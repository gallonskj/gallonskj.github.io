<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gallon&#39;s Note</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-30T02:05:06.550Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>SKJin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Queue容器</title>
    <link href="http://yoursite.com/2019/10/29/Queue%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/2019/10/29/Queue容器/</id>
    <published>2019-10-29T11:26:15.000Z</published>
    <updated>2019-10-30T02:05:06.550Z</updated>
    
    <content type="html"><![CDATA[<p>Queue主要有两类，一类是不阻塞的，一类是阻塞的。非阻塞队列主要有PriorityQueue 和 ConcurrentLinkedQueue。</p><h1 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h1><p>比如LinkedList以及ArrayDeque就是双端队列。其中，<strong>ArrayQueue是一个用数组实现的双端队列</strong>，可以在数组两端进行元素的插入以及删除，所以，这个数组必须是循环数组。<strong>LinkedList是基于双向链表的</strong>，容量没有限制，可在链表两端进行插入以及删除元素。</p><h2 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h2><p>ArrayDeque底层是一个数组。</p><p><strong>ArrayDeque是一个循环队列</strong>。它的实现比较高效，它的思路是这样：引入两个游标，head 和 tail，如果向队列里，插入一个元素，就把 tail 向后移动。如果从队列中删除一个元素，就把head向后移动。</p><h1 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h1><p>非阻塞队列主要讲一下PriorityQueue以及ConcurrentLinkedQueue。</p><p>PriorityQueue又叫做优先级队列，保存队列元素的顺序不是按照及加入队列的顺序，而是按照队列元素的大小进行重新排序。</p><ul><li><p>P<strong>riorityQueue内部实现是一个小顶堆，这样保证每次取出来的一定是最小值</strong>，他会要求你定义一个Comparable接口。<a href="https://blog.csdn.net/u013309870/article/details/71189189" target="_blank" rel="noopener">PriorityQueue</a></p></li><li><p>PriorityQueue不是线程安全的，在多线程情况下最好使用PriorityBlockingQueue 。</p></li><li><p>不允许插入 null 元素</p></li></ul><h2 id="ConcurrentLinkedQueue-ToDo"><a href="#ConcurrentLinkedQueue-ToDo" class="headerlink" title="ConcurrentLinkedQueue(ToDo)"></a>ConcurrentLinkedQueue(ToDo)</h2><p>无阻塞线程安全的队列。</p><p>如果我们要实现一个线程安全的队列有两种实现方式：一种是使用阻塞算法，另一种是使用非阻塞算法。使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现，<strong>而非阻塞的实现方式则可以使用循环 CAS 的方式来实现</strong>。</p><p>这些方法实际上是通过调用UNSAFE实例的方法,通过CAS处理是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更改Node中的数据域item</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">casItem</span><span class="params">(E cmp, E val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更改Node中的指针域next</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lazySetNext</span><span class="params">(Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">    UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更改Node中的指针域next</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://juejin.im/post/5aeeae756fb9a07ab11112af#heading-4" target="_blank" rel="noopener">ConcurrentLinkedQueue</a></p><h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><p>阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是BlockingQueue提供了可阻塞的插入和移除的方法。<strong>当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</strong></p><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>ArrayBlockingQueue = ArrayQueue+ReentrantLock+Condition。</p><p>所以，一方面，ArrayBlockingQueue使用Array做一个循环队列，另一方面，通过ReentrantLock以及Condition来实现等待唤醒操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The queued items */</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Condition for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Condition for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure><p>源码中可以看出ArrayBlockingQueue内部是<strong>采用数组进行数据存储的</strong>（<code>属性items</code>），<strong>为了保证线程安全，采用的是`ReentrantLock</strong> lock`，为了保证<strong>可阻塞式的插入删除数据利用的是Condition</strong>，当获取数据的消费者线程被阻塞时会将该线程放置到notEmpty等待队列中，当插入数据的生产者线程被阻塞时，会将该线程放置到notFull等待队列中。</p><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//如果当前队列已满，将线程移入到notFull等待队列中</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line"><span class="comment">//满足插入数据的要求，直接进行入队操作</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加数据，唤醒消费者</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line"><span class="comment">//插入数据</span></span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line"><span class="comment">//通知消费者线程，当前队列中有数据可供消费</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="take方法"><a href="#take方法" class="headerlink" title="take方法"></a>take方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//如果队列为空，没有数据，将消费者线程移入等待队列中</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line"><span class="comment">//获取数据</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出数据，唤醒生产者</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="comment">//获取数据</span></span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    <span class="comment">//通知被阻塞的生产者线程</span></span><br><span class="line">notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><ul><li><p>底层采用链表来实现。</p></li><li><p>LinkedBlockingQueue<strong>在插入数据和删除数据时分别是由两个不同的lock</strong>（<code>takeLock</code>和<code>putLock</code>）来控制线程安全的，因此，也由这两个lock生成了两个对应的condition（<code>notEmpty</code>和<code>notFull</code>）来实现可阻塞的插入和删除数据。</p></li><li><p>通过takeLock和putLock两个锁来控制生产和消费，互不干扰，不会相互因为独占锁而阻塞。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tail of linked list.</span></span><br><span class="line"><span class="comment"> * Invariant: last.next == null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Lock held by take, poll, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure></li></ul><h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><p>PriorityBlockingQueue是一个底层由数组实现的无界队列，并带有排序功能，同样采用ReentrantLock来控制并发。由于是无界的，所以插入元素时不会阻塞，没有队列满的状态，只有队列为空的状态。通过这两点特征其实可以猜测它应该是有一个独占锁（底层数组）和一个Condition（只通知消费）来实现的。</p><h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><p>DelayQueue 是一个<strong>支持延时获取元素</strong>的阻塞队列， 内部采用优先队列 <strong>PriorityQueue</strong> 存储元素，同时元素必须实现 Delayed 接口；在创建元素时可以指定多久才可以从队列中获取当前元素，<strong>只有在延迟期满时才能从队列中提取元素。</strong></p><p><img src="img/1633459982863c26" alt="1.ConcurrentLinkedQueue初始化状态.png"></p><p><a href="https://juejin.im/post/5bd1e4d7e51d4566a17a0f74#heading-2" target="_blank" rel="noopener">阻塞队列</a></p><p><img src="/_posts/img/16334a21947ee154" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Queue主要有两类，一类是不阻塞的，一类是阻塞的。非阻塞队列主要有PriorityQueue 和 ConcurrentLinkedQueue。&lt;/p&gt;
&lt;h1 id=&quot;Deque&quot;&gt;&lt;a href=&quot;#Deque&quot; class=&quot;headerlink&quot; title=&quot;De
      
    
    </summary>
    
      <category term="容器" scheme="http://yoursite.com/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="容器" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Map容器</title>
    <link href="http://yoursite.com/2019/10/26/Map%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/2019/10/26/Map容器/</id>
    <published>2019-10-26T11:45:11.000Z</published>
    <updated>2019-10-30T01:28:31.515Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><strong>HashMap 是基于哈希表的 Map 接口的实现，以 Key-Value 的形式存在</strong>，即存储的对象是 Node(同时包含了 Key 和 Value) 。</p><p>它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 <strong>HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全。</strong></p><p>在存储结构上，HashMap是<strong>数组+链表+红黑树</strong>（JDK1.8增加了红黑树部分）实现的。</p><p><img src="img/e4a19398.png" alt="img"></p><a id="more"></a><p>HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。</p><p>也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。</p><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h3><p><strong>由 Object 类定义的 hashCode 方法会针对不同的对象返回不同的整数，hashcode更像是说返回对象的摘要。</strong></p><p>重写对象的equals()必须要先重写hashCode()，两个对象相等，hashCode()一定相等，但是hashCode’()相等，不一定equals().</p><p>hashCode在遇到使用哈希表存储的数据结构时会有用。</p><p>比如说，当数据结构的元素不允许重复。一种办法就是每次出入一个元素，一个个进行比对，但是，这样，当元素个数过多的时候，效率会很低。</p><p>于是，Java采用了<strong>哈希表的原理</strong>。 这样，我们对每个要存入集合的元素使用哈希算法算出一个值，然后根据该值计算出元素应该在数组的位置。</p><p>所以，当集合要添加新的元素时，可分为两个步骤：　　</p><p>先调用这个元素的 hashCode 方法，然后根据所得到的值计算出元素应该在数组的位置。如果这个位置上没有元素，那么直接将它存储在这个位置上；</p><p>如果这个位置上已经有元素了，那么调用它的equals方法与新元素进行比较：相同的话就不存了，否则，将其存在这个位置对应的链表中（Java 中 HashSet, HashMap 和 Hashtable的实现总将元素放到链表的表头）。</p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p><strong>底层实现还是一个数组，存储的是Node(包含key-value)。</strong></p><p>Node成员：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash; <span class="comment">//hash(key.hashCode())</span></span><br><span class="line"><span class="keyword">final</span> K key; <span class="comment">//key</span></span><br><span class="line">V value;     <span class="comment">//value</span></span><br><span class="line">Node&lt;K,V&gt; next; <span class="comment">//下一个节点</span></span><br></pre></td></tr></table></figure><p>所以总的来说，HashMap底层是一个数组，而数组的每个元素存储的是一个链表，链表的每一个元素由键值对组成。</p><p><img src="assets/9420a703-1f9d-42ce-808e-bcb82b56483d.png" alt="img"></p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>initialCapacity：table数组的大小。</p><p>loadFactor：table 能够使用的比例，<strong>当table使用率超过了loadFactor，进行扩容。</strong>加载因子越大,填满的元素越多,好处是,空间利用率高了,但:冲突的机会加大了.反之,加载因子越小,填满的元素越少,好处是:冲突的机会减小了,但:空间浪费多了.默认loadFactor是0.75.因此，当我们内存比较大又对时间效率要求比较高，可以将loadFactor设置比较小，当内存比较紧张，可以将loadFactor设置比较大。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="确定数组索引位置"><a href="#确定数组索引位置" class="headerlink" title="确定数组索引位置"></a>确定数组索引位置</h4><p>使用Hash算法计算出元素应该插入到数组哪一位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line">方法二：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>计算key的hashCode。</li><li>key的hashcode并不一定在table的length之内，需要将其限制在length之内。</li><li>最简单的方法就是取余了，但是，模运算的消耗还是比较大的。jdk采用h &amp; (length-1)来解决，等价于h%length，但是效率更高。</li><li>但是，这样还有一个问题，要是table的length很小，这样h &amp; (length-1)，h只有低位会参与运算。</li><li>于是，h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)，将hashCode()的高16位异或低16位。</li></ul><h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//table是否为空，是空就创建</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//hash=hash(key)，通过hash计算需要插入的数组位置，若该位置没有元素，直接创建插入</span></span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line">           <span class="comment">//首个元素是否和key一样，如果相同直接覆盖value</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               e = p;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">               <span class="comment">//table[i]是一个红黑树，直接插入树</span></span><br><span class="line">               e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//遍历链表中的元素，假如链表长度大于规定值，反转成红黑树，</span></span><br><span class="line">               <span class="comment">//遍历过程中若发现key已经存在直接覆盖value即可</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">//这是尾插法</span></span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   p = e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                   e.value = value;</span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">//超过threshold，进行扩容</span></span><br><span class="line">       ++modCount;</span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">           resize();</span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="img/d669d29c.png" alt="img"></p><h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>默认扩容是之前数组的两倍，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                <span class="comment">//也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置</span></span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在JDK1.8，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h &amp; (length-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>因为我们每次扩展都是比上一次扩展了两倍，所以，length-1变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">扩容两倍length-<span class="number">1</span>变化：<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0111</span>-&gt;<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1111</span></span><br></pre></td></tr></table></figure><p>所以，我们在对hash做&amp;运算的时候，只需要计算变化的那个位置即可，若hash值那个位置是0，那么 h &amp; (length-1)不变，索引位置不改变；如果hash值那个位置是1，那么直接移动二次幂个位置。</p><p>一个table[i]中的key可以不一样，但是他们的hash计算是一样的。</p><h3 id="HashMap底层为什么总是2的n次方？"><a href="#HashMap底层为什么总是2的n次方？" class="headerlink" title="HashMap底层为什么总是2的n次方？"></a>HashMap底层为什么总是2的n次方？</h3><p><strong>但当底层数组的length为2的n次方时， h&amp;(length - 1) 就相当于对length取模，而且速度比直接取模快得多，这是HashMap在速度上的一个优化。</strong></p><p>这个计算方式是 ：(数组长度 - 1) &amp; hash。</p><p>数组长度是二的次方，2的2次方，二进制是 100，3次方 1000，4次方 10000。</p><p>那么按照这个规律，那么长度 - 1, 刚好是 011， 0111, 01111。这个刚好就可以当做掩码，来计算数组下标。那么就用掩码和hash做个与运算。</p><p>011    &amp; 101010100101001001101 = 01     下标=1，数组长度=4</p><p>0111  &amp; 101010100101001001101 = 101   下标=5，数组长度=8</p><p>01111 &amp; 101010100101001001101 = 1101  下标=13，数组长度=16</p><p>可以发现，通过 掩码 &amp; hash，得出的数组下标不会越界。而数组的总长度总是2的次方，就是为了方便取得掩码的。<a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">HashMap length总是2的n次方</a></p><p>所以，HashMap1.8相比1.7所做的优化主要包括两方面：</p><ul><li>红黑树。当链表中元素超过某个数值，将链表自动转化为红黑树。</li><li>resize。resize的时候不需要重新计算hash。rehash 的过程也进行了改动，基<strong>于复制的算法思想，不直接操作原链，而是定义了两条链表分别完成对原链的结点分离操作</strong>，即使是多线程的情况下也是安全的，不会产生死循环。</li></ul><h3 id="多线程问题"><a href="#多线程问题" class="headerlink" title="多线程问题"></a>多线程问题</h3><p>HashMap不是线程安全的。可能会出现以下并发问题。</p><ul><li><p>put数据丢失。</p><p>设t1执行put(“key2”, “value2”)，t2执行put(“key3”, “value3”)，并且已经有一个key1存在链表中。</p><p>理想情况是这样：</p><p><img src="img/169776786ed4a7ed" alt="hashmap10"></p></li></ul><p>但是，假设t1先执行p.next = newNode(hash, key, value, null);，但是还没有将p=key2赋值。</p><p>然后t2继续执行p.next = newNode(hash, key, value, null);，这样，p.next就会指向key3，而key2没有人指向他，就会被丢弃。</p><p><img src="img/169776786ee70c26" alt="hashmap13"></p><ul><li><p>死循环。<a href="https://www.zhihu.com/question/28516433" target="_blank" rel="noopener">死循环</a></p></li><li><p>删除数据。</p></li></ul><h3 id="HashMap与HashTable的不同"><a href="#HashMap与HashTable的不同" class="headerlink" title="HashMap与HashTable的不同"></a>HashMap与HashTable的不同</h3><ul><li>HashTable通过同步保证线程安全，锁粒度是整张表。</li><li>HashTable不允许null值。</li><li>HashTable直接使用对象的HashCode计算hash，HashMap需要通过HashCode再计算。<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2></li></ul><h3 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h3><p><img src="img/926638-20170809132445011-2033999443.png" alt="img"></p><p>Segment数组的意义就是将一个大的table分割成多个小的table来进行加锁，也就是上面的提到的<strong>锁分离技术</strong>，而每一个Segment元素存储的是HashEntry数组+链表，这个和HashMap的数据存储结构一样.默认的segment是16个。</p><p>注意，<strong>假设ConcurrentHashMap一共分为2^n个段，每个段中有2^m个桶，那么段的定位方式是将key的hash值的高n位与(2^n-1)相与。在定位到某个段后，再将key的hash值的低m位与(2^m-1)相与，定位到具体的桶位。</strong></p><h4 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h4><p><strong>Segment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。</strong>每一个segment有一个table，里面存放的是HashEntry。</p><h4 id="HashEntry"><a href="#HashEntry" class="headerlink" title="HashEntry"></a>HashEntry</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> K key;                       <span class="comment">// 声明 key 为 final 的</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;                   <span class="comment">// 声明 hash 值为 final 的</span></span><br><span class="line">       <span class="keyword">volatile</span> V value;                <span class="comment">// 声明 value 被volatile所修饰</span></span><br><span class="line">       <span class="keyword">final</span> HashEntry&lt;K,V&gt; next;      <span class="comment">// 声明 next 为 final 的</span></span><br><span class="line"></span><br><span class="line">        HashEntry(K key, <span class="keyword">int</span> hash, HashEntry&lt;K,V&gt; next, V value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; HashEntry&lt;K,V&gt;[] newArray(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashEntry[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>key，hash，next都是final，value是volatile的，<strong>因此HashEntry对象几乎是不可变的，</strong>只有value是可变的，有volatile修饰，一旦改变别的线程也可以感知到。</p><p>next是final，我们不可能从链表尾部或者是中间添加元素，只可能采用头插法。</p><p>实际上，concurrentHashMap的写操作需要对Segment加锁，但是读操作不需要加锁，这就是next是final的作用</p><h4 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h4><p><strong>需要对Segment加锁</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不允许null值</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">        <span class="keyword">return</span> segmentFor(hash).put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//段的定位方式是将key的hash值的高n位与(2^n-1)相与，2^n为segment个数</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Segment&lt;K,V&gt; <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将元素插入到segment的table中</span></span><br><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    lock();    <span class="comment">// 上锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> c = count;</span><br><span class="line">        <span class="keyword">if</span> (c++ &gt; threshold) <span class="comment">// ensure capacity</span></span><br><span class="line">            rehash();</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;    <span class="comment">// table是Volatile的</span></span><br><span class="line">        <span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);    <span class="comment">// 定位到段中特定的桶</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = tab[index];   <span class="comment">// first指向桶中链表的表头</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查该桶中是否存在相同key的结点</span></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span> &amp;&amp; (e.hash != hash || !key.equals(e.key)))  </span><br><span class="line">            e = e.next;</span><br><span class="line"></span><br><span class="line">        V oldValue;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;        <span class="comment">// 该桶中存在相同key的结点</span></span><br><span class="line">            oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                e.value = value;        <span class="comment">// 更新value值</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;         <span class="comment">// 该桶中不存在相同key的结点</span></span><br><span class="line">            oldValue = <span class="keyword">null</span>;</span><br><span class="line">            ++modCount;     <span class="comment">// 结构性修改，modCount加1</span></span><br><span class="line">            tab[index] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(key, hash, first, value);  <span class="comment">// 创建HashEntry并将其链到表头</span></span><br><span class="line">            count = c;      <span class="comment">//write-volatile，count值的更新一定要放在最后一步(volatile变量)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;    <span class="comment">// 返回旧值(该桶中不存在相同key的结点，则返回null)</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();      <span class="comment">// 在finally子句中解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>put操作时，第一步看插入的是不是<strong>null值</strong>，假如是，抛异常。</li><li><strong>定位segment</strong>。将key的hash值的高n位与(2^n-1)相与，n为segment个数。</li><li>将<strong>元素插入到segment的table内</strong>。<ul><li>对Segment的put操作是<strong>加锁</strong>完成的，segment实际上继承了ReentrantLock。这里的加锁操作是针对某个具体的Segment，锁定的也是该Segment而不是整个ConcurrentHashMap。 相比较于 HashTable 和由同步包装器包装的HashMap每次只能有一个线程执行读或写操作<strong>，ConcurrentHashMap 在并发访问性能上有了质的提高。</strong>在理想状态下，ConcurrentHashMap 可以支持 16 个线程执行并发写操作（如果并发级别设置为 16），及任意数量线程的读操作。</li><li>查看size是否超过threshold，超过了进行扩容。</li><li>定位table位置。将key的hash值的低m位与(2^m-1)相与，定位到具体位置。</li><li>插入数据。就与HashMap的过程差不多。若桶内没有元素，直接插入，若有元素，遍历整个链表，若有重复key值，直接替换，没有的话，再插入元素。</li></ul></li></ul><h4 id="rehash操作"><a href="#rehash操作" class="headerlink" title="rehash操作"></a>rehash操作</h4><p>扩容时进行的rehash操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;    <span class="comment">// 扩容前的table</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity &gt;= MAXIMUM_CAPACITY)   <span class="comment">// 已经扩到最大容量，直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 新创建一个table，其容量是原来的2倍</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable = HashEntry.newArray(oldCapacity&lt;&lt;<span class="number">1</span>);   </span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newTable.length * loadFactor);   <span class="comment">// 新的阈值</span></span><br><span class="line">    <span class="keyword">int</span> sizeMask = newTable.length - <span class="number">1</span>;     <span class="comment">// 用于定位桶</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        <span class="comment">// We need to guarantee that any existing reads of old Map can</span></span><br><span class="line">        <span class="comment">//  proceed. So we cannot yet null out each bin.</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];  <span class="comment">// 依次指向旧table中的每个桶的链表表头</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;    <span class="comment">// 旧table的该桶中链表不为空</span></span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;   <span class="comment">// 重哈希已定位到新桶</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)    <span class="comment">//  旧table的该桶中只有一个节点</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123;    </span><br><span class="line">                <span class="comment">// Reuse trailing consecutive sequence at same slot</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                     last != <span class="keyword">null</span>;</span><br><span class="line">                     last = last.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="comment">// 寻找k值相同的子链，该子链尾节点与父链的尾节点必须是同一个</span></span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// JDK直接将子链lastRun放到newTable[lastIdx]桶中</span></span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对该子链之前的结点，JDK会挨个遍历并把它们复制到新桶中</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = p.hash &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(p.key, p.hash,</span><br><span class="line">                                                     n, p.value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    table = newTable;   <span class="comment">// 扩容完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resize操作与HashMap的操作也没有多大的区别，也是将将size double，然后将元素复制到新的table中去。</p><p>但是，还有一点需要注意。</p><p>我们知道<strong>链接指针next是final的，因此看起来我们好像只能把该桶的HashEntry链中的每个节点复制到新的桶中</strong>(这意味着我们要重新创建每个节点),但事实上JDK做了一些优化。</p><p>在理论上原桶里的HashEntry链可能存在一条子链，这条子链上的节点都会被重哈希到同一个新的桶中，这样我们只要拿到该子链的头结点就可以直接把该子链放到新的桶中，从而避免了一些节点不必要的创建，提升了一定的效率。因此，JDK为了提高效率，它会首先去查找这样的一个子链，<strong>而且这个子链的尾节点必须与原hash链的尾节点是同一个</strong>（因为next是final不可变的，他只能使用头插法，所以尾部的所有元素都不能变），那么就只需要把这个子链的头结点放到新的桶中，其后面跟的一串子节点自然也就连接上了。对于这个子链头结点之前的结点，JDK会挨个遍历并把它们复制到新桶的链头(只能在表头插入元素)中。</p><p>HashMap因为next不是final，不需要新建节点，直接改指向就可以了。</p><h4 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定位segment</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">    <span class="keyword">return</span> segmentFor(hash).get(key, hash);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(Object key, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;            <span class="comment">// read-volatile，首先读 count 变量</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = getFirst(hash);   <span class="comment">// 获取桶中链表头结点</span></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; key.equals(e.key)) &#123;    <span class="comment">// 查找链中是否存在指定Key的键值对</span></span><br><span class="line">                V v = e.value;</span><br><span class="line">                <span class="keyword">if</span> (v != <span class="keyword">null</span>)  <span class="comment">// 如果读到value域不为 null，直接返回</span></span><br><span class="line">                    <span class="keyword">return</span> v;   </span><br><span class="line">                <span class="comment">// 如果读到value域为null，说明发生了重排序，加锁后重新读取</span></span><br><span class="line">                <span class="keyword">return</span> readValueUnderLock(e); <span class="comment">// recheck</span></span><br><span class="line">            &#125;</span><br><span class="line">            e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  <span class="comment">// 如果不存在，直接返回null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是有一个情况需要特别注意，就是链中存在指定Key的键值对并且其对应的Value值为null的情况。在剖析ConcurrentHashMap的put操作时，我们就知道ConcurrentHashMap不同于HashMap，它既不允许key值为null，也不允许value值为null。但是，此处怎么会存在键值对存在且的Value值为null的情形呢？JDK官方给出的解释是，这种情形发生的场景是：<strong>初始化HashEntry时发生的指令重排序导致的，也就是在HashEntry初始化完成之前便返回了它的引用。这时，JDK给出的解决之道就是加锁重读。</strong></p><h4 id="size"><a href="#size" class="headerlink" title="size"></a>size</h4><p>如果我们要统计整个 ConcurrentHashMap 里元素的大小，就必须统计所有 Segment 里元素的大小后求和。Segment 里的全局变量 count 是一个 volatile 变量，那么在多线程场景下，我们是不是直接把所有 Segment 的 count 相加就可以得到整个 ConcurrentHashMap 大小了呢？</p><p>不是的，虽然相加时可以获取每个 Segment 的 count 的最新值，但是拿到之后可能累加前使用的 count 发生了变化，那么统计结果就不准了。所以最安全的做法，是在统计 size 的时候把所有 Segment 的 put，remove 和 clean 方法全部锁住，但是这种做法显然非常低效。</p><p> 因为在累加 count 操作过程中，之前累加过的 count 发生变化的几率非常小，所以 ConcurrentHashMap 的做法是先<strong>尝试 2 次通过不锁住 Segment 的方式来统计各个 Segment 大小，如果统计的过程中，容器的 count 发生了变化，则再采用加锁的方式来统计所有 Segment 的大小。</strong></p><p>那么 ConcurrentHashMap 是如何判断在统计的时候容器是否发生了变化呢？使用 modCount 变量，在 put , remove 和 clean 方法里操作元素前都会将变量 modCount 进行加 1，那么<strong>在统计 size 前后比较 modCount 是否发生变化，从而得知容器的大小是否发生变化。</strong></p><p><strong>也是乐观锁的原理</strong>。</p><h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><p>因为next是final类型的，next不可变，所以删除元素肯定不可以直接将next指向别的元素。</p><p>对于next，只能通过新建元素通过头插法来解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Remove; match on key only if value null, else match both.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="function">V <span class="title">remove</span><span class="params">(Object key, <span class="keyword">int</span> hash, Object value)</span> </span>&#123;</span><br><span class="line">    lock();     <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> c = count - <span class="number">1</span>;      </span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);        <span class="comment">// 定位桶</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = tab[index];</span><br><span class="line">        HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span> &amp;&amp; (e.hash != hash || !key.equals(e.key)))  <span class="comment">// 查找待删除的键值对</span></span><br><span class="line">            e = e.next;</span><br><span class="line"></span><br><span class="line">        V oldValue = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;    <span class="comment">// 找到</span></span><br><span class="line">            V v = e.value;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span> || value.equals(v)) &#123;</span><br><span class="line">                oldValue = v;</span><br><span class="line">                <span class="comment">// All entries following removed node can stay</span></span><br><span class="line">                <span class="comment">// in list, but all preceding ones need to be</span></span><br><span class="line">                <span class="comment">// cloned.</span></span><br><span class="line">                ++modCount;</span><br><span class="line">                <span class="comment">// 所有处于待删除节点之后的节点原样保留在链表中</span></span><br><span class="line">                HashEntry&lt;K,V&gt; newFirst = e.next;</span><br><span class="line">                <span class="comment">// 所有处于待删除节点之前的节点被克隆到新链表中</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = first; p != e; p = p.next)</span><br><span class="line">                    newFirst = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(p.key, p.hash,newFirst, p.value); </span><br><span class="line"></span><br><span class="line">                tab[index] = newFirst;   <span class="comment">// 将删除指定节点并重组后的链重新放到桶中</span></span><br><span class="line">                count = c;      <span class="comment">// write-volatile，更新Volatile变量count</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();          <span class="comment">// finally子句解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Segment的remove操作和前面提到的get操作类似，首先根据散列码找到具体的链表，然后遍历这个链表找到要删除的节点，最<strong>后把待删除节点之后的所有节点原样保留在新链表中，把待删除节点之前的每个节点克隆到新链表中。</strong></p><p><img src="img/20170527170625098.jpg" alt="![Bremove.jpg-5kB][16]"></p><p>我们可以看出，删除节点C之后的所有节点原样保留到新链表中；删除节点C之前的每个节点被克隆到新链表中(它们在新链表中的链接顺序被反转了)。因此，<strong>在执行remove操作时，原始链表并没有被修改，也就是说，读线程不会受同时执行 remove 操作的并发写线程的干扰。</strong></p><h4 id="为何线程安全"><a href="#为何线程安全" class="headerlink" title="为何线程安全"></a>为何线程安全</h4><ul><li><strong>用HashEntery对象的不变性来降低读操作对加锁的需求；</strong></li><li><strong>用Volatile变量协调读写线程间的内存可见性；</strong>value是volatile的。</li><li><strong>若读时发生指令重排序现象，则加锁重读；</strong>由于在ConcurrentHashMap中不允许用null作为键和值，所以当读线程读到某个HashEntry的value为null时，便知道产生了冲突 —— 发生了重排序现象，此时便会加锁重新读入这个value值。</li></ul><h4 id="next为什么设置成final的呢"><a href="#next为什么设置成final的呢" class="headerlink" title="next为什么设置成final的呢"></a>next为什么设置成final的呢</h4><p>当next设置成final，肯定是不可以变的，这样读和写就可以并发执行了，也就是读操作不需要加锁。</p><p>区别：</p><ul><li>定位方式。先定位到Segment，再定位到table中的位置。</li><li>不允许插入null值，否则抛异常。</li><li>写操作需要加锁。</li></ul><h3 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h3><p>jdk 1.8 <strong>取消了基于 Segment 的分段锁思想</strong>，改用 <strong>CAS + synchronized</strong> 控制并发操作，在某些方面提升了性能。并且追随 1.8 版本的 HashMap 底层实现，使用<strong>数组+链表+红黑树进行数据存储</strong>。</p><p><img src="img/e6ac01f07ca641a54ff6f17c41a386df" alt="ConcurrentHashMap结构图"></p><h4 id="关键成员"><a href="#关键成员" class="headerlink" title="关键成员"></a>关键成员</h4><p><strong>table</strong> volatile Node&lt;K,V&gt;[] table://装载Node的数组，作为ConcurrentHashMap的数据容器，<strong>采用懒加载的方</strong>式，直到第一次插入数据的时候才会进行初始化操作，数组的大小总是为2的幂次方。</p><p><strong>nextTable</strong> volatile Node&lt;K,V&gt;[] nextTable; //扩容时使用，平时为null，只有在扩容的时候才为非null</p><p><strong>sizeCtl</strong> : -1表示正在初始化 -N则表示当前正有N-1个线程进行扩容操作。</p><p>​                正数：table未初始化，表示需要新建数组长度；table初始化了，表示table可用容量。</p><h4 id="一些内部类"><a href="#一些内部类" class="headerlink" title="一些内部类"></a>一些内部类</h4><p>Node：存放key-value。</p><p><strong>TreeNode</strong> 树节点，继承于承载数据的Node类。</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line"><span class="comment">//1. 小于0直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"><span class="comment">//2. 判断是否超过了允许的最大值，超过了话则取最大值，否则再对该值进一步处理</span></span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line"><span class="comment">//3. 赋值给sizeCtl</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = c - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的有两点。</p><ul><li><strong>ConcurrentHashMap的大小一定是2的幂次方</strong>，比如，当指定大小为18时，为了满足2的幂次方特性，实际上concurrentHashMapd的大小为2的5次方（32）。</li><li>在构造方法中，并没有初始化table<strong>，这是一个懒加载，直到插入第一个元素才会初始化table。</strong></li></ul><h4 id="initTable方法"><a href="#initTable方法" class="headerlink" title="initTable方法"></a>initTable方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 1. 保证只有一个线程正在进行初始化操作</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 2. 得出数组的大小</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="comment">// 3. 这里才真正的初始化数组</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line"><span class="comment">// 4. 计算数组中可用的大小：实际大小n*0.75（加载因子）</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>当sizeCtl&lt;0时，表明已有一个线程对其进行初始化，因此当前线程让出CPU。</p></li><li><p>进行初始化的线程需要将sizeCtl设置为-1（CAS），而且数组的容量为0.75*数组实际大小n。</p></li></ul><h4 id="put方法-1"><a href="#put方法-1" class="headerlink" title="put方法"></a>put方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"><span class="comment">//1. 计算key的hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line"><span class="comment">//2. 如果当前table还没有初始化先调用initTable方法将tab进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line"><span class="comment">//3. tab中索引为i的位置的元素为null，则直接使用CAS将值插入即可</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//4. 当前正在扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line"><span class="comment">//5. 当前为链表，在链表中插入新的键值对</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">// 6.当前为红黑树，将新的键值对插入到红黑树中</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 7.插入完键值对后再根据实际大小看是否需要转换成红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//8.对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容 </span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>ConcurrentHashMap不接受null值，假如传入的null值，直接抛异常。</p></li><li><p>计算hash，<strong>将key的hashCode的低16位于高16位进行异或运算</strong>。</p></li><li><p>初始化table。</p></li><li><p>计算table中索引位置。(n - 1) &amp; hash</p></li><li><p>确定好数组的索引i后，就可以可以tabAt()方法(这是线程安全的，调用了Unsafe的方法)，获取该位置的元素情况。</p></li><li><p>假如没有元素，直接使用casTabAt方法将新值插入。</p></li><li><p>如果当前节点不为null，且该节点为特殊节点（forwardingNode）的话（该节点hash=-1），就说明当前concurrentHashMap正在进行扩容操作.</p></li><li><p>插入新值。<strong>需要加锁</strong>。</p><ul><li>如果是链表节点（fh&gt;0）； 1.在链表中如果找到了与待插入的键值对的key相同的节点，就<strong>直接覆盖即可</strong>；2. 如果直到找到了链表的末尾都没有找到的话，就直接将待插入的键值对<strong>追加到链表的末尾</strong>即可。</li><li>当table[i]为红黑树的根节点，在红黑树中插入新值。</li></ul></li><li><p>插入完新节点后，查看链表长度是否超过设定值，是否需要将其转成红黑树。</p></li><li><p>对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容。</p></li></ul><h4 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h4><p>ConcurrentHashMap主要采用并发扩容的方式，给每个线程分配一定的区间，<strong>每个线程扩容自己所分配到的那段</strong>，当执行完自己的那一段，若还没有扩容完成，<strong>可以继续申请区间</strong>，直到扩容完毕。</p><ul><li><p>区间怎么定，根据CPU来平均分配，保证每个线程分配时均匀的。</p></li><li><p>第一个线程扩容时，会将sizeCtl设置为-1，再来一个，sizeCtl再减去1，当线程执行完扩容，sizeCtl+1.这样，就可以判断是否有线程再扩容。</p></li><li><p>当线程拿到某个桶的时候，会将一个ForwardingNode，这样，其他线程再看到这个占位符的时候，就会helptransfer。</p></li><li><p>那么线程如何处理自己的区间呢？</p><ul><li><p>会有一个bound参数，这个参数指的是该线程此次可以处理的区间的最小下标，<strong>超过这个下标，就需要重新领取区间</strong>或者结束扩容。</p></li><li><p>每次处理自己的桶的时候，需要加锁。如果这个桶是链表，那么就将这个链表根据 length 取于拆成两份，取于结果是 0 的放在新表的低位，取于结果是 1 放在新表的高位。红黑树也类似。</p><p><img src="img/1637856068bf02ed" alt="img"></p></li></ul></li></ul><p>当第一个线程扩容会将sizeCtl设置为-1，</p><p>通过给每个线程分配桶区间，避免线程间的争用，通过为每个桶节点加锁，避免 putVal 方法导致数据不一致。同时，在扩容的时候，也会将链表拆成两份，这点和 HashMap 的 resize 方法类似。</p><p>而如果有新的线程想 put 数据时，也会帮助其扩容。鬼斧神工，令人赞叹。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Moves and/or copies the nodes in each bin to new table. See</span></span><br><span class="line"><span class="comment"> * above for explanation.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * transferIndex 表示转移时的下标，初始为扩容前的 length。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 我们假设长度是 32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">// 将 length / 8 然后除以 CPU核心数。如果得到的结果小于 16，那么就使用 16。</span></span><br><span class="line">    <span class="comment">// 这里的目的是让每个 CPU 处理的桶一样多，避免出现转移任务不均匀的现象，如果桶较少的话，默认一个 CPU（一个线程）处理 16 个桶</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range 细分范围 stridea：TODO</span></span><br><span class="line">    <span class="comment">// 新的 table 尚未初始化</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 扩容  2 倍</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 更新</span></span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            <span class="comment">// 扩容失败， sizeCtl 使用 int 最大值。</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">// 结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新成员变量</span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">// 更新转移下标，就是 老的 tab 的 length</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新 tab 的 length</span></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">// 创建一个 fwd 节点，用于占位。当别的线程发现这个槽位中是 fwd 类型的节点，则跳过这个节点。</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">// 首次推进为 true，如果等于 true，说明需要再次推进一个下标（i--），反之，如果是 false，那么就不能推进下标，需要将当前的下标处理完毕才能继续推进</span></span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 完成状态，如果是 true，就结束此方法。</span></span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="comment">// 死循环,i 表示下标，bound 表示当前线程可以处理的当前桶区间最小下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="comment">// 如果当前线程可以向后推进；这个循环就是控制 i 递减。同时，每个线程都会进入这里取得自己需要转移的桶的区间</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="comment">// 对 i 减一，判断是否大于等于 bound （正常情况下，如果大于 bound 不成立，说明该线程上次领取的任务已经完成了。那么，需要在下面继续领取任务）</span></span><br><span class="line">            <span class="comment">// 如果对 i 减一大于等于 bound（还需要继续做任务），或者完成了，修改推进状态为 false，不能推进了。任务成功后修改推进状态为 true。</span></span><br><span class="line">            <span class="comment">// 通常，第一次进入循环，i-- 这个判断会无法通过，从而走下面的 nextIndex 赋值操作（获取最新的转移下标）。其余情况都是：如果可以推进，将 i 减一，然后修改成不可推进。如果 i 对应的桶处理成功了，改成可以推进。</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;<span class="comment">// 这里设置 false，是为了防止在没有成功处理一个桶的情况下却进行了推进</span></span><br><span class="line">            <span class="comment">// 这里的目的是：1. 当一个线程进入时，会选取最新的转移下标。2. 当一个线程处理完自己的区间时，如果还有剩余区间的没有别的线程处理。再次获取区间。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果小于等于0，说明没有区间了 ，i 改成 -1，推进状态变成 false，不再推进，表示，扩容结束了，当前线程可以退出了</span></span><br><span class="line">                <span class="comment">// 这个 -1 会在下面的 if 块里判断，从而进入完成状态判断</span></span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;<span class="comment">// 这里设置 false，是为了防止在没有成功处理一个桶的情况下却进行了推进</span></span><br><span class="line">            &#125;<span class="comment">// CAS 修改 transferIndex，即 length - 区间值，留下剩余的区间值供后面的线程使用</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;<span class="comment">// 这个值就是当前线程可以处理的最小当前区间最小下标</span></span><br><span class="line">                i = nextIndex - <span class="number">1</span>; <span class="comment">// 初次对i 赋值，这个就是当前线程可以处理的当前区间的最大下标</span></span><br><span class="line">                advance = <span class="keyword">false</span>; <span class="comment">// 这里设置 false，是为了防止在没有成功处理一个桶的情况下却进行了推进，这样对导致漏掉某个桶。下面的 if (tabAt(tab, i) == f) 判断会出现这样的情况。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">// 如果 i 小于0 （不在 tab 下标内，按照上面的判断，领取最后一段区间的线程扩容结束）</span></span><br><span class="line">        <span class="comment">//  如果 i &gt;= tab.length(不知道为什么这么判断)</span></span><br><span class="line">        <span class="comment">//  如果 i + tab.length &gt;= nextTable.length  （不知道为什么这么判断）</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123; <span class="comment">// 如果完成了扩容</span></span><br><span class="line">                nextTable = <span class="keyword">null</span>;<span class="comment">// 删除成员变量</span></span><br><span class="line">                table = nextTab;<span class="comment">// 更新 table</span></span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>); <span class="comment">// 更新阈值</span></span><br><span class="line">                <span class="keyword">return</span>;<span class="comment">// 结束方法。</span></span><br><span class="line">            &#125;<span class="comment">// 如果没完成</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;<span class="comment">// 尝试将 sc -1. 表示这个线程结束帮助扩容了，将 sc 的低 16 位减一。</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)<span class="comment">// 如果 sc - 2 不等于标识符左移 16 位。如果他们相等了，说明没有线程在帮助他们扩容了。也就是说，扩容结束了。</span></span><br><span class="line">                    <span class="keyword">return</span>;<span class="comment">// 不相等，说明没结束，当前线程结束方法。</span></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;<span class="comment">// 如果相等，扩容结束了，更新 finising 变量</span></span><br><span class="line">                i = n; <span class="comment">// 再次循环检查一下整张表</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>) <span class="comment">// 获取老 tab i 下标位置的变量，如果是 null，就使用 fwd 占位。</span></span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);<span class="comment">// 如果成功写入 fwd 占位，再次推进一个下标</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)<span class="comment">// 如果不是 null 且 hash 值是 MOVED。</span></span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed // 说明别的线程已经处理过了，再次推进一个下标</span></span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">// 到这里，说明这个位置有实际值了，且不是占位符。对这个节点上锁。为什么上锁，防止 putVal 的时候向链表插入数据</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 判断 i 下标处的桶节点是否和 f 相同</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;<span class="comment">// low, height 高位桶，低位桶</span></span><br><span class="line">                    <span class="comment">// 如果 f 的 hash 值大于 0 。TreeBin 的 hash 是 -2</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 对老长度进行与运算（第一个操作数的的第n位于第二个操作数的第n位如果都是1，那么结果的第n为也为1，否则为0）</span></span><br><span class="line">                        <span class="comment">// 由于 Map 的长度都是 2 的次方（000001000 这类的数字），那么取于 length 只有 2 种结果，一种是 0，一种是1</span></span><br><span class="line">                        <span class="comment">//  如果是结果是0 ，Doug Lea 将其放在低位，反之放在高位，目的是将链表重新 hash，放到对应的位置上，让新的取于算法能够击中他。</span></span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f; <span class="comment">// 尾节点，且和头节点的 hash 值取于不相等</span></span><br><span class="line">                        <span class="comment">// 遍历这个桶</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="comment">// 取于桶中每个节点的 hash 值</span></span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="comment">// 如果节点的 hash 值和首节点的 hash 值取于结果不同</span></span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b; <span class="comment">// 更新 runBit，用于下面判断 lastRun 该赋值给 ln 还是 hn。</span></span><br><span class="line">                                lastRun = p; <span class="comment">// 这个 lastRun 保证后面的节点与自己的取于值相同，避免后面没有必要的循环</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;<span class="comment">// 如果最后更新的 runBit 是 0 ，设置低位节点</span></span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun; <span class="comment">// 如果最后更新的 runBit 是 1， 设置高位节点</span></span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;<span class="comment">// 再次循环，生成两个链表，lastRun 作为停止条件，这样就是避免无谓的循环（lastRun 后面都是相同的取于结果）</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="comment">// 如果与运算结果是 0，那么就还在低位</span></span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>) <span class="comment">// 如果是0 ，那么创建低位节点</span></span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span> <span class="comment">// 1 则创建高位</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 其实这里类似 hashMap </span></span><br><span class="line">                        <span class="comment">// 设置低位链表放在新链表的 i</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 设置高位链表，在原有长度上加 n</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 将旧的链表设置成占位符</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">// 继续向后推进</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;<span class="comment">// 如果是红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="comment">// 遍历</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="comment">// 和链表相同的判断，与运算 == 0 的放在低位</span></span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125; <span class="comment">// 不是 0 的放在高位</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果树的节点数小于等于 6，那么转成链表，反之，创建一个新的树</span></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        <span class="comment">// 低位树</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 高位数</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 旧的设置成占位符</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">// 继续向后推进</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>HashMap是无序的，也就是说，迭代HashMap所得到的元素顺序并不是它们最初放置到HashMap的顺序。</p><p>LinkedHashMap解决了这个问题，<strong>它通过一个双向列表保证了迭代顺序</strong>。这个顺序可以是插入顺序，也可以是访问顺序，默认是插入顺序。所以，实际上，LinkedHashMap = HashMap+双向链表。</p><p>LinkedHashMap整个大致存储结构与HashMap没有差别，主要就是在各个节点之间添加了before以及after指针，使这些节点形成了一个双链表。</p><p>但是LinkedHashMap是非线程安全的。</p><p><img src="img/4843132-7abca1abd714341d.webp" alt="img"></p><p>红色的是一个双向链表。也就是说，当我们插入一个元素的时候，除了要插入到HashMap中，还要插入到双向链表中。</p><h3 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Entry除了有HashMap的成员外，还有before和after两个指针。 </span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; before, after;</span><br><span class="line">        Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个三个参数的，accessOrder代表迭代顺序，他是按照插入顺序还是访问顺序来完成的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">float</span> loadFactor,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);   <span class="comment">// 调用HashMap对应的构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.accessOrder = accessOrder;    <span class="comment">// 迭代顺序的默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put方法-2"><a href="#put方法-2" class="headerlink" title="put方法"></a>put方法</h3><p>LinkedHashMap完全继承了HashMap的 put(Key,Value) 方法，只是对put(Key,Value)方法所调用的recordAccess方法和addEntry方法进行了重写（1.7），1.8是对new Node重写，不过也差不多，<strong>都是对插入元素这块进行了重写</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加到双链表尾部</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>相比HashMap而言，LinkedHashMap在向哈希表添加一个键值对的同时，也会将其链入到它所维护的双向链表中，以便设定迭代顺序。</strong></p><h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h3><p>get方法跟HahMap也差不多，只不过多了一步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//假如是该LinkedHashMap按照访问顺序迭代，需要将访问过的元素放到队尾</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>LinkedHashMap是继承于HashMap，是基于HashMap和双向链表来实现的。</li><li>HashMap无序；LinkedHashMap有序，可分为插入顺序和访问顺序两种。</li><li>LinkedHashMap是线程不安全的</li></ul><h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2><p>如果<strong>map里面的key只有map本身引用时，就会将key对应的Entry清除掉。</strong>主要是因为Entry继承了WeakReference类，是弱引用。</p><h2 id="ConcurrentSkipListMap-ToDo"><a href="#ConcurrentSkipListMap-ToDo" class="headerlink" title="ConcurrentSkipListMap(ToDo)"></a>ConcurrentSkipListMap(ToDo)</h2><p><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">美团技术：HashMap in JDK8</a></p><p><a href="https://blog.csdn.net/justloveyou_/article/details/72783008" target="_blank" rel="noopener">ConcurrentHashMap in JDK7</a></p><p><a href="https://juejin.im/post/5aeeaba8f265da0b9d781d16#heading-5" target="_blank" rel="noopener">ConcurrentHashMap in JDK8</a></p><p><a href="https://juejin.im/post/5b00160151882565bd2582e0" target="_blank" rel="noopener">ConcurrentHashMap in JDK8 transfer method</a></p><p><a href="https://blog.csdn.net/justloveyou_/article/details/71713781" target="_blank" rel="noopener">LinkedHashMap</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HashMap&quot;&gt;&lt;a href=&quot;#HashMap&quot; class=&quot;headerlink&quot; title=&quot;HashMap&quot;&gt;&lt;/a&gt;HashMap&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;HashMap 是基于哈希表的 Map 接口的实现，以 Key-Value 的形式存在&lt;/strong&gt;，即存储的对象是 Node(同时包含了 Key 和 Value) 。&lt;/p&gt;
&lt;p&gt;它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 &lt;strong&gt;HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在存储结构上，HashMap是&lt;strong&gt;数组+链表+红黑树&lt;/strong&gt;（JDK1.8增加了红黑树部分）实现的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;img/e4a19398.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="容器" scheme="http://yoursite.com/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="容器" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>容器</title>
    <link href="http://yoursite.com/2019/10/19/%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/2019/10/19/容器/</id>
    <published>2019-10-19T11:28:19.000Z</published>
    <updated>2019-10-28T06:02:00.977Z</updated>
    
    <content type="html"><![CDATA[<p>容器主要包括 <strong>Collection 和 Map</strong> 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p><img src="img/1571485852603-1571485852609.png" alt="img"></p><p>Collection主要分为三类：Set，List，Queue。</p><p>Set是无序存储，而且不会存储重复的元素。</p><p>Queue是一个队列，只能从一端插入元素，从另一端取出元素。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><img src="img/1571485852603-1571485852609-1572012322950.png" alt="img"></p><p>Map存储的是键值对。</p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList的底层实现是一个数组，其访问速度比较快，但是插入删除速度比较慢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//transient表示这个成员不可以被序列化</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是旧容量的 1.5 倍。</p><p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查index是否合法</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//需要将index+1后面的位置都往前移动</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步,是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩容-1"><a href="#扩容-1" class="headerlink" title="扩容"></a>扩容</h3><p>Vector 的构造函数可以传入 capacityIncrement 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement。如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="与ArrayList不同"><a href="#与ArrayList不同" class="headerlink" title="与ArrayList不同"></a>与ArrayList不同</h3><ul><li>加了synchronized关键字，是线程安全的。</li><li>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。</li></ul><p>但是，一般来说，在面对多线程的情况，我们也很少使用Vector，因为效率比较低。</p><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>CopyOnWriteArrayList也是基于写时复制以及读写分离的思想。</p><p>当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，<strong>复制出一个新的容器</strong>，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。对CopyOnWrite容器进行并发的读的时候，不需要加锁，因为当前容器不会添加任何元素。</p><p>CopyOnWriteArrayList内部维护了一个数组，而且是volatile的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets the array.  Non-private so as to also be accessible</span></span><br><span class="line"><span class="comment"> * from CopyOnWriteArraySet class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现非常简单，因为根据写时复制，读取数据的时候数据不会修改，所以肯定是线程安全的。</p><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line"><span class="comment">//1. 使用Lock,保证写线程在同一时刻只有一个</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//2. 获取旧数组引用</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line"><span class="comment">//3. 创建新的数组，并将旧数组的数据复制到新数组中</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//4. 往新数组中添加新的数据        </span></span><br><span class="line">newElements[len] = e;</span><br><span class="line"><span class="comment">//5. 将旧数组引用指向新的数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>需要添加lock，避免出现多个线程写数据。</li><li>将旧数组拷贝，对新数组进行写操作，操作完成将数组引用指向新数据。</li><li>实际上核心就是读写其实是在两个不同的容器中，所以就可以进行同时读写。</li></ul><h3 id="与读写锁区别"><a href="#与读写锁区别" class="headerlink" title="与读写锁区别"></a>与读写锁区别</h3><p>COW与读写锁都使用了读写分离的思想，都可以同时多个线程读。</p><p>但是COW读写线程是可以同时的。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>数据一致性问题。COW实际上会有读延迟情况的发生。所以，假如对数据实时一致性很高，最好不使用COW。</li><li>内存问题。COW每次写数据都需要重新拷贝一个数组，假如高并发写或者对象比较大，会造成频繁GC。COW其实是不适用于高并发频繁写的场景。</li></ul><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>基于双向链表实现。</p><p><img src="img/1571492127073-1571492127077.png" alt="img"></p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>Set的核心概念就是<strong>集合内所有元素不重复</strong>。</p><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>基于HashTable实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>意思就是HashSet的集合其实就是HashMap的key的集合，然后HashMap的val默认都是PRESENT。HashMap的定义即是key不重复的集合。使用HashMap实现，这样HashSet就不需要再实现一遍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历的是HashMap的key</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>LinkedHashSet会根据add，remove这些操作的顺序在遍历时返回固定的集合顺序。</p><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>基于TreeMap实现。</p><p>TreeSet即是一组有次序的集合，如果没有指定排序规则Comparator，则会按照自然排序。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md" target="_blank" rel="noopener">Java容器</a></p><p><a href="https://juejin.im/post/5aeeb55f5188256715478c21" target="_blank" rel="noopener">CopyOnWriteArrayList</a></p><p><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">HashMap in JDK1.8</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;容器主要包括 &lt;strong&gt;Collection 和 Map&lt;/strong&gt; 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。&lt;/p&gt;
&lt;h2 id=&quot;Collection&quot;&gt;&lt;a href=&quot;#Collection&quot; cla
      
    
    </summary>
    
      <category term="容器" scheme="http://yoursite.com/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="容器" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>并发容器</title>
    <link href="http://yoursite.com/2019/10/19/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/2019/10/19/并发容器/</id>
    <published>2019-10-19T11:22:11.000Z</published>
    <updated>2019-10-19T11:37:28.780Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="容器" scheme="http://yoursite.com/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="容器" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://yoursite.com/2019/10/19/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2019/10/19/线程池/</id>
    <published>2019-10-19T08:03:48.000Z</published>
    <updated>2019-10-30T01:28:26.872Z</updated>
    
    <content type="html"><![CDATA[<p>线程池主要是为了避免频繁创建线程和销毁线程。当单个任务处理时间比较长或者是需要处理的任务量很大，为了避免系统效率降低，可以创建线程池，复用线程。</p><a id="more"></a><h2 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//五个参数的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span></span></span><br></pre></td></tr></table></figure><ul><li><p>corePoolSize,核心线程数。</p><p>线程池新建线程的时候，如果当前线程总数小于corePoolSize，则新建的是核心线程，如果超过corePoolSize，则新建的是非核心线程。</p><p>即使<strong>核心线程处于闲置状态，核心线程也不会被销毁</strong>。</p></li><li><p>maximumPoolSize,最大线程数。线程池中能创建的最大的线程数。</p></li><li><p>keepAliveTime.当<strong>非核心线程数闲置时长超过keepAliveTime,就会将其销毁。</strong></p></li><li><p>workQueue。</p><p>该线程池中的任务队列：维护着等待执行的Runnable对象。</p><p>当所有的核心线程都在干活时，<strong>新添加的任务会被添加到这个队列中等待处理，如果队列满了，则新建非核心线程执行任务</strong>。</p><p>可以使用无界队列或者是有界队列。</p><p>使用无界队列的话，这样队列永远不会满，也就是说线程池内线程数只能是核心线程数。</p></li></ul><h2 id="ThreadPoolExecutor的策略"><a href="#ThreadPoolExecutor的策略" class="headerlink" title="ThreadPoolExecutor的策略"></a>ThreadPoolExecutor的策略</h2><p>当一个任务被添加进线程池时：</p><ol><li>线程数量未达到corePoolSize，则新建一个线程(核心线程)执行任务</li><li>线程数量达到了corePoolSize，则将任务移入队列等待</li><li>队列已满，新建线程(非核心线程)执行任务</li><li>队列已满，总线程数又达到了maximumPoolSize，抛出异常</li></ol><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/19/1571483685643-1571483685947.png" alt="title"></p><p><strong>饱和策略 (RejectedExecutionHandler)</strong>：当等待队列已满，线程数也达到最大线程数时，线程池会根据饱和策略来执行后续操作，默认的策略是抛弃要加入的任务。</p><h2 id="线程池种类"><a href="#线程池种类" class="headerlink" title="线程池种类"></a>线程池种类</h2><ul><li><p>newFixedThreadPool，固定线程数的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>newCachedThreadPool。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>newScheduledThreadPool().</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DelayedWorkQueue 这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>newSingleThreadPool().</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h2><p>关闭线程池，可以通过<code>shutdown</code>和<code>shutdownNow</code>这两个方法。它们的原理都是遍历线程池中所有的线程，然后依次中断线程。<code>shutdown</code>和<code>shutdownNow</code>还是有不一样的地方：</p><ol><li><code>shutdownNow</code>首先将线程池的状态设置为<strong>STOP</strong>,然后尝试<strong>停止所有的正在执行和未执行任务</strong>的线程，并返回等待执行任务的列表；</li><li><code>shutdown</code>只是将线程池的状态设置为<strong>SHUTDOWN</strong>状态，<strong>然后中断所有没有正在执行任务的线程</strong></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线程池主要是为了避免频繁创建线程和销毁线程。当单个任务处理时间比较长或者是需要处理的任务量很大，为了避免系统效率降低，可以创建线程池，复用线程。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Semaphore and CountDownLatch</title>
    <link href="http://yoursite.com/2019/10/16/%C2%96Semaphore-and-CountDownLatch/"/>
    <id>http://yoursite.com/2019/10/16/Semaphore-and-CountDownLatch/</id>
    <published>2019-10-16T02:41:50.000Z</published>
    <updated>2019-10-22T06:30:31.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore叫做信号量，是一种共享锁，当其permit大于0时，线程可以获取锁，当permits小于0时，线程只能等待获取锁，等其他线程释放。</p><p>Semophore也有公平锁和非公平锁两种状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公平共享锁尝试获取acquires个信号量</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors()) <span class="comment">//前面是否有排队，有则返回获取失败</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> available = getState(); <span class="comment">//剩余的信号量（旋转寿司店剩余的座位）</span></span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining)) <span class="comment">// 剩余信号量不够，够的情况下尝试获取（旋转寿司店座位不够，或者同时来两对情况抢座位）</span></span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非公平共享锁尝试获取acquires个信号量</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> available = getState(); <span class="comment">//剩余的信号量（旋转寿司店剩余的座位）</span></span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining)) <span class="comment">// 剩余信号量不够，够的情况下尝试获取（旋转寿司店座位不够，或者同时来两对情侣抢座位）</span></span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch用于协调多个线程的同步，能让一个线程在等待其他线程执行完任务后，再继续执行。内部是通过一个计数器去完成实现。</p><p>CountDownLatch是通过<strong>一个计数器</strong>来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，可以调用<strong>countDown()，计数器的值就会减1</strong>。当计数器值到达0时，它表示所有的线程已经完成了任务，然后<strong>在闭锁上等待的线程(使用await()阻塞)就可以恢复执行任务</strong>。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><p>一个线程执行需要等待其他线程执行完毕，才能继续执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">"---start"</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">"---finish"</span>);</span><br><span class="line">               <span class="comment">//计数器减一</span></span><br><span class="line">               latch.countDown();</span><br><span class="line">           &#125;).start();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//将主线程阻塞在latch，直到latch的计数器等于0</span></span><br><span class="line">           latch.await();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">"执行完毕-----"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>CountDownLatch通过state来表示计数器。</p><ul><li>await() 将当前线程阻塞在CountDownLatch上，直到计数器的数量减少至0.</li><li>await(long timeout, TimeUnit unit)，与await()不同的是，设置了超时等待，等到了时间，不管计数器是不是0，都会继续执行。</li><li>countDown()，计数器数量减一。当计数器数量减为0时，将await()的线程唤醒。</li></ul><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</p><p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p><p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。</p><p>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。</p><p><img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/f71af66b-0d54-4399-a44b-f47b58321984.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Semaphore&quot;&gt;&lt;a href=&quot;#Semaphore&quot; class=&quot;headerlink&quot; title=&quot;Semaphore&quot;&gt;&lt;/a&gt;Semaphore&lt;/h2&gt;&lt;p&gt;Semaphore叫做信号量，是一种共享锁，当其permit大于0时，线程可以获取锁
      
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>读写锁</title>
    <link href="http://yoursite.com/2019/10/14/%E8%AF%BB%E5%86%99%E9%94%81/"/>
    <id>http://yoursite.com/2019/10/14/读写锁/</id>
    <published>2019-10-14T07:30:06.000Z</published>
    <updated>2019-10-22T12:04:09.127Z</updated>
    
    <content type="html"><![CDATA[<p>ReentrantReadWriteLock：一个资源能够被<strong>多个读线程访问</strong>，或者被<strong>一个写线程访问</strong>，但是<strong>不能同时存在读写线程</strong>。</p><p>读锁是共享锁，可以有多个线程读；而写锁是独占锁，同时只可能有一个线程写。</p><h2 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h2><p>读锁可以多线程访问，写锁只可以有一个线程访问，我们很容易想到可以使用两个变量来表示读写状态。但是，AQS却只是使用一个state来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns the number of shared holds represented in count  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"><span class="comment">/** Returns the number of exclusive holds represented in count  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure><p>举个例子来看：</p><p>这里有两个关键方法sharedCount和exclusiveCount，通过名字可以看出sharedCount是共享锁的数量，exclusiveCount是独占锁的数量。</p><p><strong>共享锁通过对c像右位移16位获得，独占锁通过和16位的1与运算获得。</strong></p><p>state前十六位代表读锁，后十六位代表写锁。</p><p>举个例子，当获取读锁的线程有3个，写锁的线程有1个（当然这是不可能同时有的），state就表示为0000 0000 0000 0011 0000 0000 0000 0001，高16位代表读锁，通过向右位移16位（c &gt;&gt;&gt; SHARED_SHIFT）得倒10进制的3，通过和0000 0000 0000 0000 1111 1111 1111 1111与运算（c &amp; EXCLUSIVE_MASK），获得10进制的1。</p><p>由于16位最大全1表示为65535，<strong>所以读锁和写锁最多可以获取65535个</strong>。</p><h2 id="WriteLock"><a href="#WriteLock" class="headerlink" title="WriteLock"></a>WriteLock</h2><p>写锁是一把独占锁，同时只可能有一个线程访问，而且不可能与读锁同时存在，所以与ReentrantLock不同的是，<strong>WriteLock不仅要判断是否还有其它写线程占用，还要考虑是否还有读线程占用</strong>。</p><p>读锁是否存在。因为要确保写锁的操作对读锁是<strong>可见的</strong>。如果在存在读锁的情况下允许获取写锁，那么那些已经获取读锁的其他线程可能就无法感知当前写线程的操作。因此只有等读锁完全释放后，写锁才能够被当前线程所获取，一旦写锁获取了，所有其他读、写线程均会被阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();  <span class="comment">//获取共享变量state</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">//获取写锁数量</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123; <span class="comment">//有读锁或者写锁</span></span><br><span class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread()) <span class="comment">//写锁为0（证明有读锁），或者持有写锁的线程不为当前线程</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// Reentrant acquire</span></span><br><span class="line">        setState(c + acquires);  <span class="comment">//当前线程持有写锁，为重入锁，+acquires即可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires)) <span class="comment">//CAS操作失败，多线程情况下被抢占，获取锁失败。CAS成功则获取锁成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h2><p>在获取写锁的时候，如果资源存在读锁，因为可能存在多个不同的线程读，要是修改了线程除了本线程别的线程也感知不到，那么肯定是无法获取写锁的。</p><p>但是，在获取读锁的时候， 如果对资源加了写锁，其他线程无法再获得写锁与读锁，但是持有写锁的线程，可以对资源加读锁（锁降级），主要原因是因为在同一个线程内，写锁所做的修改读锁时立即可见的，但是在别的线程内就没有可见性了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">   Object data;</span><br><span class="line">     <span class="comment">//保证状态可见性</span></span><br><span class="line">   <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;</span><br><span class="line">   ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     rwl.readLock().lock();</span><br><span class="line">     <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">        <span class="comment">// 在获取写锁前必须释放读锁</span></span><br><span class="line">        rwl.readLock().unlock();</span><br><span class="line">        rwl.writeLock().lock();</span><br><span class="line">        <span class="comment">//再次检查其他线程是否已经抢到  </span></span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">           <span class="comment">//获取数据</span></span><br><span class="line">          data = ...</span><br><span class="line">          cacheValid = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在释放写锁之前通过获取读锁来降级</span></span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        <span class="comment">//释放写锁，保持读锁</span></span><br><span class="line">        rwl.writeLock().unlock();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     use(data);</span><br><span class="line">     rwl.readLock().unlock();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="ReadLock"><a href="#ReadLock" class="headerlink" title="ReadLock"></a>ReadLock</h2><ul><li>申请读锁，资源上没有写锁，且读锁数量小于最大值，申请读锁成功。</li><li>申请读锁，资源上有写锁，且写锁就在本线程上，那么申请成功。</li></ul><p><a href="http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/" target="_blank" rel="noopener">读写锁</a></p><p><a href="https://blog.51cto.com/viphyy/2092670" target="_blank" rel="noopener">锁降级</a></p><p><a href="https://juejin.im/post/5b9df6015188255c8f06923a#heading-8" target="_blank" rel="noopener">读写锁</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ReentrantReadWriteLock：一个资源能够被&lt;strong&gt;多个读线程访问&lt;/strong&gt;，或者被&lt;strong&gt;一个写线程访问&lt;/strong&gt;，但是&lt;strong&gt;不能同时存在读写线程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;读锁是共享锁，可以有多个线程读；
      
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>ReentranrLock</title>
    <link href="http://yoursite.com/2019/10/13/ReentranrLock/"/>
    <id>http://yoursite.com/2019/10/13/ReentranrLock/</id>
    <published>2019-10-13T07:18:24.000Z</published>
    <updated>2019-10-14T07:29:26.827Z</updated>
    
    <content type="html"><![CDATA[<p>ReentrantLock是可重入锁，它实现了Lock接口。</p><p>可重入锁就是说同一个线程可以多次申请到该锁。</p><p>ReentrantLock有公平锁和非公平锁两种方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> *     lock.lock();  <span class="comment">// block until condition holds</span></span><br><span class="line"> *     <span class="keyword">try</span> &#123;</span><br><span class="line"> *       <span class="comment">// ... method body</span></span><br><span class="line"> *     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> *       lock.unlock()</span><br><span class="line"> *     &#125;</span><br><span class="line"> *   &#125;</span><br></pre></td></tr></table></figure><p>使用lock和unlock进行加锁和解锁。</p><p>而lock和unlock都是调用sync的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sync是ReentranrtLock的成员变量，他继承了AQS,所以，核心是AQS的实现，而且<strong>有两个内部类，一个可以实现公平锁，一个实现非公平锁</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>在构造函数中可以定义是公平锁还是非公平锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">       sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock主要还是基于AQS实现的，我们主要关注他重写的一些方法，包括tryAcquire()和release().</p><h3 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire()"></a>tryAcquire()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非公平锁 </span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="comment">//重入锁的实现</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>公平锁和非公平锁最大的区别就是!hasQueuedPredecessors()，<strong>公平锁需要先判断等待队列中是否有前驱节点在等待</strong>。如果有，则说明有线程比当前线程更早的请求资源，根据公平性，当前线程请求资源失败；如果当前节点没有前驱节点，才有做后面的逻辑判断的必要性。</p><h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><p>非公平锁的吞吐量较高例如默认状态的<strong>ReentrantLock</strong> 有新线程来了先争夺一下锁，没成功再去排队。<br>公平锁是java关键字synchronized的重锁模式，谁来了都乖乖排队，<strong>后来的线程不能争夺锁</strong>，一定要入队列等待前一个线程来unpark自己，除非队列里没有其他线程。</p><p>可以在构<strong>造函数中设置</strong>公平锁还是非公平锁。</p><h2 id="尝试锁定"><a href="#尝试锁定" class="headerlink" title="尝试锁定"></a>尝试锁定</h2><p>可以使用tryLock()来尝试上锁，<strong>假如在一定的时间内获取锁失败，那么就会放弃等待</strong>。</p><h2 id="可中断锁"><a href="#可中断锁" class="headerlink" title="可中断锁"></a>可中断锁</h2><p>lock.lockInterruptibly() 对线程中断 interrupt() 做出响应。</p><p>使用 lockInterruptibly() 则该线程在等待锁的过程中，如果被中断interrupt()，则直接抛出中断异常来立即响应中断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JUC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock3</span> </span>&#123;</span><br><span class="line">    Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">"t1 start"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">10000000</span>);</span><br><span class="line">            System.out.println(<span class="string">"t1 end"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lockInterruptibly();</span><br><span class="line">            System.out.println(<span class="string">"t2 start"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            System.out.println(<span class="string">"t2 interrupted!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLock3 test=<span class="keyword">new</span> ReentrantLock3();</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(test::m2);</span><br><span class="line">        <span class="keyword">new</span> Thread(test::m1).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t2.start();</span><br><span class="line">        t2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//t1 start</span></span><br><span class="line"><span class="comment">//t2 interrupted!</span></span><br></pre></td></tr></table></figure><h2 id="与synchronized区别"><a href="#与synchronized区别" class="headerlink" title="与synchronized区别"></a>与synchronized区别</h2><ul><li>ReentrantLock是JDK实现的，synchronized是JVM实现的。</li><li>ReentrantLock需要手动释放，而且最好在finally中释放。</li><li>ReentrantLock支持公平锁。</li><li>ReentrantLock支持中断锁。</li><li>ReentrantLock支持条件队列。</li></ul><p>现在来说，经过JVM的优化，synchronized的效率已经很高了，一般来说，如果没有必须要使用ReentrantLock的功能。最好使用synchronized。因为JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ReentrantLock是可重入锁，它实现了Lock接口。&lt;/p&gt;
&lt;p&gt;可重入锁就是说同一个线程可以多次申请到该锁。&lt;/p&gt;
&lt;p&gt;ReentrantLock有公平锁和非公平锁两种方式。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table
      
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM优化</title>
    <link href="http://yoursite.com/2019/10/12/JVM%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/10/12/JVM优化/</id>
    <published>2019-10-12T08:07:25.000Z</published>
    <updated>2019-10-14T07:29:30.977Z</updated>
    
    <content type="html"><![CDATA[<p>Java有三种编译器i，一种是前端编译器，就是将java文件转变为class文件，这是在编译阶段。一种运行期编译器(JIT编译器)，将字节码文件转变为机器码，这是在运行阶段。</p><h2 id="编译期优化"><a href="#编译期优化" class="headerlink" title="编译期优化"></a>编译期优化</h2><p>编译过程主要分为：</p><ul><li>词法语法分析。</li><li>填充符号表。</li><li>注解处理器。</li><li>语义分析。</li><li>生成字节码。</li></ul><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型是java语法糖的一种，他的本质是参数化类型。</p><p>泛型主要有泛型类，泛型接口，泛型方法。</p><p>Java中的泛型只存在于编译阶段，只是用来在编译阶段进行数据校验的作用，在运行时期，泛型就被擦除了，替换为他的原生类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; integerArrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">Class classStringArrayList = stringArrayList.getClass();</span><br><span class="line">Class classIntegerArrayList = integerArrayList.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(classStringArrayList.equals(classIntegerArrayList))&#123;</span><br><span class="line">    System.out.println(<span class="string">"----equals----"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：----equals----</span></span><br></pre></td></tr></table></figure><p>在运行阶段，泛型已被擦除，所以，都被替换为ArrayList，是相同的。</p><p>个人觉得泛型的作用就是在编译阶段进行语义的审查的作用。</p><p>泛型擦除只是从字节码中擦除了，但是元数据中还是保留了泛型信息，所以，我们还是可以通过反射手段取得参数化类型。</p><ul><li>获取方法返回泛型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method method = MyClass.class.getMethod(<span class="string">"getStringList"</span>, <span class="keyword">null</span>);</span><br><span class="line">Type returnType = method.getGenericReturnType();</span><br></pre></td></tr></table></figure><ul><li>获取成员变量泛型参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Field field = MyClass.class.getField(<span class="string">"stringList"</span>);</span><br><span class="line">Type genericFieldType = field.getGenericType();</span><br></pre></td></tr></table></figure><h2 id="运行期优化"><a href="#运行期优化" class="headerlink" title="运行期优化"></a>运行期优化</h2><p> javac 将程序源代码编译，转换成 java 字节码，JVM 通过<strong>解释字节码将其翻译成对应的机器指令</strong>，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢很多。为了提高执行速度，引入了 JIT 技术。</p><p>当JVM发现某一段代码执行特别频繁的时候，就会认为他是热点代码，为了提高执行效率，虚拟机就会用过JIT编译器将这些代码编译成机器码，缓存下来。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/12/1570883161206-1570883161218.png" alt="title"></p><p>那么，为什么不直接编译呢？</p><p>首先，如果这段代码本身在将来只会被执行一次，那么从本质上看，编译就是在浪费精力。因为将代码翻译成 java 字节码相对于编译这段代码并执行代码来说，要快很多。当然，如果一段代码频繁的调用方法，或是一个循环，也就是这段代码被多次执行，那么编译就非常值得了。因此，编译器具有的这种权衡能力会首先执行解释后的代码，然后再去分辨哪些方法会被频繁调用来保证其本身的编译。</p><p>JVM是采<strong>用解释器与编译器并行</strong>的架构。</p><p>程序启动时，解释器首先发挥作用，省掉编译的时间，迅速执行。</p><p>程序运行后，随着时间的推移，编译器发挥作用，将代码编译成机器码，获取更高执行效率。</p><p>HotSpot有两个即时编译器，Client Compiler和Server Compiler，一个注重优化速度，一个注重优化质量。</p><p>Client Compiler：<strong>编译速度快，优化简单可靠</strong>。</p><p>Server Compiler：<strong>会有一些编译时间比较长的优化</strong>。</p><h3 id="热点代码"><a href="#热点代码" class="headerlink" title="热点代码"></a>热点代码</h3><p>热点代码有两类。</p><ul><li>被多次调用的方法。</li><li>被多次执行的循环体。</li></ul><p>那么，怎么计数呢？</p><ul><li>基于采样的热点探测。虚拟机周期性的检查各个线程栈顶，如果某个方法频繁出现，那么这就是一个热点方法。</li><li>基于计数器的热点探测。为每个方法(代码块)建立计数器，统计执行次数。</li></ul><p>在HotSpot采用的是第二种，有方法计数器来统计方法调用次数，回边计数器来统计循环代码调用次数。当计数器超过阈值的时候，就会对其进行编译。</p><h3 id="优化技术"><a href="#优化技术" class="headerlink" title="优化技术"></a>优化技术</h3><h4 id="公共子表达式消除"><a href="#公共子表达式消除" class="headerlink" title="公共子表达式消除"></a>公共子表达式消除</h4><p>如果一个表达式E计算过了，且他的值没有任何变化，那么E再次出现就没必要再次计算，直接用结果。</p><h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><p>内联举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b , <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">          <span class="keyword">return</span> add(a, b) + add(c, d);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>内联之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b , <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">          <span class="keyword">return</span> a + b + c + d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用一个方法需要建立栈帧等，成本比较大，方法内联可以很好的消除方法调用的成本。</p><p>内联条件：</p><ul><li><strong>热点代码</strong>。</li><li>方法体不是太大。</li><li>如果希望方法被内联，<strong>尽量用private、static、final修饰</strong>，这样jvm可以直接内联。如果是public、protected修饰方法jvm则需要进行类型判断，因为这些方法可以被子类继承和覆盖，jvm需要判断内联究竟内联是父类还是其中某个子类的方法。</li></ul><p>但是，内联并不是这么简单的，我们的程序中大多都是虚方法(不用private，final，static修饰的)，那么就会有多态的可能，不知道会不会有子类重写了方法。</p><p>JVM团队采用CHA来解决这个问题。</p><ul><li>方法是非虚方法，直接内联即可。</li><li>是虚方法，看程序内该方法是否有多个实现，若只有一个，直接内联。</li><li>若有多个，采取内联缓存。内联缓存中保存的是第一次调用使用的版本，并且以后每次调用都会比较版本信息，一致，继续使用。</li><li>不一致，取消内联。</li></ul><h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><ul><li>方法逃逸：一个对象在方法中被定义后，可能被其他方法使用。</li><li>线程逃逸：一个对象在方法中定义后，可以被别的线程访问到。</li></ul><p>如果一个对象没有逃逸，可以对其做以下优化。</p><ul><li>栈上分配。如果一个对象没有逃逸出方法之外，那么只会在一个方法内部访问，这样的话，将其分配在栈上，方法结束，对象自动被销毁，GC压力会小很多。</li><li>同步消除。因为一个对象没有逃逸，所以不会被外部线程访问到，所以同步措施也可以消除。</li><li>标量替换。标量是指一个数据无法再分解成更小的数据，例如基本数据类型，引用类型等。如果一个对象不会被外部访问，可以选择不创建这个对象，转而直接创建这个对象会被方法调用的成员变量。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java有三种编译器i，一种是前端编译器，就是将java文件转变为class文件，这是在编译阶段。一种运行期编译器(JIT编译器)，将字节码文件转变为机器码，这是在运行阶段。&lt;/p&gt;
&lt;h2 id=&quot;编译期优化&quot;&gt;&lt;a href=&quot;#编译期优化&quot; class=&quot;header
      
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Lock and AQS</title>
    <link href="http://yoursite.com/2019/10/10/Lock-and-AQS/"/>
    <id>http://yoursite.com/2019/10/10/Lock-and-AQS/</id>
    <published>2019-10-10T12:26:05.000Z</published>
    <updated>2019-10-19T11:37:43.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JUC包"><a href="#JUC包" class="headerlink" title="JUC包"></a>JUC包</h2><p>JUC包目录。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/13/1570936405191-1570936405441.png" alt="title"></p><p>其中包含了两个子包：atomic以及lock，另外在concurrent下的阻塞队列以及executors，<strong>这些类主要是依靠volatile以及CAS实现的</strong>。</p><p>整体结构如图：</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/13/1570936455857-1570936455857.png" alt="title"></p><h2 id="Lock简介"><a href="#Lock简介" class="headerlink" title="Lock简介"></a>Lock简介</h2><p>Lock是一个接口。</p><p>与synchronized相比，Lock<strong>拥有了锁获取和释放的可操作性，可中断的获取锁以及超时获取锁等</strong>多种synchronized关键字所不具备的同步特性。</p><a id="more"></a><p>Lock是一个接口，有许多实现他的类，比如ReentranrLock，但是查看他的源码会发现大部分方法都是在调用他的内部类Sync的方法，而Sync继承了AQS，因此，Lock实现的核心还是AQS。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/13/1570955895636-1570955895643.png" alt="title"></p><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AQS的设计是使用模板方法设计模式，他将一些相同部分的代码实现，将不同的代码放到不同的子类中去；而且，在AQS的方法中，也会调用子类的代码。<a href="https://blog.csdn.net/carson_ho/article/details/54910518" target="_blank" rel="noopener">模板设计模式</a></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类需要重写tryAcquire()</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//但是在AQS的模板方法中又调用了tryAcquire()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>因此，AQS只需要实现各自不同的tryAquire()就行了,比如是公平锁还是非公平锁，是独占锁还是共享锁。</p><p>AQS提供的模板方法可以分为3类：</p><ul><li><p>独占式获取与释放同步状态；</p></li><li><p>共享式获取与释放同步状态；</p></li><li><p>查询同步队列中等待线程情况；</p></li></ul><p>AQS的功能分为两种：<strong>独占和共享</strong></p><ul><li>独占锁，每次只能有一个线程持有锁，比如ReentrantLock就是以独占方式实现的互斥锁.</li><li>共享锁，允许多个线程同时获取锁，并发访问共享资源，比如ReentrantReadWriteLock.</li></ul><h2 id="AQS实现"><a href="#AQS实现" class="headerlink" title="AQS实现"></a>AQS实现</h2><p>AQS中有两个重要的成员，一个是CLH队列，一个是state。</p><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>AQS使用一个int类型的成员变量state来<strong>表示同步状态</strong>，当state&gt;0时表示已经获取了锁，当state = 0时表示释放了锁。</p><h3 id="CLH"><a href="#CLH" class="headerlink" title="CLH"></a>CLH</h3><p>CLH是一个先进先出的队列。如果当前线程竞争锁失败，那么AQS会把当前线程以及等待状态信息<strong>构造成一个Node</strong>加入到同步队列中，同时再阻塞该线程。当获取锁的线程释放锁以后，会从队列中唤醒一个阻塞的节点(线程)。</p><p>CLH的头节点是空的，啥也不存的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Node代表的是一个正在阻塞等待的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前节点处于共享模式的标记</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//当前节点处于独占模式的标记</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程被取消了</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//释放资源后需唤醒后继节点</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//等待condition唤醒</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//工作于共享锁状态，需要向后传播，</span></span><br><span class="line">        <span class="comment">//比如根据资源是否剩余，唤醒后继节点</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待状态，有1,0,-1,-2,-3五个值。分别对应上面的值</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//前驱节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//后继节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待锁的线程</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待条件的下一个节点，ConditonObject中用到</span></span><br><span class="line">        Node nextWaiter;</span><br></pre></td></tr></table></figure><h3 id="独占锁的获取"><a href="#独占锁的获取" class="headerlink" title="独占锁的获取"></a>独占锁的获取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过子类的tryAcquire()获取锁，不同的子类有不同的实现，要是获取失败，则执行acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，将该线程放入CLH  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>入队操作：<strong>主要采取CAS+自旋的方式</strong>，一开始采用CAS快速入队，失败了之后再采用自旋操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入队操作，mode = Node.EXCLUSIVE，独占锁</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这段代码进行快速入队，实际上与enq中差不多。这样做的原因是：</span></span><br><span class="line"><span class="comment">        把最有可能成功执行的代码直接写在最常用的调用处，因为在线程数不多的情况下，CAS还是很难失败的。因此  这种写法可以节省多条指令。因为调用enq需要一次方法调用，进入循环，比较null，然后才到了红框中一样 的代码。大概类似于内联函数的优化</span></span><br><span class="line"><span class="comment">总而言之，节省指令，提高效率。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;<span class="comment">//记录尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">//由于采用lazy initialize,当队列为空时，需要进行初始化</span></span><br><span class="line">            <span class="comment">//通过CAS设置head和tail节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;<span class="comment">//将node的前节点设置为原tail节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;<span class="comment">//CAS更新tail节点，更新成功则将原tail节点的后节点设置为node，返回原tail节点，入列成功；</span></span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在把node插入队列末尾后,它并不立即挂起该节点中线程,因为在插入它的过程中,前面的线程可能已经执行完成,所以它会先进行自旋操作acquireQueued(node, arg),尝试让该线程重新获取锁!当条件满足获取到了锁则可以从自旋过程中退出，否则继续。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//如果节点的前驱是队列的头节点并且能拿到资源，获取锁成功，结束</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断当前节点是否应该被挂起。</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>判断节点是否应该被挂起，当前驱节点是SIGNAL的时候，直接挂起线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="comment">//前驱节点的状态是SIGNAL，说明前驱节点释放资源后会通知自己</span></span><br><span class="line">            <span class="comment">//此时当前节点可以安全的park()，因此返回true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//前驱节点的状态是CANCLLED，说明前置节点已经放弃获取资源了</span></span><br><span class="line">            <span class="comment">//此时一直往前找，直到找到最近的一个处于正常等待状态的节点</span></span><br><span class="line">            <span class="comment">//并排在它后面，返回false</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//前驱节点的状态是0或PROPGATE，则利用CAS将前置节点的状态置</span></span><br><span class="line">            <span class="comment">//为SIGNAL，让它释放资源后通知自己</span></span><br><span class="line">            <span class="comment">//如果前置节点刚释放资源，状态就不是SIGNAL了，这时就会失败</span></span><br><span class="line">            <span class="comment">// 返回false</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>acquire()整个流程：</p><ul><li><p><strong>调用子类的tryAquire()尝试获取资源</strong>，成功，直接返回。失败，继续。</p></li><li><p>获取失败，将该线程生成一个Node节点通过addWaiter(Node.EXCLUSIVE), arg)<strong>添加到等待队列</strong>。</p></li><li><p>插入等待队列后，防止在这个阶段资源又有了。根据<strong>前置节点状态状态判断是否应该继续获取资源</strong>。如果前驱是头结点，继续尝试获取资源；获取成功，返回；否则，继续。</p></li><li><p>在每一次自旋获取资源过程中，失败后调用shouldParkAfterFailedAcquire(Node, Node)检测当前节点是否应该park()。</p><p>如果前置节点是SIGNAL状态，就挂起，返回true。</p><p>如果前置节点状态为CANCELLED，就一直往前找，直到找到最近的一个处于正常等待状态的节点，并排在它后面，返回false，acquireQueed()接着自旋尝试。</p><p>前置节点处于其他状态，利用CAS将前置节点状态置为SIGNAL。当前置节点刚释放资源，状态就不是SIGNAL了，导致失败，返回false。但凡返回false，就导致acquireQueed()接着自旋尝试。</p></li><li><p>若返回true，则调用parkAndCheckInterrupt()中断当前节点中的线程。若返回false，则接着自旋获取资源。</p></li><li><p>parkAndCheckInterrupt()挂起线程。</p></li></ul><h3 id="共享锁的获取"><a href="#共享锁的获取" class="headerlink" title="共享锁的获取"></a>共享锁的获取</h3><p>共享锁就是同时可以有多个线程访问。实现与独占锁差不多，唯一的不同就是需要<strong>判断是否还有剩余资源</strong>。</p><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>非公平锁的吞吐量较高例如默认状态的<strong>ReentrantLock</strong> 有新线程来了先争夺一下锁，没成功再去排队。<br>公平锁是java关键字synchronized的重锁模式，谁来了都乖乖排队，<strong>后来的线程不能争夺锁</strong>，一定要入队列等待前一个线程来unpark自己，除非队列里没有其他线程。</p><h3 id="中断锁"><a href="#中断锁" class="headerlink" title="中断锁"></a>中断锁</h3><p>当线程等待的时候，如果被interrupt()，那么直接抛出中断异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            doAcquireInterruptibly(arg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="超时锁"><a href="#超时锁" class="headerlink" title="超时锁"></a>超时锁</h3><p>在获取锁的过程中，超过某一个时长，自动放弃获取。</p><h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><p>首先调用子类的tryRelease()方法释放锁,然后唤醒后继节点,在唤醒的过程中,需要判断后继节点是否满足情况,如果后继节点不为空且不是作废状态,则唤醒这个后继节点,否则从tail节点向前寻找合适的节点,如果找到,则唤醒。</p><h3 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h3><p>这是AQS的一个内部类，其维护了一个condition队列。主要有await()和signal()等方法。</p><h4 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h4><p>await()：当前线程处于阻塞状态，直到调用signal()或中断才能被唤醒。</p><ul><li>将当前线程封装成node且等待状态为CONDITION。</li><li>释放当前线程持有的所有资源，让下一个线程能获取资源。</li><li>加入到条件队列后，则阻塞当前线程，等待被唤醒。</li><li>如果是因signal被唤醒，则节点会从条件队列转移到等待队列；如果是因中断被唤醒，则记录中断状态。两种情况都会跳出循环。</li><li>若是因signal被唤醒，就自旋获取资源；否则处理中断异常。</li></ul><p>condition队列与CLH最大的不同就是CLH是双向列表，condition队列是单向列表。</p><p>CLH是单向列表的原因是可能需要获取前置节点的一些属性，比如说查看前置节点是不是头节点之类的。</p><h2 id="ConditionObject详解"><a href="#ConditionObject详解" class="headerlink" title="ConditionObject详解"></a>ConditionObject详解</h2><p>ConditionObject用来实现<strong>锁的等待通知</strong>机制。ConditionObject内部维护了一个等待队列，与CLH不同的是这个队列是单向链表。</p><h3 id="与Object-wait-notify区别"><a href="#与Object-wait-notify区别" class="headerlink" title="与Object wait/notify区别"></a>与Object wait/notify区别</h3><p>Object的wait和notify/notify是与<strong>对象监视器配合完成线程间的等待/通知机制</strong>，而<strong>Condition与Lock配合</strong>完成等待通知机制，前者是java底层级别的，后者是语言级别的，具有更高的可控制性和扩展性。</p><p>Condition能够支<strong>持多个等待队列</strong>（new 多个Condition对象），而Object方式只能支持一个。</p><p>Condition能够支持超时时间的设置，而Object不支持。</p><h3 id="await方法"><a href="#await方法" class="headerlink" title="await方法"></a>await方法</h3><ul><li>void await() throws InterruptedException:当前线程进入等待状态，如果其他线程调用condition的signal或者signalAll方法并且当前线程获取Lock从await方法返回，如果在等待状态中被中断会抛出被中断异常；</li><li>long awaitNanos(long nanosTimeout)：当前线程进入等待状态直到被通知，中断或者<strong>超时</strong>。</li><li>boolean awaitUntil(Date deadline) throws InterruptedException：当前线程进入等待状态直到被通知，中断或者<strong>到了某个时间</strong>。</li></ul><h3 id="signal方法"><a href="#signal方法" class="headerlink" title="signal方法"></a>signal方法</h3><ul><li>void signal()：唤醒一个等待在condition上的线程(第一个线程，<strong>条件队列是一个FIFO的队列</strong>)，将该线程从<strong>等待队列</strong>中转移到<strong>同步队列</strong>中，如果在同步队列中能够竞争到Lock则可以从等待方法中返回。</li><li>void signalAll()：与1的区别在于能够唤醒所有等待在condition上的线程。</li></ul><h3 id="await实现原理"><a href="#await实现原理" class="headerlink" title="await实现原理"></a>await实现原理</h3><p>await主要做了三件事：</p><ul><li>将线程包装成Node，插入到条件队列。</li><li>释放线程拥有的锁。</li><li>阻塞当前线程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line"><span class="comment">// 1. 将当前线程包装成Node，尾插入到等待队列中</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line"><span class="comment">// 2. 释放当前线程所占用的lock，在释放的过程中会唤醒同步队列中的下一个节点</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line"><span class="comment">// 3. 当前线程进入到等待状态</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 4. 自旋等待获取到同步状态（即获取到lock）</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line"><span class="comment">// 5. 处理被中断的情况</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入到条件队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//将当前线程包装成Node</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"><span class="comment">//尾插入</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line"><span class="comment">//更新lastWaiter</span></span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与等待队列不同的是，条件队列没有头节点。</p><p>释放锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line"><span class="comment">//成功释放同步状态</span></span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//不成功释放同步状态抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结束await()状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前节点被移动到了同步队列中（即另外线程调用的condition的signal或者signalAll方法），while中逻辑判断为false后结束while循环</span></span><br><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line"><span class="comment">// 3. 当前线程进入到等待状态</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//当线程被中断，会退出循环</span></span><br><span class="line">    <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/65349219" target="_blank" rel="noopener">AQS详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JUC包&quot;&gt;&lt;a href=&quot;#JUC包&quot; class=&quot;headerlink&quot; title=&quot;JUC包&quot;&gt;&lt;/a&gt;JUC包&lt;/h2&gt;&lt;p&gt;JUC包目录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/13/1570936405191-1570936405441.png&quot; alt=&quot;title&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中包含了两个子包：atomic以及lock，另外在concurrent下的阻塞队列以及executors，&lt;strong&gt;这些类主要是依靠volatile以及CAS实现的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;整体结构如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/13/1570936455857-1570936455857.png&quot; alt=&quot;title&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Lock简介&quot;&gt;&lt;a href=&quot;#Lock简介&quot; class=&quot;headerlink&quot; title=&quot;Lock简介&quot;&gt;&lt;/a&gt;Lock简介&lt;/h2&gt;&lt;p&gt;Lock是一个接口。&lt;/p&gt;
&lt;p&gt;与synchronized相比，Lock&lt;strong&gt;拥有了锁获取和释放的可操作性，可中断的获取锁以及超时获取锁等&lt;/strong&gt;多种synchronized关键字所不具备的同步特性。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://yoursite.com/2019/10/10/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/10/10/单例模式/</id>
    <published>2019-10-10T11:00:09.000Z</published>
    <updated>2019-10-22T11:13:07.642Z</updated>
    
    <content type="html"><![CDATA[<p>一开始，我们写的单例模式是这样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这种方式有一个问题，就是无法解决多线程问题。</p><a id="more"></a><p>于是，对方法加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;  <span class="comment">//lineA</span></span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就解决了并发的问题。</p><p>但是，在每次调用方法我们都需要加锁，加锁实际上性能会变低，实际上调用方法只会出现一次instance==null，以后的每一次调用都是直接返回instance对象。</p><p>因此，可以将if判断语句提取出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123; <span class="comment">//lineA</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这样还是有问题，假设线程A执行完了lineA进入同步语句，但还并没有创建实例，此时线程B也执行到了lineA，但是instance==null，还是会重复创建实例。</p><p>于是，采用DCL解决，在同步语句块内部再进行一次if判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，这样就没有问题了吗？</p><p>并不是，因为<strong>new Singleton()这个语句实际上它并不是一个原子操作</strong>。</p><p>它有三条指令构成：</p><ul><li><p>1.在堆中开辟一块内存（new）</p></li><li><p>2.调用对象的构造函数对内存进行初始化（invokespecial）</p></li><li><p>3.<strong>最后将引用赋值给变量（astore），这一句instance就赋值了</strong>。</p></li></ul><p>所以，因为重排序的存在，CPU有可能产生指令重排序，比如1-3-2，这样的话，另一个线程可能在对象还没有初始化的时候就拿走了instance，造成问题。</p><p>于是，我们可以加上volatile，禁止指令重排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.iteye.com/blog/crud0906-576321" target="_blank" rel="noopener">单例模式</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一开始，我们写的单例模式是这样的。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton instance = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(instance==&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;但是，这种方式有一个问题，就是无法解决多线程问题。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>volatile关键字</title>
    <link href="http://yoursite.com/2019/10/09/volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/10/09/volatile关键字/</id>
    <published>2019-10-09T12:18:33.000Z</published>
    <updated>2019-10-11T11:49:08.184Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><p>JMM定义了内存中各个共享变量访问的规则。</p><p>共享变量包括包括实例字段 静态字段和构成数组的元素，即所有线程都可以访问到的，不包括局部变量和方法参数，这是线程私有的。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/11/1570784481491-1570784481498.png" alt="title"></p><p>JMM规定了所有共享变量都存储在主内存，每条线程还有自己的工作内存，工作内存除了存储线程私有的局部变量以及方法参数等，还有该线程中需要用到的主内存中的共享变量的拷贝。</p><a id="more"></a><p><strong>线程对变量的操作(读取赋值等)必须在工作内存中进行</strong>，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量。</p><p>工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。</p><p>设置工作内存的<strong>目的主要是为了解决内存与处理器速度不一致的问题</strong>，一般来说，主内存存放在内存中，工作内存存放在高速缓存中，因此，工作内存数据操作速度很快。</p><p>但是，JMM有一个问题，就是主内存与工作内存不一致的问题，可能工作内存修改了某个工作变量，但是没有同步到主内存中。</p><h2 id="重排序问题"><a href="#重排序问题" class="headerlink" title="重排序问题"></a>重排序问题</h2><p>计算机在执行程序时，为了提高性能，编译器和处理器的常常会对指令做重排。</p><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。</p><p>当两条指令没有数据依赖性的时候，就又可能对他进行指令重排序。</p><h2 id="JMM-三个特性"><a href="#JMM-三个特性" class="headerlink" title="JMM 三个特性"></a>JMM 三个特性</h2><p>JMM规定了三个特性，原子性，有序性，可见性。</p><p>其中，重排序破坏了有序性，JMM内存结构破坏了可见性。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子性是指<strong>一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着“同生共死”的感觉</strong>。</p><p>JMM中read，load，use，store，write都是原子操作，所以，基本数据类型的操作都是具备原子性的(long和double例外，因为long和double占64位，可能存在读取半个变量)。</p><p>如果应用场景需要一个更大的原子范围，可以使用sychronized等来解决。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>可见性是指当一个线程修改了共享变量后，其他线程能够立即得知这个修改。变量更新后，主内存中立即更新，并且根据缓存一致性协议，其他线程中的变量也会更新。</p><p>除了sychronized和volatile，final也具有可见性，因为final是不可以被修改的。但是，也有一个前提，被final修饰的字段在构造器中一旦初始化完成，并且没有this引用逃逸，那么其他线程就能看到final字段的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisEscape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">ThisEscape</span><span class="params">(EventSource&lt;EventListener&gt; source)</span> </span>&#123;</span><br><span class="line">            id = <span class="number">1</span>;</span><br><span class="line">            source.registerListener(<span class="keyword">new</span> EventListener() &#123;</span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"id: "</span>+ThisEscape.<span class="keyword">this</span>.id);</span><br><span class="line">                        System.out.println(<span class="string">"name: "</span>+ThisEscape.<span class="keyword">this</span>.name);</span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            name = <span class="string">"flysqrlboy"</span>;</span><br><span class="line">            </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>ThisEscape在构造函数中引入了一个内部类EventListener，而内部类会自动的持有其外部类（这里是ThisEscape）的this引用。source.registerListener会将内部类发布出去，从而ThisEscape.this引用也随着内部类被发布了出去。但此时ThisEscape对象还没有构造完成 —— id已被赋值为1，但name还没被赋值，仍然为null。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile保证可见性与有序性，但是不保证原子性。</p><h3 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h3><p>在生成汇编代码时会在volatile修饰的共享变量进行写操作的时候会多出<strong>Lock前缀的指令。</strong></p><p>如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。</p><p>所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现<strong>缓存一致性</strong>协议：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p><p>这样针对volatile变量通过这样的机制就使得每个线程都能获得该变量的最新值。</p><h3 id="保证顺序性"><a href="#保证顺序性" class="headerlink" title="保证顺序性"></a>保证顺序性</h3><p>volatile会在内存中和插入一个内存屏障指令(lock指令)，来禁止指令重排序。</p><p>因此，volatile读操作跟普通变量相比，没有什么差别，但是写操作因为要插入许多内存屏障，因此，效率会低一些。</p><h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>在发生操作B之前，操作A产生的影响都能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等，它与时间上的先后发生基本没有太大关系。</p><ul><li><p>程序次序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作</p></li><li><p>管程锁定规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。同步快中线程安全。</p></li><li><p>volatile变量规则：对一个volatile变量的写操作happens-before对这个变量的读操作。</p></li><li><p>线程启动规则：Thread.start() happens before 所有操作。</p></li><li><p>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C</p></li><li><p>线程终止规则：线程中所有操作都happens-before对此线程的终止检测。</p></li><li><p>对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始</p></li><li><p>程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。</p></li></ul><p>满足任意一个原则，对于读写共享变量来说，就是线程安全。</p><h2 id="关于可见性的一些问题"><a href="#关于可见性的一些问题" class="headerlink" title="关于可见性的一些问题"></a>关于可见性的一些问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"><span class="comment">/*volatile*/</span> <span class="keyword">boolean</span> running=<span class="keyword">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"m start"</span>);</span><br><span class="line"><span class="keyword">while</span>(running) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"m end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">T t =<span class="keyword">new</span> T();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;t.m(),<span class="string">"t1"</span>).start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//睡眠1s，保证t1先执行</span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">t.running=<span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码肯定是无法停止t1线程的，加上volatile就可以了。</p><p>那么，对m加上sychronized呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> running=<span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"m start"</span>);</span><br><span class="line">        <span class="keyword">while</span>(running) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"m end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        T t =<span class="keyword">new</span> T();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;t.m(),<span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t.running=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样还是不可以的，因为sychronied修饰的代码块中并没有改写running变量,synchronized会把同步块内更新的值再给同步到内存中。</p><p>但是，当我在循环里里面加了一个打印输出的语句，就可以终止线程了，为什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> running=<span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"m start"</span>);</span><br><span class="line">        <span class="keyword">while</span>(running) &#123;</span><br><span class="line">            System.out.println(<span class="string">"2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"m end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        T t =<span class="keyword">new</span> T();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;t.m(),<span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t.running=<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，JVM对于现代的机器做了最大程度的优化，也就是说，最大程度的保障了线程和主存之间的及时的同步，也就是相当于虚拟机尽可能的帮我们加了个volatile，但是，当CPU被一直占用的时候，同步就会出现不及时，也就出现了后台线程一直不结束的情况。</p><p>也就是说，在cpu空闲的时候，可能会更新一下主内存的内容。</p><p>比如，我们在循环中sleep一下，亦可以结束线程。</p><h2 id="volatile使用场景"><a href="#volatile使用场景" class="headerlink" title="volatile使用场景"></a>volatile使用场景</h2><h3 id="状态标志"><a href="#状态标志" class="headerlink" title="状态标志"></a>状态标志</h3><p>用<code>volatile</code>来修饰一个<code>Boolean</code>状态标志，用于指示发生了某一次的重要事件，例如完成初始化或者请求停机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> shutdownRequested;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123; shutdownRequested = <span class="keyword">true</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (!shutdownRequested) &#123; </span><br><span class="line">        <span class="comment">// do stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><p>通过volatile禁止指令重排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 volatile 修饰。</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton sInstance;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123; <span class="comment">//(0)</span></span><br><span class="line">           <span class="keyword">synchronized</span> (Singleton.class) &#123; <span class="comment">//(1)         </span></span><br><span class="line">               <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;  <span class="comment">//(2)           </span></span><br><span class="line">                   sInstance = <span class="keyword">new</span> Singleton(); <span class="comment">//(3)    </span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sInstance;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="读操作远远大于写操作"><a href="#读操作远远大于写操作" class="headerlink" title="读操作远远大于写操作"></a>读操作远远大于写操作</h3><p>如果读操作远远超过写操作，您可以结合使用内部锁和<code>volatile</code>变量来减少公共代码路径的开销。下面的代码中使用<code>synchronized</code>确保增量操作是原子的，并使用<code>volatile</code>保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及<code>volatile</code>读操作，这通常要优于一个无竞争的锁获取的开销。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheesyCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java-内存模型&quot;&gt;&lt;a href=&quot;#Java-内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java 内存模型&quot;&gt;&lt;/a&gt;Java 内存模型&lt;/h2&gt;&lt;p&gt;JMM定义了内存中各个共享变量访问的规则。&lt;/p&gt;
&lt;p&gt;共享变量包括包括实例字段 静态字段和构成数组的元素，即所有线程都可以访问到的，不包括局部变量和方法参数，这是线程私有的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/11/1570784481491-1570784481498.png&quot; alt=&quot;title&quot;&gt;&lt;/p&gt;
&lt;p&gt;JMM规定了所有共享变量都存储在主内存，每条线程还有自己的工作内存，工作内存除了存储线程私有的局部变量以及方法参数等，还有该线程中需要用到的主内存中的共享变量的拷贝。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>synchronized关键字</title>
    <link href="http://yoursite.com/2019/10/09/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/10/09/synchronized关键字/</id>
    <published>2019-10-09T07:40:32.000Z</published>
    <updated>2019-10-24T03:02:09.314Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="锁定的是对象"><a href="#锁定的是对象" class="headerlink" title="锁定的是对象"></a>锁定的是对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class T &#123;</span><br><span class="line">private Object o=new Object();</span><br><span class="line">private int count=10;</span><br><span class="line">public void m() &#123;</span><br><span class="line">synchronized(o) &#123;</span><br><span class="line">count--;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;count=&quot;+count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>1.当一个线程想要去执行这段代码，必须要获得o的锁，当o被其他线程占用时，该线程必须要等其他线程释放o的锁，再去获得o的锁，才能执行。</p><p>2.synchronized关键字锁定的是对象不是代码块,demo中锁的是object对象的实例</p><p>3.可能锁对象包括： this， 临界资源对象，Class 类对象。</p><p>4.关于线程安全：加synchronized关键字之后不一定能实现线程安全，具体还要看锁定的对象是否唯一。</p><p>5.synchronized关键字修饰普通方法等同于synchronized(this)</p><h3 id="静态方法上锁"><a href="#静态方法上锁" class="headerlink" title="静态方法上锁"></a>静态方法上锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 静态方法加锁相当于给T.class文件枷锁</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">count--;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">"count="</span>+count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;复制代码</span><br></pre></td></tr></table></figure><p>给静态方法上锁，<strong>锁定的是类对象</strong>，类的.class文件是唯一的，所以说synchronize修饰静态方法或者锁定的对象是类的.class文件的时候在多线程中是可以实现线程安全的.。</p><p>需要注意的是如果一个线程A调用一个实例对象的非static synchronized方法，而线程B需要调用这个实例对象所属类的静态 synchronized方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法<strong>占用的锁是当前类的class对象</strong>，而访问非静态 synchronized 方法<strong>占用的锁是当前实例对象锁</strong>。</p><h3 id="同步和非同步方法同时调用"><a href="#同步和非同步方法同时调用" class="headerlink" title="同步和非同步方法同时调用"></a>同步和非同步方法同时调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"m1 start------"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"m1 end--------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"m2-----"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">T t=<span class="keyword">new</span> T();</span><br><span class="line"><span class="comment">//相当于new 一个线程，在run方法里执行m1 lamda表达式</span></span><br><span class="line"><span class="comment">/*new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@Override</span></span><br><span class="line"><span class="comment">public void run() &#123;</span></span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;t.m1(),<span class="string">"t1"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;t.m2(),<span class="string">"t1"</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 线程t1首先获得了当前对象t的锁，并执行m1。因为m2非同步的，不需要获得锁就可以执行，所以t2不需要获得锁就可以直接执行m2.只有执行synchronized方法才需要申请那把锁。</p><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">" m1"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">m2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">" m2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Test1 t=<span class="keyword">new</span> Test1();</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">t.m1();</span><br><span class="line">&#125;,<span class="string">"t1"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">t.m1();</span><br><span class="line"></span><br><span class="line">&#125;,<span class="string">"t2"</span>).start();;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">t1 m1</span><br><span class="line">t1 m2</span><br><span class="line">t2 m1</span><br><span class="line">t2 m2</span><br></pre></td></tr></table></figure><p>所谓重入锁，指的是以线程为单位，<strong>当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，</strong>而其他的线程是不可以的，synchronized和ReentrantLock都是可重入锁。<strong>可重入锁的意义在于防止死锁</strong>。实现原理实现是通过为每个锁关联一个请求计数和一个占有它的线程。当计数为0时，认为锁是未被占有的。线程请求一个未被占有的锁时，jvm讲记录锁的占有者，并且讲请求计数器置为1 。如果同一个线程再次请求这个锁，计数将递增；每次占用线程退出同步块，计数器值将递减。直到计数器为0,锁被释放。可重入锁锁定的必须得是同一个对象(或者是父类子类对象)。</p><h3 id="不要以字符串常量作为锁的对象。"><a href="#不要以字符串常量作为锁的对象。" class="headerlink" title="不要以字符串常量作为锁的对象。"></a>不要以字符串常量作为锁的对象。</h3><p>因为锁定的是对象。比如说你用到了一个类库，里边锁定了一个”Hello”,而你在你的代码中也锁定了”Hello”,实际上这锁定的是是同一个对象，容易发生死锁。</p><h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_11</span> </span>&#123;</span><br><span class="line">AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line"><span class="comment">/*if(count.get() &lt; 1000)*/</span></span><br><span class="line">count.incrementAndGet();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> Test_11 t = <span class="keyword">new</span> Test_11();</span><br><span class="line">List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">threads.add(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">t.m();</span><br><span class="line">&#125;</span><br><span class="line">&#125;));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(Thread thread : threads)&#123;</span><br><span class="line">thread.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(Thread thread : threads)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">thread.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(t.count.intValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AtoXXX本身的方法是<strong>具有原子性的</strong>，但是他<strong>比synchronized效率要高。</strong></p><h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p>synchronized使用的锁对象是存储在Java对象头里的，jvm中采用2个字来存储对象头(如果对象是数组则会分配3个字，多出来的1个字记录的是数组长度)，其主要结构是由Mark Word 和 Class Metadata Address 组成 。Class Metadata Address存储的是该对象属于类的地址，即可以判断这个对象属于哪一个类。</p><p>MarkWord有五种类型：</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/22/1571733588820-1571733588825.png" alt="title"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>MarkWord：</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/22/1571733631761-1571733631767.png" alt="title"></p><p>重量级锁(sychronized)：</p><p>锁标识位为10，<strong>其中指针指向的是monitor对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个 monitor 与之关联</strong>。只有获取到对象的monitor的线程，才可以执行方法或代码块，其他获取失败的线程会被阻塞，并放入同步队列中，进入BLOCKED状态。</p><h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p>当我们使用synchronized修饰方法名时，编译后会在方法名上生成一个ACC_SYNCHRONIZED标识来实现同步；当使用synchronized修饰代码块时，编译后会在代码块的前后生成monitorenter和monitorexit字节码来实现同步。</p><p>无论使用哪种方式实现，本质上都是<strong>对指定对象相关联的monitor的获取</strong>，只有获取到对象的monitor的线程，才可以执行方法或代码块，其他获取失败的线程会被阻塞，并放入同步队列中，进入BLOCKED状态。</p><p>为了解决线程安全的问题，Java提供了同步机制、互斥锁机制，这个机制保证了在同一问题内只有一个线程能访问共享资源。这个机制的保障来源于监视锁Monitor，每个对象都拥有自己的监视锁Monitor。</p><h3 id="Monitor的实现"><a href="#Monitor的实现" class="headerlink" title="Monitor的实现"></a>Monitor的实现</h3><p>数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = 0;</span><br><span class="line">    _waiters      = 0,</span><br><span class="line">    _recursions   = 0;</span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL;</span><br><span class="line">    _WaitSet      = NULL;</span><br><span class="line">    _WaitSetLock  = 0 ;</span><br><span class="line">    _Responsible  = NULL ;</span><br><span class="line">    _succ         = NULL ;</span><br><span class="line">    _cxq          = NULL ;</span><br><span class="line">    FreeNext      = NULL ;</span><br><span class="line">    _EntryList    = NULL ;</span><br><span class="line">    _SpinFreq     = 0 ;</span><br><span class="line">    _SpinClock    = 0 ;</span><br><span class="line">    OwnerIsThread = 0 ;</span><br><span class="line">  &#125;复制代码</span><br></pre></td></tr></table></figure><p>关键属性：</p><p>_owner：指向持有ObjectMonitor对象的线程</p><p>_WaitSet：存放处于wait状态的线程队列</p><p>_EntryList：存放处于等待锁block状态的线程队列</p><p>_recursions：锁的重入次数</p><p>_count：用来记录该线程获取锁的次数、</p><p>ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表( 每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。</p><p>若执行线程调用 notify/notifyAll 方法，WaitSet 中的线程被唤醒，进入EntryList 中阻塞，等 待获取锁标记。若执行线程的同步代码执行结束，同样会释放锁标记，monitor 中的_Owner 标记赋值为 null，且计数器赋值为 0 计算。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/22/1571733665296-1571733665302.png" alt="title"></p><h3 id="等待唤醒机制与synchronized"><a href="#等待唤醒机制与synchronized" class="headerlink" title="等待唤醒机制与synchronized"></a>等待唤醒机制与synchronized</h3><p>所谓等待唤醒机制本篇主要指的是notify/notifyAll和wait方法，在使用这3个方法时，必须处于synchronized代码块或synchronized方法中，否则就会抛出IllegalMonitorStateException异常。</p><p>这是因为调用这几个方法前必须拿到当前对象的监视器monitor对象，也就是说notify/notifyAll和wait方法依赖于monitor对象，在前面的分析中，我们知道monitor 存在于对象头的Mark Word 中(存储monitor引用指针)，而synchronized关键字可以获取 monitor ，这也就是为什么notify/notifyAll和wait方法必须在synchronized代码块或者synchronized方法调用的原因。</p><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>锁的状态总共有四种：<strong>无锁状态、偏向锁、轻量级锁和重量级锁</strong>。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁。但是不可以降级。</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>sychronized就是重量级锁。</p><p>Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而<strong>操作系统实现线程之间的切换这就需要从用户态转换到核心态</strong>，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。JDK为了sychronized的优化，引入了轻量级锁和偏向锁。</p><p>一个依据：“<strong>对于绝大部分的锁，在整个同步周期内都是不存在竞争的</strong>。”</p><p>这是轻量级锁和偏向锁的依据。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>在大多数情况下，<strong>锁不仅不存在多线程竞争，而且总是由同一线程多次获得</strong>，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。</p><p>偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程<strong>再次请求锁时，无需再做任何同步操作，即获取锁的过程</strong>，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。</p><p>所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</p><p><strong>当有另外一个线程去尝试获取这个锁对象时</strong>，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态偏向锁可以提高有同步但竞争比较少的程序性能。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。</p><p>当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。</p><p>如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>重量级锁通过Monitor来实现，状态转换效率低。</p><p>轻量级锁基于CAS来实现。</p><p>偏向锁不需要同步，要是同一个线程申请锁。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/22/1571733707618-1571733707623.png" alt="title"></p><h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><ul><li>synchronized是悲观锁，这种线程一旦得到锁，其他需要锁的线程就挂起的情况就是悲观锁。</li><li>CAS操作的就是乐观锁，每次不加锁而是<strong>假设没有冲突</strong>而去完成某项操作，如果因为冲突失败就重试，直到成功为止。</li></ul><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>Atomic底层的实现就是CAS。</p><p>CAS是一个原子操作。</p><p>CAS机制当中使用了3个基本操作数：内存地址V，旧的值A，要修改的新值B。</p><p>更新一个变量的时候，<strong>只有当变量旧的值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B</strong>。 </p><p>这样说或许有些抽象，我们来看一个例子：</p><p>1.在内存地址V当中，存储着值为10的变量。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/22/1571733771170-1571733771178.png" alt="title"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>2.此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A=10，要修改的新值B=11。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/22/1571733804825-1571733804830.png" alt="title"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>3.在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/22/1571733837941-1571733837945.png" alt="title"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>4.线程1开始提交更新，首先进行A和地址V的实际值比较（Compare），发现A不等于V的实际值，提交失败。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/22/1571733873772-1571733873779.png" alt="title"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>5.线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为自旋。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/22/1571733898828-1571733898835.png" alt="title"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>6.这一次比较幸运，没有其他线程改变地址V的值。线程1进行Compare，发现A和地址V的实际值是相等的。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/22/1571733932675-1571733932684.png" alt="title"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>7.线程1进行SWAP，把地址V的值替换为B，也就是12。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/22/1571733960743-1571733960748.png" alt="title"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>当多个线程同时使用CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会挂起，仅是被告知失败，并且允许再次尝试，当然也允许实现的线程放弃操作。基于这样的原理，CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰。</p><p>Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。</p><p>CAS缺点：</p><ul><li><p>CPU开销较大<br>在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</p></li><li><p>ABA问题。</p><p>假设一个变量 A ，修改为 B之后又修改为 A，CAS 的机制是无法察觉的，但实际上已经被修改过了。如果在基本类型上是没有问题的，但是如果是引用类型呢？这个对象中有多个变量，我怎么知道有没有被改过？加个版本号啊。每次修改就检查版本号，如果版本号变了，说明改过，就算你还是 A，也不行。</p><p>AtomicReference就是这样做的。</p></li></ul><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除.</p><p>主要通过逃逸分析来判定。</p><p>何为逃逸？</p><p>当一个对象在方法中被定义后，如果被外部方法所引用，甚至可能会被外部线程所访问到，称为线程逃逸。</p><p>如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p><p>因为代码中会有许多隐形的锁，比如String。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p><p>例如在一个for循环里枷锁，就可以把锁提到外面。</p><h3 id="自旋锁（空转打圈儿）"><a href="#自旋锁（空转打圈儿）" class="headerlink" title="自旋锁（空转打圈儿）"></a>自旋锁（空转打圈儿）</h3><p>适用于共享数据只会锁定很短的一段时间。</p><p>当获取锁的过程中，未获取到。为了提高效率，JVM 自动执行若干次空循环（while循环中啥也不做），再次申请 锁，而不是进入阻塞状态的情况。称为自旋锁。自旋锁提高效率就是避免线程状态的变更。<strong>避免线程挂起导致的花费</strong>。</p><p>互斥同步对性能影响最大的是阻塞，即线程的挂起和恢复。许多应用中，<strong>共享数据的锁定状态只会持续很短的一段时间</strong>。如果有两个以上的处理器，能让两个或者以上的线程并行执行，我们就可以让后面请求锁的线程等待一下，但是并不放弃处理器的执行时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p><p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p><p>自适应的自旋锁：</p><p>自适应的自旋锁意味着自旋的时间不在固定了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得锁，并且持有者的线程正在运行中，那么虚拟机认为这次自旋也很有可能再次成功，因此会自旋等待较长的时间。相反的是，假如对于某个锁，自旋等待很少成功，那么以后获取这个锁的时候即有可能省略掉这个过程。</p><p><strong>一般自旋锁可以搭配CAS来使用。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h2&gt;&lt;h3 id=&quot;锁定的是对象&quot;&gt;&lt;a href=&quot;#锁定的是对象&quot; class=&quot;headerlink&quot; title=&quot;锁定的是对象&quot;&gt;&lt;/a&gt;锁定的是对象&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class T &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	private Object o=new Object();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	private int count=10;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public void m() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		synchronized(o) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			count--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			System.out.println(Thread.currentThread().getName()+&amp;quot;count=&amp;quot;+count);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>操作系统同步互斥</title>
    <link href="http://yoursite.com/2019/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/"/>
    <id>http://yoursite.com/2019/10/08/操作系统同步互斥/</id>
    <published>2019-10-08T12:21:50.000Z</published>
    <updated>2019-10-09T06:35:36.533Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TSL指令"><a href="#TSL指令" class="headerlink" title="TSL指令"></a>TSL指令</h2><p>类似于java的CAS。</p><p>Test and set lock.<strong>这是一个原子操作，他的读写操作是不分开的</strong>。</p><a id="more"></a><p>TSL指令实现锁机制：当lock为0时，任何进程都可以使用TSL指令将其设置为1，然后访问临界区，操作结束时，再将lock重新设置为0.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void acquire(int *lock)&#123;</span><br><span class="line">    while(TestAndSet(*lock));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void release(int *lock)&#123;</span><br><span class="line">    *lock = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在acquire函数中，如果TestAndSet返回1，那么while循环就一直执行（也就是在这里等待），直到另一个线程调用release。当然，这个实现看起来不太好，主要是<strong>等待的线程会不停的检查，浪费CPU，这个问题称之为忙等待</strong>（busy-wait or spin-wait），所以这个lock的实现也叫自旋锁spinlock。解决办法是如果需要等待，那么该线程主动交出执行权，让其他线程有机会执行，这种方式称之为让权等待（yield-wait or sleep-wait），应用开发人员使用的互斥锁一都是指这种情况。</p><p>以上的这些机制都是忙等待。<br>当一个进程想进入临界区，先检查是否允许进入，若不允许，将会原地等待，直到允许为止。<br>浪费CPU。</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>可以同时多个线程访问临界区，有P,V两个原子操作。</p><p>P(): 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</p><p>V(); 对信号量执行 +1 操作，唤醒睡眠的进程让其完成 P操作。</p><p>要是信号量的取值变为了1，那么就变成了互斥量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mutex=<span class="keyword">new</span> Semaphore(<span class="number">1</span>)</span><br><span class="line">mutex.P();</span><br><span class="line">临界区</span><br><span class="line">mutex.V();</span><br></pre></td></tr></table></figure><p>信号量主要可以解决两类问题。</p><ul><li><strong>互斥问题</strong>。同一时刻只可以有一个线程访问某一个临界资源。</li><li><strong>同步问题</strong>。线程A需要等待线程B执行完毕后才可以继续执行。</li></ul><h3 id="信号量解决生产者消费者问题"><a href="#信号量解决生产者消费者问题" class="headerlink" title="信号量解决生产者消费者问题"></a>信号量解决生产者消费者问题</h3><ul><li>同一时刻，只能有一个生产者或者是消费者访问缓冲区。(互斥问题)</li><li>缓冲区满时，生产者需要等待消费者消费。(同步问题)</li><li>缓冲区空时，消费者需要等待生产者生产。(同步问题)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥量</span></span><br><span class="line">mutex = <span class="keyword">new</span> Semophore(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//代表缓冲区有多少产品</span></span><br><span class="line">products = <span class="keyword">new</span> Semophore(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//代表缓冲区里有多大位置</span></span><br><span class="line">remainPosition = <span class="keyword">new</span> Semophore(n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line">remainPosition-&gt;P();</span><br><span class="line">mutex-&gt;P();</span><br><span class="line">Add();</span><br><span class="line">mutex-&gt;V();</span><br><span class="line">products-&gt;V();</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者，先去申请产品，在空出一个位置</span></span><br><span class="line">products-&gt;P();</span><br><span class="line">mutex-&gt;P();</span><br><span class="line">Remove();</span><br><span class="line">mutex-&gt;V();</span><br><span class="line">remainPosition-V();</span><br></pre></td></tr></table></figure><p>注意，empty-&gt;P()和mutex-&gt;P()不可以交换顺序。</p><p>要是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mutex-&gt;P()</span><br><span class="line">empty-P();</span><br></pre></td></tr></table></figure><p><strong>假设我们现在的empty已经是0了，mutex先执行也变为了0，但是当执行到下一步empty-P()，发现自己需要阻塞，但是mutex还未释放，会造成死锁。</strong><br>两个V()操作可以交换顺序。</p><h2 id="管程-Monitor"><a href="#管程-Monitor" class="headerlink" title="管程(Monitor)"></a>管程(Monitor)</h2><p><strong>管程=互斥量+条件变量</strong>。<br><strong>互斥量：可以保证共享资源在同一时间只能有一个进程访问</strong>。<br><strong>条件变量：正在管程内的线程可以放弃对管程的控制权，等待某些条件发生再继续执行</strong>。<br>每个条件变量实际上代表的是一个等待队列。<br>当wait时，进程释放锁，挂起，并插入该条件变量的等待队列。<br>signal时，唤醒条件变量等待队列中的进程。</p><p>任意时刻管程中只能有一个活跃进程。<br>条件变量：解决死锁问题，挂起进程。<br>条件变量。wait：释放锁，挂起 notify：<strong>唤醒等待队列中一个线程</strong>。防止死锁。</p><h3 id="管程解决生产者消费者问题"><a href="#管程解决生产者消费者问题" class="headerlink" title="管程解决生产者消费者问题"></a>管程解决生产者消费者问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">mutex buffer;<span class="comment">//互斥量，一次只能由一个进程访问</span></span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">Condition full,empty;<span class="comment">//条件变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Produce</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//获取互斥量</span></span><br><span class="line">   mutex.acquire();</span><br><span class="line">   <span class="comment">//容器满了，线程挂起</span></span><br><span class="line">   <span class="keyword">while</span>(count==n)&#123;</span><br><span class="line">      wait(full);</span><br><span class="line">   &#125;</span><br><span class="line">   Add c;</span><br><span class="line">   count++;</span><br><span class="line">   <span class="comment">//唤醒因没有产品挂起的线程</span></span><br><span class="line">   notify(empty);</span><br><span class="line">   mutex.release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Produce</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//获取互斥量</span></span><br><span class="line">   mutex.acquire();</span><br><span class="line">   <span class="comment">//容器满了，线程挂起</span></span><br><span class="line">   <span class="keyword">while</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">      wait(empty);</span><br><span class="line">   &#125;</span><br><span class="line">   Remove c;</span><br><span class="line">   count--;</span><br><span class="line"><span class="comment">//唤醒因容器满了挂起的线程</span></span><br><span class="line">   notify(full); </span><br><span class="line">   mutex.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TSL指令&quot;&gt;&lt;a href=&quot;#TSL指令&quot; class=&quot;headerlink&quot; title=&quot;TSL指令&quot;&gt;&lt;/a&gt;TSL指令&lt;/h2&gt;&lt;p&gt;类似于java的CAS。&lt;/p&gt;
&lt;p&gt;Test and set lock.&lt;strong&gt;这是一个原子操作，他的读写操作是不分开的&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统进程</title>
    <link href="http://yoursite.com/2019/10/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/10/07/操作系统进程/</id>
    <published>2019-10-07T13:54:57.000Z</published>
    <updated>2019-10-09T05:51:55.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是<strong>资源分配的基本单位</strong>，他是程序运行时的一个实例。<br>程序运行时，系统会创建一个进程，并分配相关的资源。</p><p><strong>程序是静态的，进程是动态的</strong>。一个程序可以对应多个进程，一个进程可以包括多个程序。</p><p>进程=程序+数据+状态信息。</p><a id="more"></a><h3 id="PCB-进程控制块"><a href="#PCB-进程控制块" class="headerlink" title="PCB(进程控制块)"></a>PCB(进程控制块)</h3><p>每个进程都有一个进程控制块，他是<strong>进程的唯一标识</strong>。<br>进程块描述进程的基本信息和运行状态。所谓的进程的创建与销毁，就是对PCB的创建与销毁。</p><p>各个进程块在内存中<strong>应该是以链表的形式存储</strong>的，因为进程块需要频繁的进行插入与删除。</p><h3 id="进程的生命周期"><a href="#进程的生命周期" class="headerlink" title="进程的生命周期"></a>进程的生命周期</h3><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/06/09/1560068275561-1560068275567.png" alt="title"><br><strong>最主要的就是就绪，运行，阻塞三个状态。</strong><br>操作系统创建一个进程完成后，并为其分配了除了cpu之外的所有的资源，那么进程进入<strong>就绪(ready)状态</strong>，当CPU处于空闲的时候，就绪状态的进程占用CPU，进入<strong>运行（running）状态</strong>。正在执行的进程，由于等待某个事件发生而无法执行时，便放弃CPU而处于<strong>阻塞（waiting）状态</strong>。</p><ul><li><p>ready-&gt;running<br>当没有其他进程占用CPU，所有的ready进程就可以去竞争CPU，获得CPU的进程进入running状态。</p></li><li><p>running-&gt;waiting<br>正在执行的进程，因为等待某个事件发生而放弃CPU时，进入waiting状态。比如I/O阻塞，申请缓冲区不能满足、等待信件等。</p></li><li><p>running-&gt;ready<br>处于执行状态的进程在其执行过程中，因分配给它的一个时间片已用完或更高优先级的进程抢占而不得不让出处理机，于是进程从执行状态转变成就绪状态。</p></li><li><p>waiting-&gt;ready<br>当等待事件完成的时候，从阻塞进入就绪态。<br>需要正在运行的进程对他唤醒。</p></li></ul><h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>因为所有的进程都有自己独立的地址空间。</p><ul><li><p>页表以及地址空间的切换。</p></li><li><p>寄存器，程序计数器，堆栈的切换。</p></li></ul><p>进程上下文切换过程：</p><ul><li><p>保存现场。暂停当前进程，从运行态变为其他状态，保存当前进程的上下文，包括CPU寄存器状态，程序计数器状态等。保存在PCB中。</p></li><li><p>选取进程。调度另一个进程从就绪转为运行。</p></li><li><p>恢复现场。从内存中恢复下一个要执行的进程的上下文，恢复该进程原来的状态到寄存器，恢复程序执行上一次暂停的地方。从PCB中取。</p><p>在进程切换的过程中，页表会改变，地址空间会改变，高速缓存中的存储的数据过期，也需要进行切换。</p></li></ul><h3 id="进程挂起"><a href="#进程挂起" class="headerlink" title="进程挂起"></a>进程挂起</h3><p>将<strong>进程从内存转移到磁盘上</strong>。<br>进程挂起状态包括<strong>阻塞挂起</strong>（在外存，处于阻塞）和就绪挂起（在外存，就绪状态）。</p><p>进程挂起状态转换：</p><ul><li>阻塞到阻塞挂起。内存不够时，将阻塞状态的进程移到外存，变为阻塞挂起状态。</li><li>就绪到就绪挂起。有高优先级阻塞和低优先级就绪，那么将低优先级挂起。</li><li>运行到就绪挂起。</li></ul><p>挂起是将进程从内存转移到磁盘，而阻塞是由于资源得不到满足暂时无法获取CPU，还是在内存的。</p><h3 id="状态队列"><a href="#状态队列" class="headerlink" title="状态队列"></a>状态队列</h3><p><strong>操作系统中维护了多个队列，不同的队列来表示不同的状态。</strong><br>就绪队列，阻塞队列，运行队列等。<br>方便操作系统管理进程。<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/06/09/1560078704085-1560078704092.png" alt="title"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>当我们并发的需求时，如果采用多进程的话，因为进程每个进程都有自己的独立空间，进程间通信麻烦，还有进程切换的时候需要进行保护现场恢复现场，十分耗费资源，效率低下。<br>于是，引入了线程。</p><p>线程是轻量级的进程。所有的线程共享进程的地址空间，进程间开销小，通信方便。<br>进程中的所有线程共享代码，文件等资源。<br>但是，<strong>他们都有自己的堆栈，寄存器等</strong>。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/06/09/1560080472816-1560080472823.png" alt="title"></p><p>进程是资源分配的角色，线程是执行功能的角色。<br>一个线程崩溃，整个进程崩溃。因此，在对于安全性过高的场合，我们一般使用进程来解决并发问题。比如说，我们的浏览器，每开一个界面，就创建一个进程。</p><h3 id="OS中两种线程"><a href="#OS中两种线程" class="headerlink" title="OS中两种线程"></a>OS中两种线程</h3><p><strong>根据操作系统能够感知到线程，分为用户线程以及内核线程。</strong></p><h4 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h4><p>内核完成线程的创建以及管理。<br>内核分配CPU是以线程为单位的。</p><p>优点：</p><ul><li>一个线程阻塞不会导致整个进程阻塞。</li><li>内核会为每一个线程分配CPU，对于多线程的进程，时间片时间大大增加。</li></ul><p>缺点：</p><ul><li>线程切换要从用户态转移到内核态，耗费大，速度慢。</li></ul><h4 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h4><p>用户级的线程库完成线程的创建以及管理。<br><strong>内核资源的分配仍然是按照进程（用户进程）进行分配的。</strong><br>不依赖于操作系统的内核，<strong>操作系统感受不到用户线程的存在</strong>。</p><p>缺点：</p><ul><li>因此，对于操作系统来说，这个用户线程所属的进程是没有线程的，因此，<strong>一个线程的阻塞将导致整个进程的阻塞</strong>，因为，对于操作系统来说，他看到的只是这个进程，这个用户线程阻塞，对操作系统来说就是整个进程阻塞，所以这个进程将会阻塞。</li><li>因为没有操作系统的管制，一个用户线程拿到了分配给这个进程的时间片，他会一直霸占着，除非她主动放弃，或者到这个时间片结束，可能会导致别的用户线程没有机会执行。</li></ul><p>优点：</p><ul><li>但是，用户线程切换不需要从用户态转到内核态，消耗小，速度快。</li></ul><p>总的来说，对于用户线程，操作系统是感受不到，<strong>还是会把它看作一个进程来进行处理</strong>。</p><p><a href="https://www.cnblogs.com/Lee-johnH/p/6663618.html" target="_blank" rel="noopener">内核线程与用户线程</a></p><h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><p>将用户线程与内核线程绑定。主要有一对一，多对一，以及多对多。操作系统中主要使用多对多。</p><h4 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a>多对一</h4><p>多个用户线程与一个内核线程绑定。</p><p>缺点是一个线程阻塞，这多个用户线程都会被阻塞。</p><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>一个用户线程绑定一个内核线程。</p><p>缺点是每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大，会影响到应用程序的性能。</p><h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>将 n 个用户级线程映射到 m 个内核级线程上，要求 m &lt;= n。</p><p>不会出现一个用户线程阻塞，所有线程都阻塞的情况。</p><p>详解<a href="https://www.cnblogs.com/stemon/p/4855583.html" target="_blank" rel="noopener">多线程模型</a></p><h2 id="与进程区别"><a href="#与进程区别" class="headerlink" title="与进程区别"></a>与进程区别</h2><ul><li>进程是资源分配的最小单位，线程是程序执行的最小单位。</li><li>进程有自己的独立空间，每创建一个进程，都要为他分配独立的地址空间，花费很大。而线程是共享进程地址空间的，花费要小很多。</li><li>进程之间的通信需要以通信的方式（IPC)进行，需要通过内核来通信。而线程可以通过共享变量等方式进行。</li><li>进程之间切换时间比线程之间切换时间要大得多。因为进程之间页表是不同的，需要切换页表，开销比较大。因为各个进程页表不同，TLB，缓存信息可能都需要重新加载。而线程是共享的。</li><li>一个进程死掉，对其他进程没有影响；一个线程死掉，整个进程就会崩溃。<br><strong>当一个线程向非法地址读取或者写入，无法确认这个操作是否会影响同一进程中的其它线程，所以只能是整个进程一起崩溃。</strong></li></ul><h2 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h2><p>与进程上下文切换不同的是，线程上下文切换没有页表以及地址空间的切换，因为同一个进程的线程共享同一个地址空间。只需要进行程序计数器，寄存器，以及线程的堆栈的切换。</p><h2 id="fork-and-exec"><a href="#fork-and-exec" class="headerlink" title="fork and exec"></a>fork and exec</h2><p>linux的fork 和exec 函数。</p><p>fork() 复制出一个子进程，<strong>这个进程几乎是当前进程的一个拷贝</strong>：子进程和父进程使用相同的代码段；子进程复制父进程的堆栈段和数据段。这样，父进程的所有数据都可以留给子进程，但是，子进程一旦开始运行，<strong>虽然它继承了父进程的一切数据，但实际上数据却已经分开，相互之间不再有影响了</strong>，也就是说，它们之间不再共享任何数据了。它们再要交互信息时，只有通过进程间通信来实现，这将是我们下面的内容。既然它们如此相象，系统如何来区分它们呢？这<strong>由函数的返回值来决定的</strong>。对于父进程， fork函数返回了子程序的进程号，而对于子程序，fork函数则返回零。在操作系统中，我们用ps函数就可以看到不同的进程号，对父进程而言，它的进程号是由比它更低 层的系统调用赋予的，而对于子进程而言，它的进程号即是fork函数对父进程的返回值。在程序设计中，父进程和子进程都要调用函数fork（）下面的代码，而我们就是利用fork（）函数对父子进程的不同返回值用if…else…语句来实现让父子进程完成不同的功能。</p><p>exec将替换现有进程，执行exec的程序。</p><p>一个进程一旦调用exec类函数，它本身就”死亡”了，<strong>系统把代码段替换成新的程序的代码，废弃原有的数据段和堆栈段</strong>，并为新程序分配新的数据段与堆栈段，唯一留下的，就是进程号，也就是说，对系统而言，还是同一个进程，不过已经是另一个程序了。</p><h2 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="headerlink" title="僵尸进程和孤儿进程"></a>僵尸进程和孤儿进程</h2><p>正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。</p><p>一个子进exit()之后，内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。直到父进程通过wait / waitpid来取时才释放。这样，一个进程才算是完全终止掉。</p><p>当一个父进程迟迟没有调用wait()，这个子进程内存中保存的信息就迟迟不会释放，包括进程号也不会释放，操作系统的进程号是有限的，因此僵尸进程的危害很大。</p><p>当一个父进程退出，子进程还在运行，那么子进程将会称为孤儿进程。孤儿进程会被init进程处理，使用wait()完成进程的终止等，因此，孤儿进程是没有坏处的。</p><p><strong>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</strong></p><p><strong>僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h2&gt;&lt;p&gt;进程是&lt;strong&gt;资源分配的基本单位&lt;/strong&gt;，他是程序运行时的一个实例。&lt;br&gt;程序运行时，系统会创建一个进程，并分配相关的资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序是静态的，进程是动态的&lt;/strong&gt;。一个程序可以对应多个进程，一个进程可以包括多个程序。&lt;/p&gt;
&lt;p&gt;进程=程序+数据+状态信息。&lt;/p&gt;
    
    </summary>
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统概述</title>
    <link href="http://yoursite.com/2019/10/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2019/10/07/操作系统概述/</id>
    <published>2019-10-07T12:47:33.000Z</published>
    <updated>2019-10-11T02:34:30.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><p>操作系统主要进行应用程序管理，资源管理，外设管理等工作。</p><p><strong>在操作系统中，将CPU抽象为进程，将内存抽象为地址空间，将磁盘抽象为文件。</strong><br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/30/1559223725482-1559223725514.png" alt="title"></p><p>OS=shell+kernel.shell就是GUI或者是命令行。Kernel是操作系统的核心。</p><a id="more"></a><p>kernel主要完成的工作包括<strong>CPU调度，物理内存虚拟内存的管理，文件系统的管理，中断处理，外设管理等</strong>。</p><p>kernel的特征：</p><ul><li><strong>并发</strong>（应用并发执行）。</li><li><strong>共享</strong>。某一个公共资源是可以共享访问的还是互斥访问的。</li><li><strong>虚拟化</strong>。将物理实体虚拟化为逻辑实体。主要包括时分复用(时间片)和空分复用(虚拟内存)。</li><li><strong>异步</strong>。</li></ul><h2 id="OS启动过程"><a href="#OS启动过程" class="headerlink" title="OS启动过程"></a>OS启动过程</h2><p>Disk：存储bootloader以及OS.<br>BIOS:基本IO处理系统。</p><p>最先放入内存的是BIOS启动固件。BIOS的第一步是检测外设，完成后，将bootloader加载进内存，并且CPU控制权转交给bootloader，bootloader再将磁盘上的OS加载进内存，这是OS掌控CPU。</p><p>BIOS—&gt;加载bootloader—&gt;加载OS。（所以说我们安装系统的时候要先进入BIOS设置启动项，这个启动项就是bootloader）。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/30/1559224752551-1559224752559.png" alt="title"></p><h2 id="系统调用，中断，异常"><a href="#系统调用，中断，异常" class="headerlink" title="系统调用，中断，异常"></a>系统调用，中断，异常</h2><p>都需要从用户态转移到内核态。</p><h3 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h3><p>来源于外设。</p><p>为了<strong>支持CPU 和设备之间 的 并行操作</strong>。当IO事件完成之后，设备中断通知CPU，CPU在进行相应事件的处理。可以看作是一种异步操作啊。</p><p>当CPU 启动设备进行输入/输出后 ，设备便可以独立工作，CPU 转去处理与此次输入/输出不相关的 事情；当设备完成输入/输出后，通过向CPU 发中断报告此次 输入/输出的结果，让CPU 决定如何处理以后的事情。</p><h4 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h4><ul><li>设备（硬件）将中断事件的ID传递给中断寄存器。不<strong>同的中断ID范围代表不同的中断类型</strong>。</li><li>CPU在执行完一条指令后，会查看中断寄存器，假如有中断的话，进行中断处理。</li><li>CPU保存现场。保存各种寄存器等。</li><li>CPU 根据中断码查中断向量表，获得与该中断相关的处理程序的入口地址。</li><li>进行相应中断处理。</li><li>恢复之前保存的处理状态。</li></ul><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>来源于应用程序。CPU执行指令非法。</p><p>异常过程与中断过程差不多，也是保存现场，处理，恢复现场这几个过程。</p><p>但是不同的是，异常一般是交给进程自己来处理，而中断是由内核的中断函数来处理，根据不同的中断类型执行不同的中断函数。</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>当应用程序需要调用系统级别的函数请求。</p><h4 id="系统调用过程"><a href="#系统调用过程" class="headerlink" title="系统调用过程"></a>系统调用过程</h4><ul><li>每一个系统调用对应一个系统调用号。</li><li>根据系统调用号选取相应的系统调用例程进行系统调用。</li><li>返回系统调用结果。</li></ul><p>系统调用需要从用户态切换到内核态。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>系统调用，中断，异常机制其实都是大同小异。在操作系统中都维持着一个表，中断是中断号和中断函数对应，系统调用是系统调用号和系统调用函数，根据ID去调用相应的函数，返回结果。</p><p>而且OS都需要从用户态转到内核态。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是操作系统&quot;&gt;&lt;a href=&quot;#什么是操作系统&quot; class=&quot;headerlink&quot; title=&quot;什么是操作系统&quot;&gt;&lt;/a&gt;什么是操作系统&lt;/h2&gt;&lt;p&gt;操作系统主要进行应用程序管理，资源管理，外设管理等工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在操作系统中，将CPU抽象为进程，将内存抽象为地址空间，将磁盘抽象为文件。&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/30/1559223725482-1559223725514.png&quot; alt=&quot;title&quot;&gt;&lt;/p&gt;
&lt;p&gt;OS=shell+kernel.shell就是GUI或者是命令行。Kernel是操作系统的核心。&lt;/p&gt;
    
    </summary>
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>IO线程模型</title>
    <link href="http://yoursite.com/2019/09/30/IO%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/09/30/IO线程模型/</id>
    <published>2019-09-30T11:31:56.000Z</published>
    <updated>2019-10-11T02:36:41.933Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阻塞I-O"><a href="#阻塞I-O" class="headerlink" title="阻塞I/O"></a>阻塞I/O</h1><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/07/1557216950760-1557216950760.png" alt="title"></p><ul><li>每一条连接都需要建立一个独立的线程来处理，机器耗费线程资源。</li><li>当没有数据读写时，线程还会阻塞。</li></ul><a id="more"></a><h1 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h1><p><strong>IO多路复用+线程池来实现</strong>。<br>I/O多路复用来解决会有多个线程阻塞的问题，IO多路复用只会造成一个线程阻塞。<br>线程池不必为每个连接都建立一个新的线程。</p><p>Reactor模型，是指通过一个或多个输入同时传递给服务处理器的服务请求的事件驱动处理模式。 服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor模式也叫Dispatcher模式，即<strong>I/O多路复用统一监听事件，收到事件后分发</strong>(Dispatch给某进程)。</p><p>Reactor两个关键组成：</p><ul><li>Reactor<br>负责监听和分发事件，分发给适当的处理程序来对IO事件做出反应。</li><li>Handler<br>处理程序执行I/O事件要完成的实际事件.<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/07/1557217752478-1557217752483.png" alt="title"><h2 id="单Reactor"><a href="#单Reactor" class="headerlink" title="单Reactor"></a>单Reactor</h2><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/07/1557217879896-1557217879896.png" alt="title"></li><li>Reactor对象通过select不断轮询监控客户端请求事件，收到事件后通过dispatch进行分发</li><li>如果是建立连接请求事件，则由Acceptor通过accept处理连接请求，然后创建一个Handler对象处理连接完成后的后续业务处理</li><li>如果不是建立连接事件，则Reactor会分发调用连接对应的Handler来响应</li><li>Handler会完成read-&gt;业务处理-&gt;send的完整业务流程<h2 id="单Reactor多线程"><a href="#单Reactor多线程" class="headerlink" title="单Reactor多线程"></a>单Reactor多线程</h2>主要通过建立一个线程池。<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/07/1557218020262-1557218020277.png" alt="title"><br>Worker线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给Handler进行处理。</li></ul><h2 id="主从Reactor多线程"><a href="#主从Reactor多线程" class="headerlink" title="主从Reactor多线程"></a>主从Reactor多线程</h2><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/07/1557218140668-1557218140683.png" alt="title"></p><ul><li>Reactor主线程MainReactor对象通过select监控建立连接事件，收到事件后通过Acceptor接收，处理建立连接事件。</li><li>Accepto处理建立连接事件后，MainReactor将Socket分配Reactor子线程给<strong>SubReactor进行处理</strong>。</li><li>SubReactor将Socket加入连接队列进行监听，并创建一个Handler用于处理各种连接事件，例如读写操作。</li><li>当有新的事件发生时，SubReactor会调用连接对应的Handler进行响应</li><li>Handler通过read读取数据后，会分发给后面的Worker线程池进行业务处理</li><li>Worker线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给Handler进行处理</li><li>Handler收到响应结果后通过send将响应结果返回给client<h2 id="NIO代码"><a href="#NIO代码" class="headerlink" title="NIO代码"></a>NIO代码</h2></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> nioDemo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.CharBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*服务器端，:接收客户端发送过来的数据并显示，</span></span><br><span class="line"><span class="comment"> *服务器把上接收到的数据加上"echo from service:"再发送回去*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceSocketChannelDemo</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPEchoServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="comment">/*服务器地址*/</span></span><br><span class="line">        <span class="keyword">private</span> InetSocketAddress localAddress; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TCPEchoServer</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.localAddress = <span class="keyword">new</span> InetSocketAddress(port);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            ServerSocketChannel ssc = <span class="keyword">null</span>;</span><br><span class="line">            Selector selector = <span class="keyword">null</span>;           </span><br><span class="line">            Random rnd = <span class="keyword">new</span> Random();   </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/*创建选择器*/</span></span><br><span class="line">                selector = Selector.open();</span><br><span class="line">                <span class="comment">/*创建服务器通道*/</span></span><br><span class="line">                ssc = ServerSocketChannel.open();</span><br><span class="line">                ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">/*设置监听服务器的端口，设置最大连接缓冲数为100*/</span></span><br><span class="line">                ssc.bind(localAddress, <span class="number">100</span>);</span><br><span class="line">                <span class="comment">/*服务器通道只能对tcp链接事件感兴趣*/</span></span><br><span class="line">                ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                System.out.println(<span class="string">"server start failed"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            System.out.println(<span class="string">"server start with address : "</span> + localAddress);  </span><br><span class="line">            <span class="comment">/*服务器线程被中断后会退出*/</span></span><br><span class="line">            <span class="keyword">try</span>&#123;   </span><br><span class="line">                <span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;      </span><br><span class="line">                    <span class="keyword">int</span> n = selector.select();</span><br><span class="line">                    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Set&lt;SelectionKey&gt; keySet = selector.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; it = keySet.iterator();</span><br><span class="line">                    SelectionKey key = <span class="keyword">null</span>; </span><br><span class="line">                    <span class="keyword">while</span>(it.hasNext())&#123;               </span><br><span class="line">                        key = it.next();</span><br><span class="line">                        <span class="comment">/*防止下次select方法返回已处理过的通道*/</span></span><br><span class="line">                        it.remove();           </span><br><span class="line">                        <span class="comment">/*若发现异常，说明客户端连接出现问题,但服务器要保持正常*/</span></span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            <span class="comment">/*ssc通道只能对链接事件感兴趣*/</span></span><br><span class="line">                            <span class="keyword">if</span>(key.isAcceptable())&#123;  </span><br><span class="line">                                <span class="comment">/*accept方法会返回一个普通通道，</span></span><br><span class="line"><span class="comment">                                     每个通道在内核中都对应一个socket缓冲区*/</span></span><br><span class="line">                                SocketChannel sc = ssc.accept();</span><br><span class="line">                                sc.configureBlocking(<span class="keyword">false</span>);      </span><br><span class="line">                     <span class="comment">/*向选择器注册这个通道和普通通道感兴趣的事件，同时提供这个新通道相关的缓冲区*/</span></span><br><span class="line">                                <span class="keyword">int</span> interestSet = SelectionKey.OP_READ;                   </span><br><span class="line">                                sc.register(selector, interestSet, <span class="keyword">new</span> Buffers(<span class="number">256</span>,<span class="number">256</span>));</span><br><span class="line">                                System.out.println(<span class="string">"accept from"</span>+ sc.getRemoteAddress());</span><br><span class="line">                            &#125;    </span><br><span class="line">                            <span class="comment">/*（普通）通道感兴趣读事件且有数据可读*/</span></span><br><span class="line">                            <span class="keyword">if</span>(key.isReadable())&#123;           </span><br><span class="line">                                <span class="comment">/*通过SelectionKey获取通道对应的缓冲区*/</span></span><br><span class="line">                                Buffers  buffers = (Buffers)key.attachment();</span><br><span class="line">                                ByteBuffer readBuffer = buffers.getReadBuffer();</span><br><span class="line">                                ByteBuffer writeBuffer = buffers.gerWriteBuffer();</span><br><span class="line">                                 </span><br><span class="line">                                <span class="comment">/*通过SelectionKey获取对应的通道*/</span></span><br><span class="line">                                SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                                 </span><br><span class="line">                                <span class="comment">/*从底层socket读缓冲区中读入数据*/</span></span><br><span class="line">                                sc.read(readBuffer);</span><br><span class="line">                                readBuffer.flip();</span><br><span class="line">                                 </span><br><span class="line">                                <span class="comment">/*解码显示，客户端发送来的信息*/</span></span><br><span class="line">                                CharBuffer cb = utf8.decode(readBuffer);</span><br><span class="line">                                System.out.println(cb.array());                 </span><br><span class="line">                                readBuffer.rewind(); </span><br><span class="line">                                <span class="comment">/*准备好向客户端发送的信息*/</span></span><br><span class="line">                                <span class="comment">/*先写入"echo:"，再写入收到的信息*/</span></span><br><span class="line">                                writeBuffer.put(<span class="string">"echo from service:"</span>.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">                                writeBuffer.put(readBuffer);</span><br><span class="line">                                readBuffer.clear();  </span><br><span class="line">                                <span class="comment">/*设置通道写事件*/</span></span><br><span class="line">                                key.interestOps(key.interestOps() | SelectionKey.OP_WRITE);</span><br><span class="line">                                                                 </span><br><span class="line">                            &#125;</span><br><span class="line">                             </span><br><span class="line">                            <span class="comment">/*通道感兴趣写事件且底层缓冲区有空闲*/</span></span><br><span class="line">                            <span class="keyword">if</span>(key.isWritable())&#123; </span><br><span class="line">                                doSomething();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                            System.out.println(<span class="string">"service encounter client error"</span>);</span><br><span class="line">                            <span class="comment">/*若客户端连接出现异常，从Seletcor中移除这个key*/</span></span><br><span class="line">                            key.cancel();</span><br><span class="line">                            key.channel().close();</span><br><span class="line">                        &#125;</span><br><span class="line"> </span><br><span class="line">                    &#125;   </span><br><span class="line">                    Thread.sleep(rnd.nextInt(<span class="number">500</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                 </span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                System.out.println(<span class="string">"serverThread is interrupted"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                System.out.println(<span class="string">"serverThread selecotr error"</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    selector.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"selector close failed"</span>);</span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"server close"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException</span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> TCPEchoServer(<span class="number">8080</span>));</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">        <span class="comment">/*结束服务器线程*/</span></span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Proactor模型（异步）"><a href="#Proactor模型（异步）" class="headerlink" title="Proactor模型（异步）"></a>Proactor模型（异步）</h1><p>主要的核心在于回调机制。<br>Reactor在接收事件后需要交给Reactor处理。而Proactor直接由操作系统来处理相关事件，然后返回结果。<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/07/1557218800106-1557218800122.png" alt="title"></p><p><a href="https://juejin.im/post/5b908419e51d450e704230f0#heading-11" target="_blank" rel="noopener">理解高性能网络模型</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;阻塞I-O&quot;&gt;&lt;a href=&quot;#阻塞I-O&quot; class=&quot;headerlink&quot; title=&quot;阻塞I/O&quot;&gt;&lt;/a&gt;阻塞I/O&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/07/1557216950760-1557216950760.png&quot; alt=&quot;title&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每一条连接都需要建立一个独立的线程来处理，机器耗费线程资源。&lt;/li&gt;
&lt;li&gt;当没有数据读写时，线程还会阻塞。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="IO" scheme="http://yoursite.com/categories/IO/"/>
    
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>I/O模型</title>
    <link href="http://yoursite.com/2019/09/29/IO%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/09/29/IO模型/</id>
    <published>2019-09-29T07:12:09.000Z</published>
    <updated>2019-10-11T02:37:01.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Socket与ServerSocket"><a href="#Socket与ServerSocket" class="headerlink" title="Socket与ServerSocket"></a>Socket与ServerSocket</h2><p>网络通信需要一对socket，即通信的两端各有一个socket，两个socket之间形成一个管道，进行数据流的通信。<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/05/1557035867781-1557035868213.png" alt="title"><br>ServerSocket<br>ServerSocket监听服务器端的一个端口，当一个客户端发送来连接时，ServerSocket来处理连接，成功后返回一个常规的Socket对象，用来与客户端socket进行数据传输。</p><h1 id="同步-异步-阻塞-非阻塞"><a href="#同步-异步-阻塞-非阻塞" class="headerlink" title="同步 异步 阻塞 非阻塞"></a>同步 异步 阻塞 非阻塞</h1><p><strong>同步与异步主要是从消息通知机制角度来说的。</strong><br>当一个同步调用发出后，调用者要一直等待返回消息（结果）后，才能进行后续的执行；当一个异步过程调用发出后，调用者不能立刻得到返回消息（结果），实际处理这个调用的部件在完成后，通过<strong>状态、通知和回调</strong>来通知调用者。异步是调用完成后由别人来通知他。</p><a id="more"></a><p>阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的。<br>阻塞调用是指调用结果返回之前，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务。<br>非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。如果在这个等待的过程中，等待者除了等待消息通知之外不能做其它的事情，那么该机制就是阻塞的。</p><p>阻塞与同步是不同的。如果这个线程在等待函数返回时，仍在执行其他消息处理，那么这就是同步非阻塞。如果这个线程在等待函数返回时，没有执行其他消息处理，而是挂起等待，那么就是同步阻塞</p><h1 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h1><p>操作系统将内存空间分为了<strong>内核空间和用户空间</strong>。<br>进程切换非常的耗资源，所以能不挂起进程就不挂起进程。<br>将进程阻塞是让出CPU资源。</p><p>对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：1. 等待数据准备 (Waiting for the data to be ready)2. 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</p><h1 id="Linux-IO的五种模型"><a href="#Linux-IO的五种模型" class="headerlink" title="Linux IO的五种模型"></a>Linux IO的五种模型</h1><h2 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h2><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/05/1557037472070-1557037472074.png" alt="title"></p><p><img src="https://user-gold-cdn.xitu.io/2019/3/25/169b2de92af4b59b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>当应用进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在进程这边，整个应用进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，应用进程才解除block的状态，重新运行起来。在内核执行I/O的两个阶段，都是阻塞的。<strong>每个连接都需要配套一个线程，不适合高并发的情况。</strong></p><p><strong>在阻塞的过程中，这个线程被挂起了，但是他让出了CPU，其他应用进程可以继续占用CPU执行。</strong></p><h2 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h2><p>基于轮询的方式。<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/05/1557037653186-1557037653231.png" alt="title"><br>当所请求的I/O操作不能满足要求时候，不把本进程投入睡眠，而是返回一个错误。也就是说当数据没有到达时并不等待，而是以一个错误返回。并且进程会多次轮询的请求I/O操作。应用程序的线程需要不断的进行 I/O 系统调用，轮询数据是否已经准备好，如果没有准备好，继续轮询，直到完成系统调用为止 。这样，好处是线程不需要一直阻塞，但是需要不断地进行I/O系统调用，<strong>不断轮询，浪费CPU</strong>。不断发起I/O操作及其浪费CPU资源。同步非阻塞就是 “每隔一会儿瞄一眼进度条” 的轮询（polling）方式。<br>需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。</p><h2 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h2><p>基于操作系统的poll，select，epoll。<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/05/1557037849336-1557037849341.png" alt="title"><br>非阻塞IO问题：<br>由于同步非阻塞方式需要不断主动轮询，轮询占据了很大一部分过程，轮询会消耗大量的CPU时间，但是服务器端可能会有多个连接，这样他对每一个连接都这样做，要是连接数量太多时，是不适合的。</p><p>IO多路复用有两个特别的系统调用select、poll、epoll函数。select调用是内核级别的，select轮询相对非阻塞的轮询的区别在于—<strong>前者可以等待多个socket，能实现同时对多个IO端口进行监听</strong>，当其中任何一个socket的数据准好了，就能返回进行可读，然后进程再进行recvform系统调用，将数据由内核拷贝到用户进程，当然这个过程是阻塞的。</p><p>select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function<strong>会不断的轮询所负责的所有socket</strong>，当某个socket有数据到达了，就通知用户进程。</p><p>这几个函数也会使进程阻塞，但是和阻塞I/O所不同的的，<strong>这两个函数可以同时阻塞多个I/O操作</strong>（只需要阻塞一个select函数）。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时（注意不是全部数据可读或可写），才真正调用I/O操作函数。</p><p>上面的图和blocking IO的图其实并没有太大的不同，在两个阶段都需要阻塞。当连接数量很少的时候，I/O多路复用可能比BIO效率还要低，因为I/O多路复用需要多执行一个select内核操作。但是I/O多路复用的优势在于他可以处理更多的连接，而不是处理单个连接速度更快。与传统的多线程/多进程模型比，I/O多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降底了系统的维护工作量，节省了系统资源。</p><h2 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h2><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/05/1557039387817-1557039387825.png" alt="title"><br>在信号驱动式I/O模型中，应用程序使用套接口进行信号驱动I/O，并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。</p><p>基本不怎么用。</p><h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/05/1557039496514-1557039496560.png" alt="title"><br>用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会<strong>直接返回给用户进程</strong>，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核<strong>向进程发送通知（回调函数）</strong>。IO两个阶段，进程都是非阻塞的。</p><p>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>注意：同步非阻塞I/O和I/O多路复用，在返回可读条件后，都需要再调用一次I/O操作，进行复制数据。首先一个IO操作其实分成了两个步骤：发起IO请求和实际的IO操作，同步IO和异步IO的区别就在于第二个步骤是否阻塞，如果实际的IO读写阻塞请求进程，那么就是同步IO，因此阻塞IO、非阻塞IO、IO复用、信号驱动IO都是同步IO，如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，那么就是异步IO。阻塞IO和非阻塞IO的区别在于第一步，发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。</p><h1 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select poll epoll"></a>select poll epoll</h1><p>目前支持I/O多路复用的系统调用有 select，poll，epoll，I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，<strong>一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作</strong>。select，pselect，poll，epoll本质上都是同步I/O。</p><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>用于表述指向文件的引用的抽象化概念。。<br>当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p><h2 id="Linux的socket事件wakeup-callback机制"><a href="#Linux的socket事件wakeup-callback机制" class="headerlink" title="Linux的socket事件wakeup callback机制"></a>Linux的socket事件wakeup callback机制</h2><p>linux wakeup callback机制是IO多路复用的本质。</p><p>Linux通过socket睡眠队列来管理所有等待socket的某个事件的进程（Process），同时通过wakeup机制来异步唤醒整个睡眠队列上等待事件的Process，通知Process相关事件发生。</p><p>每个socket维护了一个队列，比如socket可读的时候，内核就会唤醒队列里的各个Process，并且执行每个Process的callback函数。</p><p>每一个socket都有sleep_list,当某个进程所关心的事件在socket中并没有发生，那么将进程插入到sleep_list，当socket的时间发生了，那么就去遍历他sleep_list中的每个进程的callback函数。</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>我们以read事件为例子。<br>当socket上所监听的事件发生了，那么相应的进程就去处理。那么怎么获取监听的事件发生呢？<br>我们应该block在等待事件的发生上，这个事件简单点就是关心的N个socket中一个或多个socket有数据可读了，当block解除的时候，就意味着，我们一定可以找到一个或多个socket上有可读的数据。</p><p>根据wakeup callback。<br>所以，进程需要同时插入到我们管理的这好多个socket的sleep_list上等待任意一个socket可读事件发生而被唤醒，当Process被唤醒的时候，其callback里面应该有个逻辑去检查具体哪些socket可读了。</p><p>举个例子：<br>假设c1，c2，c3连接到了服务器端，我们想监听他们的读事件，因此我们将进程p1插入到他们与服务器各自的socket中sleep_list中去，此时没有事件发生，因此进程处于睡眠状态，当c1客户端发送来了数据，有数据读取的时候，p1进程被唤醒。<br>伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private int sk_event;</span><br><span class="line"></span><br><span class="line">void poll() &#123;</span><br><span class="line">    //其他逻辑...</span><br><span class="line">    when (receive queue is not empty) &#123;</span><br><span class="line">        sk_event |= POLL_IN；</span><br><span class="line">    &#125;</span><br><span class="line">   //其他逻辑...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当receive queue不为空的时候（即收到了消息），我们就给这个socket的sk_event添加一个POLL_IN事件，用来<strong>表示当前这个socket可读</strong>。将来Process遍历到这个socket，发现其sk_event包含POLL_IN的时候，就可以对这个socket进行读取数据操作了。</p><p>接下来，p1执行select，select会将需要监控的readfds集合拷贝到内核空间（因为内核才能通知说某个socket可读），然后遍历自己监控的socket，挨个调用socket的poll逻辑以便检查该socket是否有可读事件。<br>遍历完所有的socket后，如果没有任何一个sk可读，那么select会调用schedule，使得Process进入睡眠（或者睡眠timeout这么长时间）。如果在timeout时间内某个socket上有数据可读了，或者等待timeout了，则调用select的Process会被唤醒。<br>伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (socket in readfds) &#123;</span><br><span class="line">    sk_event.evt = socket.poll();</span><br><span class="line">    sk_event.sk = socket;</span><br><span class="line">    return_event_for_process;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</span><br></pre></td></tr></table></figure><p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，<strong>直到有描述符就绪</strong>（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），<strong>函数返回</strong>。<strong>当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</strong><br>select缺点：<br>1.文件描述符的数量存在最大限制，在Linux上一般为1024。</p><p>2.对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。<br>每次select()都需要扫描所有的fd_set。而epoll是通过注册回调函数来实现的，所以epoll效率大大高于select.</p><p>3.需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</p><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>解决了文件描述符数量限制的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int poll (struct pollfd *fds, unsigned int nfds, int timeout);</span><br></pre></td></tr></table></figure><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。<br>与select两点区别：<br>1.文件描述符大小不限制。<br>2.不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct pollfd &#123;</span><br><span class="line">    int fd; /* file descriptor */</span><br><span class="line">    short events; /* requested events to watch */</span><br><span class="line">    short revents; /* returned events witnessed */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>pollfd结构包含了要监视的event和发生的event。</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>解决了需要循环遍历文件描述符的缺点，解决了需要将大量的fds从内核拷贝到用户空间的问题。</p><p>将大量的fds从内核拷贝到用户空间的解决：<br>共享内存。<br>epoll通过内核与用户空间mmap同一块内存来解决。mmap将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址（不管是用户空间还是内核空间都是虚拟地址，最终要通过地址映射映射到物理地址），使得这块物理内存对内核和对用户均可见，减少用户态和内核态之间的数据交换。</p><p>需要循环遍历文件描述符的解决：<br>epoll引入了一个中间层，一个双向链表ready_list，一个单独的睡眠队列single_epoll_wait_list。<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/07/1557212167413-1557212167863.png" alt="title"><br>1.调用epoll之前，我们希望我们的MyProcess可以管理四个socket。<br>2.四个socket都没有事件，这时候MyProcess进入single_epoll_wait_list并且sleep。<br>3.有一个socket（大红色）收到了数据，触发其wait_entry_sk，把这个socket加入到ready_list里。<br>4.MyProcess被唤醒（从single_epoll_wait_list出来了表示被唤醒），来处理ready_list中的所有socket：遍历epoll的ready_list，挨个调用每个socket的poll逻辑收集发生的事件，对于监控可读事件而已，ready_list上的每个socket都是有数据可读的，这里的遍历必要的。</p><p>epoll有两种工作模式，LT和ET。<br>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p><p><a href="https://blog.csdn.net/j080624/article/details/78468396" target="_blank" rel="noopener">ServerSocket与Socket</a><br><a href="https://www.jianshu.com/p/486b0965c296" target="_blank" rel="noopener">Linux 五种IO模型</a><br><a href="https://www.jianshu.com/p/dfd940e7fca2" target="_blank" rel="noopener">select、poll、epoll详解</a><br><a href="https://segmentfault.com/a/1190000003063859#articleHeader15" target="_blank" rel="noopener">Linux IO模式及 select、poll、epoll详解</a><br><a href="https://wyj.shiwuliang.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SELECT%E3%80%81POLL%E5%92%8CEPOLL%20.html" target="_blank" rel="noopener">深入理解select，poll，epoll</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Socket与ServerSocket&quot;&gt;&lt;a href=&quot;#Socket与ServerSocket&quot; class=&quot;headerlink&quot; title=&quot;Socket与ServerSocket&quot;&gt;&lt;/a&gt;Socket与ServerSocket&lt;/h2&gt;&lt;p&gt;网络通信需要一对socket，即通信的两端各有一个socket，两个socket之间形成一个管道，进行数据流的通信。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/05/1557035867781-1557035868213.png&quot; alt=&quot;title&quot;&gt;&lt;br&gt;ServerSocket&lt;br&gt;ServerSocket监听服务器端的一个端口，当一个客户端发送来连接时，ServerSocket来处理连接，成功后返回一个常规的Socket对象，用来与客户端socket进行数据传输。&lt;/p&gt;
&lt;h1 id=&quot;同步-异步-阻塞-非阻塞&quot;&gt;&lt;a href=&quot;#同步-异步-阻塞-非阻塞&quot; class=&quot;headerlink&quot; title=&quot;同步 异步 阻塞 非阻塞&quot;&gt;&lt;/a&gt;同步 异步 阻塞 非阻塞&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;同步与异步主要是从消息通知机制角度来说的。&lt;/strong&gt;&lt;br&gt;当一个同步调用发出后，调用者要一直等待返回消息（结果）后，才能进行后续的执行；当一个异步过程调用发出后，调用者不能立刻得到返回消息（结果），实际处理这个调用的部件在完成后，通过&lt;strong&gt;状态、通知和回调&lt;/strong&gt;来通知调用者。异步是调用完成后由别人来通知他。&lt;/p&gt;
    
    </summary>
    
      <category term="IO" scheme="http://yoursite.com/categories/IO/"/>
    
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Java线程</title>
    <link href="http://yoursite.com/2019/09/29/Java%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/09/29/Java线程/</id>
    <published>2019-09-29T05:53:25.000Z</published>
    <updated>2019-10-11T02:35:45.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发作用"><a href="#并发作用" class="headerlink" title="并发作用"></a>并发作用</h2><p>将多核CPU的计算能力发挥到极致，性能得到提升。</p><p>面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分。</p><a id="more"></a><h2 id="并发缺点"><a href="#并发缺点" class="headerlink" title="并发缺点"></a>并发缺点</h2><ul><li>线程安全问题。</li><li>频繁的上下文切换。</li></ul><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p>Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once。并发指的是多个任务交替进行，而<strong>并行则是指真正意义上的“同时进行</strong>”。实际上，如果系统内只有一个CPU，而使用多线程时，那么真实系统环境下不能并行，只能通过切换时间片的方式交替进行，而成为并发执行任务。真正的并行也只能出现在拥有多个CPU的系统中。</p><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>主要从消息通知角度来看。</p><p>同步是说在调用一个函数后，直到执行完成才返回结果。</p><p>异步是在调用一个函数之后，立即返回，等待函数执行完成之后，通过<strong>状态、通知和回调</strong>来通知调用者。</p><h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><p>主要从等待返回结果时的状态来看。</p><p>阻塞就是在等待返回结果时，当前线程会被挂起，让出CPU，不能执行其他业务。</p><p>非阻塞就是在等待返回结果时，当前线程不会阻塞，可以去执行其他的业务。</p><h3 id="临界区资源"><a href="#临界区资源" class="headerlink" title="临界区资源"></a>临界区资源</h3><p>临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每个线程使用时，一旦临界区资源被一个线程占有，那么其他线程必须等待。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><ul><li>继承Thread</li><li>实现Runnable</li><li>实现Callable</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extends thread</span></span><br><span class="line">     Thread t1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             System.out.println(<span class="string">"t1"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     t1.start();</span><br><span class="line">     <span class="comment">// implements Runnable</span></span><br><span class="line">     Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             System.out.println(<span class="string">"t2"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     t2.start();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// implements Callable,Callable可以有返回值</span></span><br><span class="line">     ExecutorService service=Executors.newSingleThreadExecutor();</span><br><span class="line">     Future&lt;String&gt; future=service.submit(<span class="keyword">new</span> Callable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="string">"thread 3"</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         String result=future.get();</span><br><span class="line">         System.out.println(result);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/07/1570450394461-1570450394478.png" alt="title"></p><ul><li><p>新建(new)，创建线程。</p></li><li><p>Runnable。包括Running和Ready两个阶段，Running就是占用CPU运行，Ready是线程还处于等待阶段。</p></li><li><p>阻塞(Blocked)。等待获取临界区资源，一旦他获得了锁就会结束这个状态。</p></li><li><p>无限期等待(Waiting)。</p><p>等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>没有设置 Timeout 参数的 Object.wait() 方法</td><td>Object.notify() / Object.notifyAll()</td></tr><tr><td>没有设置 Timeout 参数的 Thread.join() 方法</td><td>被调用的线程执行完毕</td></tr><tr><td>LockSupport.park() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table></li><li><p>限期等待(Timed-waiting)。</p><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>Thread.sleep() 方法</td><td>时间结束</td></tr><tr><td>设置了 Timeout 参数的 Object.wait() 方法</td><td>时间结束 / Object.notify() / Object.notifyAll()</td></tr><tr><td>设置了 Timeout 参数的 Thread.join() 方法</td><td>时间结束 / 被调用的线程执行完毕</td></tr><tr><td>LockSupport.parkNanos() 方法</td><td>LockSupport.unpark(Thread)</td></tr><tr><td>LockSupport.parkUntil() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table></li><li><p>终止。线程任务结束，或者是产生了异常而终止。</p></li></ul><h3 id="线程基本操作"><a href="#线程基本操作" class="headerlink" title="线程基本操作"></a>线程基本操作</h3><h4 id="sleep-and-wait"><a href="#sleep-and-wait" class="headerlink" title="sleep() and wait()"></a>sleep() and wait()</h4><p>sleep会休眠当前线程，等到了时间，自动苏醒。</p><p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，<strong>其它线程会调用</strong> <strong>notify() 或者 notifyAll() 来唤醒挂起的线程</strong>。</p><p>两者区别：</p><ul><li><p>sleep到点自己醒，<strong>wait需要其他线程调用notify来唤醒</strong>。</p></li><li><p>wait()方法必须要在<strong>同步方法或者同步块中调用</strong>，也就是必须已经获得对象锁。</p></li><li><p>sleep不释放锁，wait释放锁。</p></li></ul><h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><p>在<strong>线程中调用另一个线程的 join() 方法，会将当前线程挂起</strong>，而不是忙等待，<strong>直到目标线程结束</strong>。</p><p>对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。</p><h4 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h4><p>一旦执行，当前线程会让出cpu，但是，需要注意的是，让出的CPU并不是代表当前线程不再运行了，如果在下一次竞争中，又获得了CPU时间片当前线程依然会继续运行。另外，让出的时间片只会分配<strong>给当前线程相同优先级</strong>的线程。</p><p>sleep()和yield()方法，同样都是当前线程会交出处理器资源，而它们不同的是，sleep()交出来的时间片其他线程都可以去竞争，也就是说都有机会获得当前线程让出的时间片。而yield()方法只允许与当前线程具有相同优先级的线程能够获得释放出来的CPU时间片。</p><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p><p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。</p><p>main() 属于非守护线程。</p><p>使用 setDaemon() 方法将一个线程设置为守护线程</p><h3 id="线程中断问题"><a href="#线程中断问题" class="headerlink" title="线程中断问题"></a>线程中断问题</h3><p>线程可以调用interrupt()来中断别的线程。但这个操作并不一定会使线程中断，更像是给了线程一个通知，但具体是否中断还是要看线程本身。</p><h4 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h4><p>通过调用一个线程的 interrupt() 来中断该线程，<strong>如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程</strong>。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p><h4 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h4><p>如果线程不处在等待或者是阻塞状态，那么直接interrupt是不能中断线程的。但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。</p><p>这样，线程就可以对相应的中断请求进行处理了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Thread t1=<span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">while</span>(!isInterrupted()) &#123;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"end......."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">t1.start();</span><br><span class="line">t1.interrupt();</span><br><span class="line">System.out.println(t1.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;并发作用&quot;&gt;&lt;a href=&quot;#并发作用&quot; class=&quot;headerlink&quot; title=&quot;并发作用&quot;&gt;&lt;/a&gt;并发作用&lt;/h2&gt;&lt;p&gt;将多核CPU的计算能力发挥到极致，性能得到提升。&lt;/p&gt;
&lt;p&gt;面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM字节码执行引擎</title>
    <link href="http://yoursite.com/2019/09/25/%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <id>http://yoursite.com/2019/09/25/字节码执行引擎/</id>
    <published>2019-09-25T01:57:50.000Z</published>
    <updated>2019-10-22T07:03:16.416Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法调用就是确定调用哪一个方法。</p><p>在编译阶段，即将java文件转化为class文件，<strong>class文件中存储的是方法的符号引用(类似于一个代号吧)，而不是直接引用</strong>(内存地址)，因为类还没有加载到内存嘛，所以具体的内存地址肯定是不知道的。</p><p>因此，需要到类加载期间，甚至是运行期间才可能确定目标方法的直接引用。</p><a id="more"></a><p>在类加载的阶段，会将一部分符号引用转化为直接引用，前提是</p><blockquote><p>方法在程序运行前就可以确定他是哪一个。</p></blockquote><p>比如说private和static两类方法，这是因为<strong>这两类方法都不可能被继承或者是被重写，只可能有唯一的版本</strong>。别的方法就有可能被重写，存在多个版本，难以确定。</p><p>除了这两类，还有构造方法以及final方法，这几个都是不可能被重写的，可以唯一确定。</p><p>所以，<strong>私有方法，final方法，构造方法，static方法在编译期间既可以完全确定</strong>，<strong>在类加载阶段</strong>直接将符号引用转化为直接引用，其他方法都是在运行期间才能确定。</p><h2 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h2><p>重载和重写在JVM中是如何实现的？</p><h3 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h3><p>重载的实现。</p><p>重载时是<strong>通过参数的静态类型</strong>而不是实际类型决定使用哪个重载函数。</p><p>所以，重载的实现需要参数类型或者个数不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Father是静态类型 ， Son是实际类型。</span></span><br><span class="line">Father father = <span class="keyword">new</span> Son();</span><br></pre></td></tr></table></figure><p>所以，<strong>在编译阶段就可以确定重载的函数是哪一个</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Son();          <span class="comment">//静态分派</span></span><br><span class="line">        print(father);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Father father)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is father"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Son son)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is son"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：this is father</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><h3 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h3><p>重写的实现。</p><p>在运行阶段才可以确定重写的函数是哪一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123; </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123; </span><br><span class="line">System.out.println(<span class="string">"man say hello!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123; </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123; </span><br><span class="line">System.out.println(<span class="string">"woman say hello!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Human man=<span class="keyword">new</span> Man();</span><br><span class="line">Human woman=<span class="keyword">new</span> Woman();</span><br><span class="line">man.sayHello();</span><br><span class="line">woman.sayHello();</span><br><span class="line">man=<span class="keyword">new</span> Woman();</span><br><span class="line">man.sayHello(); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从invokevirtual指令的多态查找过程开始说起，invokevirtual指令的运行时解析过程大致分为以下几个步骤：</p><p>1、找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。<br>2、如果在类型C中找到与常量中的描述符和简单名称相符合的方法，然后进行访问权限验证，如果验证通过则返回这个方法的直接引用，查找过程结束；如果验证不通过，则抛出java.lang.IllegalAccessError异常。<br>3、否则未找到，就按照继承关系从下往上依次对类型C的各个父类进行第2步的搜索和验证过程。<br>4、如果始终没有找到合适的方法，则跑出java.lang.AbstractMethodError异常。</p><p><strong>由于invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上</strong>，这个过程就是Java语言方法重写的本质。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;方法调用&quot;&gt;&lt;a href=&quot;#方法调用&quot; class=&quot;headerlink&quot; title=&quot;方法调用&quot;&gt;&lt;/a&gt;方法调用&lt;/h2&gt;&lt;p&gt;方法调用就是确定调用哪一个方法。&lt;/p&gt;
&lt;p&gt;在编译阶段，即将java文件转化为class文件，&lt;strong&gt;class文件中存储的是方法的符号引用(类似于一个代号吧)，而不是直接引用&lt;/strong&gt;(内存地址)，因为类还没有加载到内存嘛，所以具体的内存地址肯定是不知道的。&lt;/p&gt;
&lt;p&gt;因此，需要到类加载期间，甚至是运行期间才可能确定目标方法的直接引用。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
</feed>
