<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gallon&#39;s Note</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-09T13:02:34.945Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>SKJin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>volatile关键字</title>
    <link href="http://yoursite.com/2019/10/09/volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/10/09/volatile关键字/</id>
    <published>2019-10-09T12:18:33.000Z</published>
    <updated>2019-10-09T13:02:34.945Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>synchronized关键字</title>
    <link href="http://yoursite.com/2019/10/09/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/10/09/synchronized关键字/</id>
    <published>2019-10-09T07:40:32.000Z</published>
    <updated>2019-10-09T12:18:00.030Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="锁定的是对象"><a href="#锁定的是对象" class="headerlink" title="锁定的是对象"></a>锁定的是对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class T &#123;</span><br><span class="line">private Object o=new Object();</span><br><span class="line">private int count=10;</span><br><span class="line">public void m() &#123;</span><br><span class="line">synchronized(o) &#123;</span><br><span class="line">count--;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;count=&quot;+count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>1.当一个线程想要去执行这段代码，必须要获得o的锁，当o被其他线程占用时，该线程必须要等其他线程释放o的锁，再去获得o的锁，才能执行。</p><p>2.synchronized关键字锁定的是对象不是代码块,demo中锁的是object对象的实例</p><p>3.可能锁对象包括： this， 临界资源对象，Class 类对象。</p><p>4.关于线程安全：加synchronized关键字之后不一定能实现线程安全，具体还要看锁定的对象是否唯一。</p><p>5.synchronized关键字修饰普通方法等同于synchronized(this)</p><h3 id="静态方法上锁"><a href="#静态方法上锁" class="headerlink" title="静态方法上锁"></a>静态方法上锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 静态方法加锁相当于给T.class文件枷锁</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">count--;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">"count="</span>+count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;复制代码</span><br></pre></td></tr></table></figure><p>给静态方法上锁，<strong>锁定的是类对象</strong>，类的.class文件是唯一的，所以说synchronize修饰静态方法或者锁定的对象是类的.class文件的时候在多线程中是可以实现线程安全的.。</p><p>需要注意的是如果一个线程A调用一个实例对象的非static synchronized方法，而线程B需要调用这个实例对象所属类的静态 synchronized方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法<strong>占用的锁是当前类的class对象</strong>，而访问非静态 synchronized 方法<strong>占用的锁是当前实例对象锁</strong>。</p><h3 id="同步和非同步方法同时调用"><a href="#同步和非同步方法同时调用" class="headerlink" title="同步和非同步方法同时调用"></a>同步和非同步方法同时调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"m1 start------"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"m1 end--------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"m2-----"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">T t=<span class="keyword">new</span> T();</span><br><span class="line"><span class="comment">//相当于new 一个线程，在run方法里执行m1 lamda表达式</span></span><br><span class="line"><span class="comment">/*new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@Override</span></span><br><span class="line"><span class="comment">public void run() &#123;</span></span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;t.m1(),<span class="string">"t1"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;t.m2(),<span class="string">"t1"</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 线程t1首先获得了当前对象t的锁，并执行m1。因为m2非同步的，不需要获得锁就可以执行，所以t2不需要获得锁就可以直接执行m2.只有执行synchronized方法才需要申请那把锁。</p><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">" m1"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">m2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">" m2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Test1 t=<span class="keyword">new</span> Test1();</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">t.m1();</span><br><span class="line">&#125;,<span class="string">"t1"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">t.m1();</span><br><span class="line"></span><br><span class="line">&#125;,<span class="string">"t2"</span>).start();;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">t1 m1</span><br><span class="line">t1 m2</span><br><span class="line">t2 m1</span><br><span class="line">t2 m2</span><br></pre></td></tr></table></figure><p>所谓重入锁，指的是以线程为单位，<strong>当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，</strong>而其他的线程是不可以的，synchronized和ReentrantLock都是可重入锁。<strong>可重入锁的意义在于防止死锁</strong>。实现原理实现是通过为每个锁关联一个请求计数和一个占有它的线程。当计数为0时，认为锁是未被占有的。线程请求一个未被占有的锁时，jvm讲记录锁的占有者，并且讲请求计数器置为1 。如果同一个线程再次请求这个锁，计数将递增；每次占用线程退出同步块，计数器值将递减。直到计数器为0,锁被释放。可重入锁锁定的必须得是同一个对象(或者是父类子类对象)。</p><h3 id="读脏数据"><a href="#读脏数据" class="headerlink" title="读脏数据"></a>读脏数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Account &#123;</span><br><span class="line">String name;</span><br><span class="line">double balance=0;</span><br><span class="line">public synchronized void set(String name,Double balance) &#123;</span><br><span class="line">this.name=name;</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(2000);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">this.balance=balance;</span><br><span class="line">&#125;</span><br><span class="line">public double getBalance() &#123;</span><br><span class="line">return balance;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">Account a= new Account();</span><br><span class="line">new Thread(()-&gt;a.set(&quot;aaaa&quot;,100.0)).start();</span><br><span class="line">System.out.println(a.getBalance());</span><br><span class="line">try &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(3);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(a.getBalance());</span><br><span class="line">&#125;</span><br><span class="line">&#125;复制代码</span><br></pre></td></tr></table></figure><p>再给getBalance加锁就可以解决该问题了。</p><h3 id="不要以字符串常量作为锁的对象。"><a href="#不要以字符串常量作为锁的对象。" class="headerlink" title="不要以字符串常量作为锁的对象。"></a>不要以字符串常量作为锁的对象。</h3><p>因为锁定的是对象。比如说你用到了一个类库，里边锁定了一个”Hello”,而你在你的代码中也锁定了”Hello”,实际上这锁定的是是同一个对象，容易发生死锁。</p><h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_11</span> </span>&#123;</span><br><span class="line">AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line"><span class="comment">/*if(count.get() &lt; 1000)*/</span></span><br><span class="line">count.incrementAndGet();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> Test_11 t = <span class="keyword">new</span> Test_11();</span><br><span class="line">List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">threads.add(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">t.m();</span><br><span class="line">&#125;</span><br><span class="line">&#125;));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(Thread thread : threads)&#123;</span><br><span class="line">thread.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(Thread thread : threads)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">thread.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(t.count.intValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AtoXXX本身的方法是<strong>具有原子性的</strong>，但是他<strong>比synchronized效率要高。</strong></p><h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p>synchronized使用的锁对象是存储在Java对象头里的，jvm中采用2个字来存储对象头(如果对象是数组则会分配3个字，多出来的1个字记录的是数组长度)，其主要结构是由Mark Word 和 Class Metadata Address 组成 。Class Metadata Address存储的是该对象属于类的地址，即可以判断这个对象属于哪一个类。</p><p>MarkWord有五种类型：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/22/169a3f347a4218f7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>MarkWord：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/22/169a3f347a648d8d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>重量级锁(sychronized)：</p><p>锁标识位为10，<strong>其中指针指向的是monitor对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个 monitor 与之关联</strong>。只有获取到对象的monitor的线程，才可以执行方法或代码块，其他获取失败的线程会被阻塞，并放入同步队列中，进入BLOCKED状态。</p><h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p>当我们使用synchronized修饰方法名时，编译后会在方法名上生成一个ACC_SYNCHRONIZED标识来实现同步；当使用synchronized修饰代码块时，编译后会在代码块的前后生成monitorenter和monitorexit字节码来实现同步。</p><p>无论使用哪种方式实现，本质上都是<strong>对指定对象相关联的monitor的获取</strong>，只有获取到对象的monitor的线程，才可以执行方法或代码块，其他获取失败的线程会被阻塞，并放入同步队列中，进入BLOCKED状态。</p><p>为了解决线程安全的问题，Java提供了同步机制、互斥锁机制，这个机制保证了在同一问题内只有一个线程能访问共享资源。这个机制的保障来源于监视锁Monitor，每个对象都拥有自己的监视锁Monitor。</p><h3 id="Monitor的实现"><a href="#Monitor的实现" class="headerlink" title="Monitor的实现"></a>Monitor的实现</h3><p>数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = 0;</span><br><span class="line">    _waiters      = 0,</span><br><span class="line">    _recursions   = 0;</span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL;</span><br><span class="line">    _WaitSet      = NULL;</span><br><span class="line">    _WaitSetLock  = 0 ;</span><br><span class="line">    _Responsible  = NULL ;</span><br><span class="line">    _succ         = NULL ;</span><br><span class="line">    _cxq          = NULL ;</span><br><span class="line">    FreeNext      = NULL ;</span><br><span class="line">    _EntryList    = NULL ;</span><br><span class="line">    _SpinFreq     = 0 ;</span><br><span class="line">    _SpinClock    = 0 ;</span><br><span class="line">    OwnerIsThread = 0 ;</span><br><span class="line">  &#125;复制代码</span><br></pre></td></tr></table></figure><p>关键属性：</p><p>_owner：指向持有ObjectMonitor对象的线程</p><p>_WaitSet：存放处于wait状态的线程队列</p><p>_EntryList：存放处于等待锁block状态的线程队列</p><p>_recursions：锁的重入次数</p><p>_count：用来记录该线程获取锁的次数、</p><p>ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表( 每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSe t集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。</p><p>若执行线程调用 notify/notifyAll 方法，WaitSet 中的线程被唤醒，进入EntryList 中阻塞，等 待获取锁标记。若执行线程的同步代码执行结束，同样会释放锁标记，monitor 中的_Owner 标记赋值为 null，且计数器赋值为 0 计算。</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/22/169a439b8449109e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="等待唤醒机制与synchronized"><a href="#等待唤醒机制与synchronized" class="headerlink" title="等待唤醒机制与synchronized"></a>等待唤醒机制与synchronized</h3><p>所谓等待唤醒机制本篇主要指的是notify/notifyAll和wait方法，在使用这3个方法时，必须处于synchronized代码块或synchronized方法中，否则就会抛出IllegalMonitorStateException异常。</p><p>这是因为调用这几个方法前必须拿到当前对象的监视器monitor对象，也就是说notify/notifyAll和wait方法依赖于monitor对象，在前面的分析中，我们知道monitor 存在于对象头的Mark Word 中(存储monitor引用指针)，而synchronized关键字可以获取 monitor ，这也就是为什么notify/notifyAll和wait方法必须在synchronized代码块或者synchronized方法调用的原因。</p><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>锁的状态总共有四种：<strong>无锁状态、偏向锁、轻量级锁和重量级锁</strong>。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁。但是不可以降级。</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>sychronized就是重量级锁。</p><p>Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。JDK为了sychronized的优化，引入了轻量级锁和偏向锁。</p><p>一个依据：“<strong>对于绝大部分的锁，在整个同步周期内都是不存在竞争的</strong>。”</p><p>这是轻量级锁和偏向锁的依据。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>在大多数情况下，<strong>锁不仅不存在多线程竞争，而且总是由同一线程多次获得</strong>，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。</p><p>偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程<strong>再次请求锁时，无需再做任何同步操作，即获取锁的过程</strong>，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。</p><p>所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</p><p><strong>当有另外一个线程去尝试获取这个锁对象时</strong>，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态偏向锁可以提高有同步但竞争比较少的程序性能。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。</p><p>当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。</p><p>如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>重量级锁通过Monitor来实现，状态转换效率低。</p><p>轻量级锁基于CAS来实现。</p><p>偏向锁不需要同步，要是同一个线程申请锁。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/30/16315cb91da523d9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="åç§éçå¯¹æ¯"></p><h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><ul><li>synchronized是悲观锁，这种线程一旦得到锁，其他需要锁的线程就挂起的情况就是悲观锁。</li><li>CAS操作的就是乐观锁，每次不加锁而是<strong>假设没有冲突</strong>而去完成某项操作，如果因为冲突失败就重试，直到成功为止。</li></ul><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>Atomic底层的实现就是CAS。</p><p>CAS是一个原子操作。</p><p>CAS机制当中使用了3个基本操作数：内存地址V，旧的值A，要修改的新值B。</p><p>更新一个变量的时候，<strong>只有当变量旧的值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B</strong>。 </p><p>这样说或许有些抽象，我们来看一个例子：</p><p>1.在内存地址V当中，存储着值为10的变量。</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/22/169a49634442a552?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>2.此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A=10，要修改的新值B=11。</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/22/169a49634465e1e5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>3.在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11。</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/22/169a4963449100eb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>4.线程1开始提交更新，首先进行A和地址V的实际值比较（Compare），发现A不等于V的实际值，提交失败。</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/22/169a49634492ab80?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>5.线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为自旋。</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/22/169a496344a307ee?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>6.这一次比较幸运，没有其他线程改变地址V的值。线程1进行Compare，发现A和地址V的实际值是相等的。</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/22/169a496344beaf77?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>7.线程1进行SWAP，把地址V的值替换为B，也就是12。</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/22/169a49635b810441?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>当多个线程同时使用CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会挂起，仅是被告知失败，并且允许再次尝试，当然也允许实现的线程放弃操作。基于这样的原理，CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰。</p><p>Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。</p><p>CAS缺点：</p><ul><li><p>CPU开销较大<br>在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</p></li><li><p>ABA问题。</p><p>假设一个变量 A ，修改为 B之后又修改为 A，CAS 的机制是无法察觉的，但实际上已经被修改过了。如果在基本类型上是没有问题的，但是如果是引用类型呢？这个对象中有多个变量，我怎么知道有没有被改过？加个版本号啊。每次修改就检查版本号，如果版本号变了，说明改过，就算你还是 A，也不行。</p><p>AtomicReference就是这样做的。</p></li></ul><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除.</p><p>主要通过逃逸分析来判定。</p><p>何为逃逸？</p><p>当一个对象在方法中被定义后，如果被外部方法所引用，甚至可能会被外部线程所访问到，称为线程逃逸。</p><p>如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p><p>因为代码中会有许多隐形的锁，比如String。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p><p>例如在一个for循环里枷锁，就可以把锁提到外面。</p><h3 id="自旋锁（空转打圈儿）"><a href="#自旋锁（空转打圈儿）" class="headerlink" title="自旋锁（空转打圈儿）"></a>自旋锁（空转打圈儿）</h3><p>适用于共享数据只会锁定很短的一段时间。</p><p>当获取锁的过程中，未获取到。为了提高效率，JVM 自动执行若干次空循环（while循环中啥也不做），再次申请 锁，而不是进入阻塞状态的情况。称为自旋锁。自旋锁提高效率就是避免线程状态的变更。<strong>避免线程挂起导致的花费</strong>。</p><p>互斥同步对性能影响最大的是阻塞，即线程的挂起和恢复。许多应用中，<strong>共享数据的锁定状态只会持续很短的一段时间</strong>。如果有两个以上的处理器，能让两个或者以上的线程并行执行，我们就可以让后面请求锁的线程等待一下，但是并不放弃处理器的执行时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p><p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p><p>自适应的自旋锁：</p><p>自适应的自旋锁意味着自旋的时间不在固定了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得锁，并且持有者的线程正在运行中，那么虚拟机认为这次自旋也很有可能再次成功，因此会自旋等待较长的时间。相反的是，假如对于某个锁，自旋等待很少成功，那么以后获取这个锁的时候即有可能省略掉这个过程。</p><p><strong>一般自旋锁可以搭配CAS来使用。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h2&gt;&lt;h3 id=&quot;锁定的是对象&quot;&gt;&lt;a href=&quot;#锁定的是对象&quot; class=&quot;headerlink&quot; title=&quot;锁定的是对象&quot;&gt;&lt;/a&gt;锁定的是对象&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class T &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	private Object o=new Object();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	private int count=10;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public void m() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		synchronized(o) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			count--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			System.out.println(Thread.currentThread().getName()+&amp;quot;count=&amp;quot;+count);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>操作系统同步互斥</title>
    <link href="http://yoursite.com/2019/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/"/>
    <id>http://yoursite.com/2019/10/08/操作系统同步互斥/</id>
    <published>2019-10-08T12:21:50.000Z</published>
    <updated>2019-10-09T06:35:36.533Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TSL指令"><a href="#TSL指令" class="headerlink" title="TSL指令"></a>TSL指令</h2><p>类似于java的CAS。</p><p>Test and set lock.<strong>这是一个原子操作，他的读写操作是不分开的</strong>。</p><a id="more"></a><p>TSL指令实现锁机制：当lock为0时，任何进程都可以使用TSL指令将其设置为1，然后访问临界区，操作结束时，再将lock重新设置为0.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void acquire(int *lock)&#123;</span><br><span class="line">    while(TestAndSet(*lock));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void release(int *lock)&#123;</span><br><span class="line">    *lock = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在acquire函数中，如果TestAndSet返回1，那么while循环就一直执行（也就是在这里等待），直到另一个线程调用release。当然，这个实现看起来不太好，主要是<strong>等待的线程会不停的检查，浪费CPU，这个问题称之为忙等待</strong>（busy-wait or spin-wait），所以这个lock的实现也叫自旋锁spinlock。解决办法是如果需要等待，那么该线程主动交出执行权，让其他线程有机会执行，这种方式称之为让权等待（yield-wait or sleep-wait），应用开发人员使用的互斥锁一都是指这种情况。</p><p>以上的这些机制都是忙等待。<br>当一个进程想进入临界区，先检查是否允许进入，若不允许，将会原地等待，直到允许为止。<br>浪费CPU。</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>可以同时多个线程访问临界区，有P,V两个原子操作。</p><p>P(): 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</p><p>V(); 对信号量执行 +1 操作，唤醒睡眠的进程让其完成 P操作。</p><p>要是信号量的取值变为了1，那么就变成了互斥量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mutex=<span class="keyword">new</span> Semaphore(<span class="number">1</span>)</span><br><span class="line">mutex.P();</span><br><span class="line">临界区</span><br><span class="line">mutex.V();</span><br></pre></td></tr></table></figure><p>信号量主要可以解决两类问题。</p><ul><li><strong>互斥问题</strong>。同一时刻只可以有一个线程访问某一个临界资源。</li><li><strong>同步问题</strong>。线程A需要等待线程B执行完毕后才可以继续执行。</li></ul><h3 id="信号量解决生产者消费者问题"><a href="#信号量解决生产者消费者问题" class="headerlink" title="信号量解决生产者消费者问题"></a>信号量解决生产者消费者问题</h3><ul><li>同一时刻，只能有一个生产者或者是消费者访问缓冲区。(互斥问题)</li><li>缓冲区满时，生产者需要等待消费者消费。(同步问题)</li><li>缓冲区空时，消费者需要等待生产者生产。(同步问题)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥量</span></span><br><span class="line">mutex = <span class="keyword">new</span> Semophore(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//代表缓冲区有多少产品</span></span><br><span class="line">products = <span class="keyword">new</span> Semophore(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//代表缓冲区里有多大位置</span></span><br><span class="line">remainPosition = <span class="keyword">new</span> Semophore(n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line">remainPosition-&gt;P();</span><br><span class="line">mutex-&gt;P();</span><br><span class="line">Add();</span><br><span class="line">mutex-&gt;V();</span><br><span class="line">products-&gt;V();</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者，先去申请产品，在空出一个位置</span></span><br><span class="line">products-&gt;P();</span><br><span class="line">mutex-&gt;P();</span><br><span class="line">Remove();</span><br><span class="line">mutex-&gt;V();</span><br><span class="line">remainPosition-V();</span><br></pre></td></tr></table></figure><p>注意，empty-&gt;P()和mutex-&gt;P()不可以交换顺序。</p><p>要是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mutex-&gt;P()</span><br><span class="line">empty-P();</span><br></pre></td></tr></table></figure><p><strong>假设我们现在的empty已经是0了，mutex先执行也变为了0，但是当执行到下一步empty-P()，发现自己需要阻塞，但是mutex还未释放，会造成死锁。</strong><br>两个V()操作可以交换顺序。</p><h2 id="管程-Monitor"><a href="#管程-Monitor" class="headerlink" title="管程(Monitor)"></a>管程(Monitor)</h2><p><strong>管程=互斥量+条件变量</strong>。<br><strong>互斥量：可以保证共享资源在同一时间只能有一个进程访问</strong>。<br><strong>条件变量：正在管程内的线程可以放弃对管程的控制权，等待某些条件发生再继续执行</strong>。<br>每个条件变量实际上代表的是一个等待队列。<br>当wait时，进程释放锁，挂起，并插入该条件变量的等待队列。<br>signal时，唤醒条件变量等待队列中的进程。</p><p>任意时刻管程中只能有一个活跃进程。<br>条件变量：解决死锁问题，挂起进程。<br>条件变量。wait：释放锁，挂起 notify：<strong>唤醒等待队列中一个线程</strong>。防止死锁。</p><h3 id="管程解决生产者消费者问题"><a href="#管程解决生产者消费者问题" class="headerlink" title="管程解决生产者消费者问题"></a>管程解决生产者消费者问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">mutex buffer;<span class="comment">//互斥量，一次只能由一个进程访问</span></span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">Condition full,empty;<span class="comment">//条件变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Produce</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//获取互斥量</span></span><br><span class="line">   mutex.acquire();</span><br><span class="line">   <span class="comment">//容器满了，线程挂起</span></span><br><span class="line">   <span class="keyword">while</span>(count==n)&#123;</span><br><span class="line">      wait(full);</span><br><span class="line">   &#125;</span><br><span class="line">   Add c;</span><br><span class="line">   count++;</span><br><span class="line">   <span class="comment">//唤醒因没有产品挂起的线程</span></span><br><span class="line">   notify(empty);</span><br><span class="line">   mutex.release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Produce</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//获取互斥量</span></span><br><span class="line">   mutex.acquire();</span><br><span class="line">   <span class="comment">//容器满了，线程挂起</span></span><br><span class="line">   <span class="keyword">while</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">      wait(empty);</span><br><span class="line">   &#125;</span><br><span class="line">   Remove c;</span><br><span class="line">   count--;</span><br><span class="line"><span class="comment">//唤醒因容器满了挂起的线程</span></span><br><span class="line">   notify(full); </span><br><span class="line">   mutex.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TSL指令&quot;&gt;&lt;a href=&quot;#TSL指令&quot; class=&quot;headerlink&quot; title=&quot;TSL指令&quot;&gt;&lt;/a&gt;TSL指令&lt;/h2&gt;&lt;p&gt;类似于java的CAS。&lt;/p&gt;
&lt;p&gt;Test and set lock.&lt;strong&gt;这是一个原子操作，他的读写操作是不分开的&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统进程</title>
    <link href="http://yoursite.com/2019/10/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/10/07/操作系统进程/</id>
    <published>2019-10-07T13:54:57.000Z</published>
    <updated>2019-10-09T05:51:55.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是<strong>资源分配的基本单位</strong>，他是程序运行时的一个实例。<br>程序运行时，系统会创建一个进程，并分配相关的资源。</p><p><strong>程序是静态的，进程是动态的</strong>。一个程序可以对应多个进程，一个进程可以包括多个程序。</p><p>进程=程序+数据+状态信息。</p><a id="more"></a><h3 id="PCB-进程控制块"><a href="#PCB-进程控制块" class="headerlink" title="PCB(进程控制块)"></a>PCB(进程控制块)</h3><p>每个进程都有一个进程控制块，他是<strong>进程的唯一标识</strong>。<br>进程块描述进程的基本信息和运行状态。所谓的进程的创建与销毁，就是对PCB的创建与销毁。</p><p>各个进程块在内存中<strong>应该是以链表的形式存储</strong>的，因为进程块需要频繁的进行插入与删除。</p><h3 id="进程的生命周期"><a href="#进程的生命周期" class="headerlink" title="进程的生命周期"></a>进程的生命周期</h3><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/06/09/1560068275561-1560068275567.png" alt="title"><br><strong>最主要的就是就绪，运行，阻塞三个状态。</strong><br>操作系统创建一个进程完成后，并为其分配了除了cpu之外的所有的资源，那么进程进入<strong>就绪(ready)状态</strong>，当CPU处于空闲的时候，就绪状态的进程占用CPU，进入<strong>运行（running）状态</strong>。正在执行的进程，由于等待某个事件发生而无法执行时，便放弃CPU而处于<strong>阻塞（waiting）状态</strong>。</p><ul><li><p>ready-&gt;running<br>当没有其他进程占用CPU，所有的ready进程就可以去竞争CPU，获得CPU的进程进入running状态。</p></li><li><p>running-&gt;waiting<br>正在执行的进程，因为等待某个事件发生而放弃CPU时，进入waiting状态。比如I/O阻塞，申请缓冲区不能满足、等待信件等。</p></li><li><p>running-&gt;ready<br>处于执行状态的进程在其执行过程中，因分配给它的一个时间片已用完或更高优先级的进程抢占而不得不让出处理机，于是进程从执行状态转变成就绪状态。</p></li><li><p>waiting-&gt;ready<br>当等待事件完成的时候，从阻塞进入就绪态。<br>需要正在运行的进程对他唤醒。</p></li></ul><h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>因为所有的进程都有自己独立的地址空间。</p><ul><li><p>页表以及地址空间的切换。</p></li><li><p>寄存器，程序计数器，堆栈的切换。</p></li></ul><p>进程上下文切换过程：</p><ul><li><p>保存现场。暂停当前进程，从运行态变为其他状态，保存当前进程的上下文，包括CPU寄存器状态，程序计数器状态等。保存在PCB中。</p></li><li><p>选取进程。调度另一个进程从就绪转为运行。</p></li><li><p>恢复现场。从内存中恢复下一个要执行的进程的上下文，恢复该进程原来的状态到寄存器，恢复程序执行上一次暂停的地方。从PCB中取。</p><p>在进程切换的过程中，页表会改变，地址空间会改变，高速缓存中的存储的数据过期，也需要进行切换。</p></li></ul><h3 id="进程挂起"><a href="#进程挂起" class="headerlink" title="进程挂起"></a>进程挂起</h3><p>将<strong>进程从内存转移到磁盘上</strong>。<br>进程挂起状态包括<strong>阻塞挂起</strong>（在外存，处于阻塞）和就绪挂起（在外存，就绪状态）。</p><p>进程挂起状态转换：</p><ul><li>阻塞到阻塞挂起。内存不够时，将阻塞状态的进程移到外存，变为阻塞挂起状态。</li><li>就绪到就绪挂起。有高优先级阻塞和低优先级就绪，那么将低优先级挂起。</li><li>运行到就绪挂起。</li></ul><p>挂起是将进程从内存转移到磁盘，而阻塞是由于资源得不到满足暂时无法获取CPU，还是在内存的。</p><h3 id="状态队列"><a href="#状态队列" class="headerlink" title="状态队列"></a>状态队列</h3><p><strong>操作系统中维护了多个队列，不同的队列来表示不同的状态。</strong><br>就绪队列，阻塞队列，运行队列等。<br>方便操作系统管理进程。<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/06/09/1560078704085-1560078704092.png" alt="title"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>当我们并发的需求时，如果采用多进程的话，因为进程每个进程都有自己的独立空间，进程间通信麻烦，还有进程切换的时候需要进行保护现场恢复现场，十分耗费资源，效率低下。<br>于是，引入了线程。</p><p>线程是轻量级的进程。所有的线程共享进程的地址空间，进程间开销小，通信方便。<br>进程中的所有线程共享代码，文件等资源。<br>但是，<strong>他们都有自己的堆栈，寄存器等</strong>。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/06/09/1560080472816-1560080472823.png" alt="title"></p><p>进程是资源分配的角色，线程是执行功能的角色。<br>一个线程崩溃，整个进程崩溃。因此，在对于安全性过高的场合，我们一般使用进程来解决并发问题。比如说，我们的浏览器，每开一个界面，就创建一个进程。</p><h3 id="OS中两种线程"><a href="#OS中两种线程" class="headerlink" title="OS中两种线程"></a>OS中两种线程</h3><p><strong>根据操作系统能够感知到线程，分为用户线程以及内核线程。</strong></p><h4 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h4><p>内核完成线程的创建以及管理。<br>内核分配CPU是以线程为单位的。</p><p>优点：</p><ul><li>一个线程阻塞不会导致整个进程阻塞。</li><li>内核会为每一个线程分配CPU，对于多线程的进程，时间片时间大大增加。</li></ul><p>缺点：</p><ul><li>线程切换要从用户态转移到内核态，耗费大，速度慢。</li></ul><h4 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h4><p>用户级的线程库完成线程的创建以及管理。<br><strong>内核资源的分配仍然是按照进程（用户进程）进行分配的。</strong><br>不依赖于操作系统的内核，<strong>操作系统感受不到用户线程的存在</strong>。</p><p>缺点：</p><ul><li>因此，对于操作系统来说，这个用户线程所属的进程是没有线程的，因此，<strong>一个线程的阻塞将导致整个进程的阻塞</strong>，因为，对于操作系统来说，他看到的只是这个进程，这个用户线程阻塞，对操作系统来说就是整个进程阻塞，所以这个进程将会阻塞。</li><li>因为没有操作系统的管制，一个用户线程拿到了分配给这个进程的时间片，他会一直霸占着，除非她主动放弃，或者到这个时间片结束，可能会导致别的用户线程没有机会执行。</li></ul><p>优点：</p><ul><li>但是，用户线程切换不需要从用户态转到内核态，消耗小，速度快。</li></ul><p>总的来说，对于用户线程，操作系统是感受不到，<strong>还是会把它看作一个进程来进行处理</strong>。</p><p><a href="https://www.cnblogs.com/Lee-johnH/p/6663618.html" target="_blank" rel="noopener">内核线程与用户线程</a></p><h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><p>将用户线程与内核线程绑定。主要有一对一，多对一，以及多对多。操作系统中主要使用多对多。</p><h4 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a>多对一</h4><p>多个用户线程与一个内核线程绑定。</p><p>缺点是一个线程阻塞，这多个用户线程都会被阻塞。</p><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>一个用户线程绑定一个内核线程。</p><p>缺点是每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大，会影响到应用程序的性能。</p><h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>将 n 个用户级线程映射到 m 个内核级线程上，要求 m &lt;= n。</p><p>不会出现一个用户线程阻塞，所有线程都阻塞的情况。</p><p>详解<a href="https://www.cnblogs.com/stemon/p/4855583.html" target="_blank" rel="noopener">多线程模型</a></p><h2 id="与进程区别"><a href="#与进程区别" class="headerlink" title="与进程区别"></a>与进程区别</h2><ul><li>进程是资源分配的最小单位，线程是程序执行的最小单位。</li><li>进程有自己的独立空间，每创建一个进程，都要为他分配独立的地址空间，花费很大。而线程是共享进程地址空间的，花费要小很多。</li><li>进程之间的通信需要以通信的方式（IPC)进行，需要通过内核来通信。而线程可以通过共享变量等方式进行。</li><li>进程之间切换时间比线程之间切换时间要大得多。因为进程之间页表是不同的，需要切换页表，开销比较大。因为各个进程页表不同，TLB，缓存信息可能都需要重新加载。而线程是共享的。</li><li>一个进程死掉，对其他进程没有影响；一个线程死掉，整个进程就会崩溃。<br><strong>当一个线程向非法地址读取或者写入，无法确认这个操作是否会影响同一进程中的其它线程，所以只能是整个进程一起崩溃。</strong></li></ul><h2 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h2><p>与进程上下文切换不同的是，线程上下文切换没有页表以及地址空间的切换，因为同一个进程的线程共享同一个地址空间。只需要进行程序计数器，寄存器，以及线程的堆栈的切换。</p><h2 id="fork-and-exec"><a href="#fork-and-exec" class="headerlink" title="fork and exec"></a>fork and exec</h2><p>linux的fork 和exec 函数。</p><p>fork() 复制出一个子进程，<strong>这个进程几乎是当前进程的一个拷贝</strong>：子进程和父进程使用相同的代码段；子进程复制父进程的堆栈段和数据段。这样，父进程的所有数据都可以留给子进程，但是，子进程一旦开始运行，<strong>虽然它继承了父进程的一切数据，但实际上数据却已经分开，相互之间不再有影响了</strong>，也就是说，它们之间不再共享任何数据了。它们再要交互信息时，只有通过进程间通信来实现，这将是我们下面的内容。既然它们如此相象，系统如何来区分它们呢？这<strong>由函数的返回值来决定的</strong>。对于父进程， fork函数返回了子程序的进程号，而对于子程序，fork函数则返回零。在操作系统中，我们用ps函数就可以看到不同的进程号，对父进程而言，它的进程号是由比它更低 层的系统调用赋予的，而对于子进程而言，它的进程号即是fork函数对父进程的返回值。在程序设计中，父进程和子进程都要调用函数fork（）下面的代码，而我们就是利用fork（）函数对父子进程的不同返回值用if…else…语句来实现让父子进程完成不同的功能。</p><p>exec将替换现有进程，执行exec的程序。</p><p>一个进程一旦调用exec类函数，它本身就”死亡”了，<strong>系统把代码段替换成新的程序的代码，废弃原有的数据段和堆栈段</strong>，并为新程序分配新的数据段与堆栈段，唯一留下的，就是进程号，也就是说，对系统而言，还是同一个进程，不过已经是另一个程序了。</p><h2 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="headerlink" title="僵尸进程和孤儿进程"></a>僵尸进程和孤儿进程</h2><p>正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。</p><p>一个子进exit()之后，内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。直到父进程通过wait / waitpid来取时才释放。这样，一个进程才算是完全终止掉。</p><p>当一个父进程迟迟没有调用wait()，这个子进程内存中保存的信息就迟迟不会释放，包括进程号也不会释放，操作系统的进程号是有限的，因此僵尸进程的危害很大。</p><p>当一个父进程退出，子进程还在运行，那么子进程将会称为孤儿进程。孤儿进程会被init进程处理，使用wait()完成进程的终止等，因此，孤儿进程是没有坏处的。</p><p><strong>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</strong></p><p><strong>僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h2&gt;&lt;p&gt;进程是&lt;strong&gt;资源分配的基本单位&lt;/strong&gt;，他是程序运行时的一个实例。&lt;br&gt;程序运行时，系统会创建一个进程，并分配相关的资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序是静态的，进程是动态的&lt;/strong&gt;。一个程序可以对应多个进程，一个进程可以包括多个程序。&lt;/p&gt;
&lt;p&gt;进程=程序+数据+状态信息。&lt;/p&gt;
    
    </summary>
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统概述</title>
    <link href="http://yoursite.com/2019/10/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2019/10/07/操作系统概述/</id>
    <published>2019-10-07T12:47:33.000Z</published>
    <updated>2019-10-07T13:54:24.444Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><p>操作系统主要进行应用程序管理，资源管理，外设管理等工作。</p><p><strong>在操作系统中，将CPU抽象为进程，将内存抽象为地址空间，将磁盘抽象为文件。</strong><br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/30/1559223725482-1559223725514.png" alt="title"></p><p>OS=shell+kernel.shell就是GUI或者是命令行。Kernel是操作系统的核心。<br>kernel主要完成的工作包括<strong>CPU调度，物理内存虚拟内存的管理，文件系统的管理，中断处理，外设管理等</strong>。</p><p>kernel的特征：</p><ul><li><strong>并发</strong>（应用并发执行）。</li><li><strong>共享</strong>。某一个公共资源是可以共享访问的还是互斥访问的。</li><li><strong>虚拟化</strong>。将物理实体虚拟化为逻辑实体。主要包括时分复用(时间片)和空分复用(虚拟内存)。</li><li><strong>异步</strong>。</li></ul><h2 id="OS启动过程"><a href="#OS启动过程" class="headerlink" title="OS启动过程"></a>OS启动过程</h2><p>Disk：存储bootloader以及OS.<br>BIOS:基本IO处理系统。</p><p>最先放入内存的是BIOS启动固件。BIOS的第一步是检测外设，完成后，将bootloader加载进内存，并且CPU控制权转交给bootloader，bootloader再将磁盘上的OS加载进内存，这是OS掌控CPU。</p><p>BIOS—&gt;加载bootloader—&gt;加载OS。（所以说我们安装系统的时候要先进入BIOS设置启动项，这个启动项就是bootloader）。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/30/1559224752551-1559224752559.png" alt="title"></p><h2 id="系统调用，中断，异常"><a href="#系统调用，中断，异常" class="headerlink" title="系统调用，中断，异常"></a>系统调用，中断，异常</h2><p>都需要从用户态转移到内核态。</p><h3 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h3><p>来源于外设。</p><p>为了<strong>支持CPU 和设备之间 的 并行操作</strong>。当IO事件完成之后，设备中断通知CPU，CPU在进行相应事件的处理。可以看作是一种异步操作啊。</p><p>当CPU 启动设备进行输入/输出后 ，设备便可以独立工作，CPU 转去处理与此次输入/输出不相关的 事情；当设备完成输入/输出后，通过向CPU 发中断报告此次 输入/输出的结果，让CPU 决定如何处理以后的事情。</p><h4 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h4><ul><li>设备（硬件）将中断事件的ID传递给中断寄存器。不<strong>同的中断ID范围代表不同的中断类型</strong>。</li><li>CPU在执行完一条指令后，会查看中断寄存器，假如有中断的话，进行中断处理。</li><li>CPU保存现场。保存各种寄存器等。</li><li>CPU 根据中断码查中断向量表，获得与该中断相关的处理程序的入口地址。</li><li>进行相应中断处理。</li><li>恢复之前保存的处理状态。</li></ul><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>来源于应用程序。CPU执行指令非法。</p><p>异常过程与中断过程差不多，也是保存现场，处理，恢复现场这几个过程。</p><p>但是不同的是，异常一般是交给进程自己来处理，而中断是由内核的中断函数来处理，根据不同的中断类型执行不同的中断函数。</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>当应用程序需要调用系统级别的函数请求。</p><h4 id="系统调用过程"><a href="#系统调用过程" class="headerlink" title="系统调用过程"></a>系统调用过程</h4><ul><li>每一个系统调用对应一个系统调用号。</li><li>根据系统调用号选取相应的系统调用例程进行系统调用。</li><li>返回系统调用结果。</li></ul><p>系统调用需要从用户态切换到内核态。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>系统调用，中断，异常机制其实都是大同小异。在操作系统中都维持着一个表，中断是中断号和中断函数对应，系统调用是系统调用号和系统调用函数，根据ID去调用相应的函数，返回结果。</p><p>而且OS都需要从用户态转到内核态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是操作系统&quot;&gt;&lt;a href=&quot;#什么是操作系统&quot; class=&quot;headerlink&quot; title=&quot;什么是操作系统&quot;&gt;&lt;/a&gt;什么是操作系统&lt;/h2&gt;&lt;p&gt;操作系统主要进行应用程序管理，资源管理，外设管理等工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在操作系统中
      
    
    </summary>
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>IO线程模型</title>
    <link href="http://yoursite.com/2019/09/30/IO%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/09/30/IO线程模型/</id>
    <published>2019-09-30T11:31:56.000Z</published>
    <updated>2019-09-30T11:53:50.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阻塞I-O"><a href="#阻塞I-O" class="headerlink" title="阻塞I/O"></a>阻塞I/O</h1><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/07/1557216950760-1557216950760.png" alt="title"></p><ul><li>每一条连接都需要建立一个独立的线程来处理，机器耗费线程资源。</li><li>当没有数据读写时，线程还会阻塞。<h1 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h1></li></ul><p><strong>IO多路复用+线程池来实现</strong>。<br>I/O多路复用来解决会有多个线程阻塞的问题，IO多路复用只会造成一个线程阻塞。<br>线程池不必为每个连接都建立一个新的线程。</p><p>Reactor模型，是指通过一个或多个输入同时传递给服务处理器的服务请求的事件驱动处理模式。 服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor模式也叫Dispatcher模式，即<strong>I/O多路复用统一监听事件，收到事件后分发</strong>(Dispatch给某进程)。</p><p>Reactor两个关键组成：</p><ul><li>Reactor<br>负责监听和分发事件，分发给适当的处理程序来对IO事件做出反应。</li><li>Handler<br>处理程序执行I/O事件要完成的实际事件.<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/07/1557217752478-1557217752483.png" alt="title"><h2 id="单Reactor"><a href="#单Reactor" class="headerlink" title="单Reactor"></a>单Reactor</h2><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/07/1557217879896-1557217879896.png" alt="title"></li><li>Reactor对象通过select不断轮询监控客户端请求事件，收到事件后通过dispatch进行分发</li><li>如果是建立连接请求事件，则由Acceptor通过accept处理连接请求，然后创建一个Handler对象处理连接完成后的后续业务处理</li><li>如果不是建立连接事件，则Reactor会分发调用连接对应的Handler来响应</li><li>Handler会完成read-&gt;业务处理-&gt;send的完整业务流程<h2 id="单Reactor多线程"><a href="#单Reactor多线程" class="headerlink" title="单Reactor多线程"></a>单Reactor多线程</h2>主要通过建立一个线程池。<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/07/1557218020262-1557218020277.png" alt="title"><br>Worker线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给Handler进行处理。</li></ul><h2 id="主从Reactor多线程"><a href="#主从Reactor多线程" class="headerlink" title="主从Reactor多线程"></a>主从Reactor多线程</h2><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/07/1557218140668-1557218140683.png" alt="title"></p><ul><li>Reactor主线程MainReactor对象通过select监控建立连接事件，收到事件后通过Acceptor接收，处理建立连接事件。</li><li>Accepto处理建立连接事件后，MainReactor将Socket分配Reactor子线程给<strong>SubReactor进行处理</strong>。</li><li>SubReactor将Socket加入连接队列进行监听，并创建一个Handler用于处理各种连接事件，例如读写操作。</li><li>当有新的事件发生时，SubReactor会调用连接对应的Handler进行响应</li><li>Handler通过read读取数据后，会分发给后面的Worker线程池进行业务处理</li><li>Worker线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给Handler进行处理</li><li>Handler收到响应结果后通过send将响应结果返回给client<h2 id="NIO代码"><a href="#NIO代码" class="headerlink" title="NIO代码"></a>NIO代码</h2></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> nioDemo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.CharBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*服务器端，:接收客户端发送过来的数据并显示，</span></span><br><span class="line"><span class="comment"> *服务器把上接收到的数据加上"echo from service:"再发送回去*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceSocketChannelDemo</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPEchoServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="comment">/*服务器地址*/</span></span><br><span class="line">        <span class="keyword">private</span> InetSocketAddress localAddress; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TCPEchoServer</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.localAddress = <span class="keyword">new</span> InetSocketAddress(port);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            ServerSocketChannel ssc = <span class="keyword">null</span>;</span><br><span class="line">            Selector selector = <span class="keyword">null</span>;           </span><br><span class="line">            Random rnd = <span class="keyword">new</span> Random();   </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/*创建选择器*/</span></span><br><span class="line">                selector = Selector.open();</span><br><span class="line">                <span class="comment">/*创建服务器通道*/</span></span><br><span class="line">                ssc = ServerSocketChannel.open();</span><br><span class="line">                ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">/*设置监听服务器的端口，设置最大连接缓冲数为100*/</span></span><br><span class="line">                ssc.bind(localAddress, <span class="number">100</span>);</span><br><span class="line">                <span class="comment">/*服务器通道只能对tcp链接事件感兴趣*/</span></span><br><span class="line">                ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                System.out.println(<span class="string">"server start failed"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            System.out.println(<span class="string">"server start with address : "</span> + localAddress);  </span><br><span class="line">            <span class="comment">/*服务器线程被中断后会退出*/</span></span><br><span class="line">            <span class="keyword">try</span>&#123;   </span><br><span class="line">                <span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;      </span><br><span class="line">                    <span class="keyword">int</span> n = selector.select();</span><br><span class="line">                    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Set&lt;SelectionKey&gt; keySet = selector.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; it = keySet.iterator();</span><br><span class="line">                    SelectionKey key = <span class="keyword">null</span>; </span><br><span class="line">                    <span class="keyword">while</span>(it.hasNext())&#123;               </span><br><span class="line">                        key = it.next();</span><br><span class="line">                        <span class="comment">/*防止下次select方法返回已处理过的通道*/</span></span><br><span class="line">                        it.remove();           </span><br><span class="line">                        <span class="comment">/*若发现异常，说明客户端连接出现问题,但服务器要保持正常*/</span></span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            <span class="comment">/*ssc通道只能对链接事件感兴趣*/</span></span><br><span class="line">                            <span class="keyword">if</span>(key.isAcceptable())&#123;  </span><br><span class="line">                                <span class="comment">/*accept方法会返回一个普通通道，</span></span><br><span class="line"><span class="comment">                                     每个通道在内核中都对应一个socket缓冲区*/</span></span><br><span class="line">                                SocketChannel sc = ssc.accept();</span><br><span class="line">                                sc.configureBlocking(<span class="keyword">false</span>);      </span><br><span class="line">                     <span class="comment">/*向选择器注册这个通道和普通通道感兴趣的事件，同时提供这个新通道相关的缓冲区*/</span></span><br><span class="line">                                <span class="keyword">int</span> interestSet = SelectionKey.OP_READ;                   </span><br><span class="line">                                sc.register(selector, interestSet, <span class="keyword">new</span> Buffers(<span class="number">256</span>,<span class="number">256</span>));</span><br><span class="line">                                System.out.println(<span class="string">"accept from"</span>+ sc.getRemoteAddress());</span><br><span class="line">                            &#125;    </span><br><span class="line">                            <span class="comment">/*（普通）通道感兴趣读事件且有数据可读*/</span></span><br><span class="line">                            <span class="keyword">if</span>(key.isReadable())&#123;           </span><br><span class="line">                                <span class="comment">/*通过SelectionKey获取通道对应的缓冲区*/</span></span><br><span class="line">                                Buffers  buffers = (Buffers)key.attachment();</span><br><span class="line">                                ByteBuffer readBuffer = buffers.getReadBuffer();</span><br><span class="line">                                ByteBuffer writeBuffer = buffers.gerWriteBuffer();</span><br><span class="line">                                 </span><br><span class="line">                                <span class="comment">/*通过SelectionKey获取对应的通道*/</span></span><br><span class="line">                                SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                                 </span><br><span class="line">                                <span class="comment">/*从底层socket读缓冲区中读入数据*/</span></span><br><span class="line">                                sc.read(readBuffer);</span><br><span class="line">                                readBuffer.flip();</span><br><span class="line">                                 </span><br><span class="line">                                <span class="comment">/*解码显示，客户端发送来的信息*/</span></span><br><span class="line">                                CharBuffer cb = utf8.decode(readBuffer);</span><br><span class="line">                                System.out.println(cb.array());                 </span><br><span class="line">                                readBuffer.rewind(); </span><br><span class="line">                                <span class="comment">/*准备好向客户端发送的信息*/</span></span><br><span class="line">                                <span class="comment">/*先写入"echo:"，再写入收到的信息*/</span></span><br><span class="line">                                writeBuffer.put(<span class="string">"echo from service:"</span>.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">                                writeBuffer.put(readBuffer);</span><br><span class="line">                                readBuffer.clear();  </span><br><span class="line">                                <span class="comment">/*设置通道写事件*/</span></span><br><span class="line">                                key.interestOps(key.interestOps() | SelectionKey.OP_WRITE);</span><br><span class="line">                                                                 </span><br><span class="line">                            &#125;</span><br><span class="line">                             </span><br><span class="line">                            <span class="comment">/*通道感兴趣写事件且底层缓冲区有空闲*/</span></span><br><span class="line">                            <span class="keyword">if</span>(key.isWritable())&#123; </span><br><span class="line">                                doSomething();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                            System.out.println(<span class="string">"service encounter client error"</span>);</span><br><span class="line">                            <span class="comment">/*若客户端连接出现异常，从Seletcor中移除这个key*/</span></span><br><span class="line">                            key.cancel();</span><br><span class="line">                            key.channel().close();</span><br><span class="line">                        &#125;</span><br><span class="line"> </span><br><span class="line">                    &#125;   </span><br><span class="line">                    Thread.sleep(rnd.nextInt(<span class="number">500</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                 </span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                System.out.println(<span class="string">"serverThread is interrupted"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                System.out.println(<span class="string">"serverThread selecotr error"</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    selector.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"selector close failed"</span>);</span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"server close"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException</span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> TCPEchoServer(<span class="number">8080</span>));</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">        <span class="comment">/*结束服务器线程*/</span></span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Proactor模型（异步）"><a href="#Proactor模型（异步）" class="headerlink" title="Proactor模型（异步）"></a>Proactor模型（异步）</h1><p>主要的核心在于回调机制。<br>Reactor在接收事件后需要交给Reactor处理。而Proactor直接由操作系统来处理相关事件，然后返回结果。<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/07/1557218800106-1557218800122.png" alt="title"></p><p><a href="https://juejin.im/post/5b908419e51d450e704230f0#heading-11" target="_blank" rel="noopener">理解高性能网络模型</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;阻塞I-O&quot;&gt;&lt;a href=&quot;#阻塞I-O&quot; class=&quot;headerlink&quot; title=&quot;阻塞I/O&quot;&gt;&lt;/a&gt;阻塞I/O&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/gallonskj/gitn
      
    
    </summary>
    
      <category term="IO" scheme="http://yoursite.com/categories/IO/"/>
    
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>I/O模型</title>
    <link href="http://yoursite.com/2019/09/29/IO%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/09/29/IO模型/</id>
    <published>2019-09-29T07:12:09.000Z</published>
    <updated>2019-10-07T10:43:52.608Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Socket与ServerSocket"><a href="#Socket与ServerSocket" class="headerlink" title="Socket与ServerSocket"></a>Socket与ServerSocket</h2><p>网络通信需要一对socket，即通信的两端各有一个socket，两个socket之间形成一个管道，进行数据流的通信。<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/05/1557035867781-1557035868213.png" alt="title"><br>ServerSocket<br>ServerSocket监听服务器端的一个端口，当一个客户端发送来连接时，ServerSocket来处理连接，成功后返回一个常规的Socket对象，用来与客户端socket进行数据传输。</p><h1 id="同步-异步-阻塞-非阻塞"><a href="#同步-异步-阻塞-非阻塞" class="headerlink" title="同步 异步 阻塞 非阻塞"></a>同步 异步 阻塞 非阻塞</h1><p><strong>同步与异步主要是从消息通知机制角度来说的。</strong><br>当一个同步调用发出后，调用者要一直等待返回消息（结果）后，才能进行后续的执行；当一个异步过程调用发出后，调用者不能立刻得到返回消息（结果），实际处理这个调用的部件在完成后，通过<strong>状态、通知和回调</strong>来通知调用者。异步是调用完成后由别人来通知他。</p><p>阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的。<br>阻塞调用是指调用结果返回之前，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务。<br>非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。如果在这个等待的过程中，等待者除了等待消息通知之外不能做其它的事情，那么该机制就是阻塞的。</p><p>阻塞与同步是不同的。如果这个线程在等待函数返回时，仍在执行其他消息处理，那么这就是同步非阻塞。如果这个线程在等待函数返回时，没有执行其他消息处理，而是挂起等待，那么就是同步阻塞</p><h1 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h1><p>操作系统将内存空间分为了<strong>内核空间和用户空间</strong>。<br>进程切换非常的耗资源，所以能不挂起进程就不挂起进程。<br>将进程阻塞是让出CPU资源。</p><p>对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：1. 等待数据准备 (Waiting for the data to be ready)2. 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</p><h1 id="Linux-IO的五种模型"><a href="#Linux-IO的五种模型" class="headerlink" title="Linux IO的五种模型"></a>Linux IO的五种模型</h1><h2 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h2><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/05/1557037472070-1557037472074.png" alt="title"></p><p><img src="https://user-gold-cdn.xitu.io/2019/3/25/169b2de92af4b59b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>当应用进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在进程这边，整个应用进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，应用进程才解除block的状态，重新运行起来。在内核执行I/O的两个阶段，都是阻塞的。<strong>每个连接都需要配套一个线程，不适合高并发的情况。</strong></p><p><strong>在阻塞的过程中，这个线程被挂起了，但是他让出了CPU，其他应用进程可以继续占用CPU执行。</strong></p><h2 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h2><p>基于轮询的方式。<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/05/1557037653186-1557037653231.png" alt="title"><br>当所请求的I/O操作不能满足要求时候，不把本进程投入睡眠，而是返回一个错误。也就是说当数据没有到达时并不等待，而是以一个错误返回。并且进程会多次轮询的请求I/O操作。应用程序的线程需要不断的进行 I/O 系统调用，轮询数据是否已经准备好，如果没有准备好，继续轮询，直到完成系统调用为止 。这样，好处是线程不需要一直阻塞，但是需要不断地进行I/O系统调用，<strong>不断轮询，浪费CPU</strong>。不断发起I/O操作及其浪费CPU资源。同步非阻塞就是 “每隔一会儿瞄一眼进度条” 的轮询（polling）方式。<br>需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。</p><h2 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h2><p>基于操作系统的poll，select，epoll。<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/05/1557037849336-1557037849341.png" alt="title"><br>非阻塞IO问题：<br>由于同步非阻塞方式需要不断主动轮询，轮询占据了很大一部分过程，轮询会消耗大量的CPU时间，但是服务器端可能会有多个连接，这样他对每一个连接都这样做，要是连接数量太多时，是不适合的。</p><p>IO多路复用有两个特别的系统调用select、poll、epoll函数。select调用是内核级别的，select轮询相对非阻塞的轮询的区别在于—<strong>前者可以等待多个socket，能实现同时对多个IO端口进行监听</strong>，当其中任何一个socket的数据准好了，就能返回进行可读，然后进程再进行recvform系统调用，将数据由内核拷贝到用户进程，当然这个过程是阻塞的。</p><p>select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function<strong>会不断的轮询所负责的所有socket</strong>，当某个socket有数据到达了，就通知用户进程。</p><p>这几个函数也会使进程阻塞，但是和阻塞I/O所不同的的，<strong>这两个函数可以同时阻塞多个I/O操作</strong>（只需要阻塞一个select函数）。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时（注意不是全部数据可读或可写），才真正调用I/O操作函数。</p><p>上面的图和blocking IO的图其实并没有太大的不同，在两个阶段都需要阻塞。当连接数量很少的时候，I/O多路复用可能比BIO效率还要低，因为I/O多路复用需要多执行一个select内核操作。但是I/O多路复用的优势在于他可以处理更多的连接，而不是处理单个连接速度更快。与传统的多线程/多进程模型比，I/O多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降底了系统的维护工作量，节省了系统资源。</p><h2 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h2><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/05/1557039387817-1557039387825.png" alt="title"><br>在信号驱动式I/O模型中，应用程序使用套接口进行信号驱动I/O，并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。</p><p>基本不怎么用。</p><h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/05/1557039496514-1557039496560.png" alt="title"><br>用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会<strong>直接返回给用户进程</strong>，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核<strong>向进程发送通知（回调函数）</strong>。IO两个阶段，进程都是非阻塞的。</p><p>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>注意：同步非阻塞I/O和I/O多路复用，在返回可读条件后，都需要再调用一次I/O操作，进行复制数据。首先一个IO操作其实分成了两个步骤：发起IO请求和实际的IO操作，同步IO和异步IO的区别就在于第二个步骤是否阻塞，如果实际的IO读写阻塞请求进程，那么就是同步IO，因此阻塞IO、非阻塞IO、IO复用、信号驱动IO都是同步IO，如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，那么就是异步IO。阻塞IO和非阻塞IO的区别在于第一步，发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。</p><h1 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select poll epoll"></a>select poll epoll</h1><p>目前支持I/O多路复用的系统调用有 select，poll，epoll，I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，<strong>一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作</strong>。select，pselect，poll，epoll本质上都是同步I/O。</p><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>用于表述指向文件的引用的抽象化概念。。<br>当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p><h2 id="Linux的socket事件wakeup-callback机制"><a href="#Linux的socket事件wakeup-callback机制" class="headerlink" title="Linux的socket事件wakeup callback机制"></a>Linux的socket事件wakeup callback机制</h2><p>linux wakeup callback机制是IO多路复用的本质。</p><p>Linux通过socket睡眠队列来管理所有等待socket的某个事件的进程（Process），同时通过wakeup机制来异步唤醒整个睡眠队列上等待事件的Process，通知Process相关事件发生。</p><p>每个socket维护了一个队列，比如socket可读的时候，内核就会唤醒队列里的各个Process，并且执行每个Process的callback函数。</p><p>每一个socket都有sleep_list,当某个进程所关心的事件在socket中并没有发生，那么将进程插入到sleep_list，当socket的时间发生了，那么就去遍历他sleep_list中的每个进程的callback函数。</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>我们以read事件为例子。<br>当socket上所监听的事件发生了，那么相应的进程就去处理。那么怎么获取监听的事件发生呢？<br>我们应该block在等待事件的发生上，这个事件简单点就是关心的N个socket中一个或多个socket有数据可读了，当block解除的时候，就意味着，我们一定可以找到一个或多个socket上有可读的数据。</p><p>根据wakeup callback。<br>所以，进程需要同时插入到我们管理的这好多个socket的sleep_list上等待任意一个socket可读事件发生而被唤醒，当Process被唤醒的时候，其callback里面应该有个逻辑去检查具体哪些socket可读了。</p><p>举个例子：<br>假设c1，c2，c3连接到了服务器端，我们想监听他们的读事件，因此我们将进程p1插入到他们与服务器各自的socket中sleep_list中去，此时没有事件发生，因此进程处于睡眠状态，当c1客户端发送来了数据，有数据读取的时候，p1进程被唤醒。<br>伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private int sk_event;</span><br><span class="line"></span><br><span class="line">void poll() &#123;</span><br><span class="line">    //其他逻辑...</span><br><span class="line">    when (receive queue is not empty) &#123;</span><br><span class="line">        sk_event |= POLL_IN；</span><br><span class="line">    &#125;</span><br><span class="line">   //其他逻辑...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当receive queue不为空的时候（即收到了消息），我们就给这个socket的sk_event添加一个POLL_IN事件，用来<strong>表示当前这个socket可读</strong>。将来Process遍历到这个socket，发现其sk_event包含POLL_IN的时候，就可以对这个socket进行读取数据操作了。</p><p>接下来，p1执行select，select会将需要监控的readfds集合拷贝到内核空间（因为内核才能通知说某个socket可读），然后遍历自己监控的socket，挨个调用socket的poll逻辑以便检查该socket是否有可读事件。<br>遍历完所有的socket后，如果没有任何一个sk可读，那么select会调用schedule，使得Process进入睡眠（或者睡眠timeout这么长时间）。如果在timeout时间内某个socket上有数据可读了，或者等待timeout了，则调用select的Process会被唤醒。<br>伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (socket in readfds) &#123;</span><br><span class="line">    sk_event.evt = socket.poll();</span><br><span class="line">    sk_event.sk = socket;</span><br><span class="line">    return_event_for_process;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</span><br></pre></td></tr></table></figure><p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，<strong>直到有描述符就绪</strong>（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），<strong>函数返回</strong>。<strong>当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</strong><br>select缺点：<br>1.文件描述符的数量存在最大限制，在Linux上一般为1024。</p><p>2.对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。<br>每次select()都需要扫描所有的fd_set。而epoll是通过注册回调函数来实现的，所以epoll效率大大高于select.</p><p>3.需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</p><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>解决了文件描述符数量限制的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int poll (struct pollfd *fds, unsigned int nfds, int timeout);</span><br></pre></td></tr></table></figure><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。<br>与select两点区别：<br>1.文件描述符大小不限制。<br>2.不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct pollfd &#123;</span><br><span class="line">    int fd; /* file descriptor */</span><br><span class="line">    short events; /* requested events to watch */</span><br><span class="line">    short revents; /* returned events witnessed */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>pollfd结构包含了要监视的event和发生的event。</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>解决了需要循环遍历文件描述符的缺点，解决了需要将大量的fds从内核拷贝到用户空间的问题。</p><p>将大量的fds从内核拷贝到用户空间的解决：<br>共享内存。<br>epoll通过内核与用户空间mmap同一块内存来解决。mmap将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址（不管是用户空间还是内核空间都是虚拟地址，最终要通过地址映射映射到物理地址），使得这块物理内存对内核和对用户均可见，减少用户态和内核态之间的数据交换。</p><p>需要循环遍历文件描述符的解决：<br>epoll引入了一个中间层，一个双向链表ready_list，一个单独的睡眠队列single_epoll_wait_list。<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/07/1557212167413-1557212167863.png" alt="title"><br>1.调用epoll之前，我们希望我们的MyProcess可以管理四个socket。<br>2.四个socket都没有事件，这时候MyProcess进入single_epoll_wait_list并且sleep。<br>3.有一个socket（大红色）收到了数据，触发其wait_entry_sk，把这个socket加入到ready_list里。<br>4.MyProcess被唤醒（从single_epoll_wait_list出来了表示被唤醒），来处理ready_list中的所有socket：遍历epoll的ready_list，挨个调用每个socket的poll逻辑收集发生的事件，对于监控可读事件而已，ready_list上的每个socket都是有数据可读的，这里的遍历必要的。</p><p>epoll有两种工作模式，LT和ET。<br>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p><p><a href="https://blog.csdn.net/j080624/article/details/78468396" target="_blank" rel="noopener">ServerSocket与Socket</a><br><a href="https://www.jianshu.com/p/486b0965c296" target="_blank" rel="noopener">Linux 五种IO模型</a><br><a href="https://www.jianshu.com/p/dfd940e7fca2" target="_blank" rel="noopener">select、poll、epoll详解</a><br><a href="https://segmentfault.com/a/1190000003063859#articleHeader15" target="_blank" rel="noopener">Linux IO模式及 select、poll、epoll详解</a><br><a href="https://wyj.shiwuliang.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SELECT%E3%80%81POLL%E5%92%8CEPOLL%20.html" target="_blank" rel="noopener">深入理解select，poll，epoll</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Socket与ServerSocket&quot;&gt;&lt;a href=&quot;#Socket与ServerSocket&quot; class=&quot;headerlink&quot; title=&quot;Socket与ServerSocket&quot;&gt;&lt;/a&gt;Socket与ServerSocket&lt;/h2&gt;&lt;p&gt;网络
      
    
    </summary>
    
      <category term="IO" scheme="http://yoursite.com/categories/IO/"/>
    
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Java线程</title>
    <link href="http://yoursite.com/2019/09/29/Java%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/09/29/Java线程/</id>
    <published>2019-09-29T05:53:25.000Z</published>
    <updated>2019-10-09T07:50:23.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发作用"><a href="#并发作用" class="headerlink" title="并发作用"></a>并发作用</h2><p>将多核CPU的计算能力发挥到极致，性能得到提升。</p><p>面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分。</p><a id="more"></a><h2 id="并发缺点"><a href="#并发缺点" class="headerlink" title="并发缺点"></a>并发缺点</h2><ul><li>线程安全问题。</li><li>频繁的上下文切换。</li></ul><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p>Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once。并发指的是多个任务交替进行，而<strong>并行则是指真正意义上的“同时进行</strong>”。实际上，如果系统内只有一个CPU，而使用多线程时，那么真实系统环境下不能并行，只能通过切换时间片的方式交替进行，而成为并发执行任务。真正的并行也只能出现在拥有多个CPU的系统中。</p><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>主要从消息通知角度来看。</p><p>同步是说在调用一个函数后，直到执行完成才返回结果。</p><p>异步是在调用一个函数之后，立即返回，等待函数执行完成之后，通过<strong>状态、通知和回调</strong>来通知调用者。</p><h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><p>主要从等待返回结果时的状态来看。</p><p>阻塞就是在等待返回结果时，当前线程会被挂起，让出CPU，不能执行其他业务。</p><p>非阻塞就是在等待返回结果时，当前线程不会阻塞，可以去执行其他的业务。</p><h3 id="临界区资源"><a href="#临界区资源" class="headerlink" title="临界区资源"></a>临界区资源</h3><p>临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每个线程使用时，一旦临界区资源被一个线程占有，那么其他线程必须等待。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><ul><li>继承Thread</li><li>实现Runnable</li><li>实现Callable</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extends thread</span></span><br><span class="line">     Thread t1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             System.out.println(<span class="string">"t1"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     t1.start();</span><br><span class="line">     <span class="comment">// implements Runnable</span></span><br><span class="line">     Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             System.out.println(<span class="string">"t2"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     t2.start();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// implements Callable,Callable可以有返回值</span></span><br><span class="line">     ExecutorService service=Executors.newSingleThreadExecutor();</span><br><span class="line">     Future&lt;String&gt; future=service.submit(<span class="keyword">new</span> Callable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="string">"thread 3"</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         String result=future.get();</span><br><span class="line">         System.out.println(result);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/07/1570450394461-1570450394478.png" alt="title"></p><ul><li><p>新建(new)，创建线程。</p></li><li><p>Runnable。包括Running和Ready两个阶段，Running就是占用CPU运行，Ready是线程还处于等待阶段。</p></li><li><p>阻塞(Blocked)。等待获取临界区资源，一旦他获得了锁就会结束这个状态。</p></li><li><p>无限期等待(Waiting)。</p><p>等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>没有设置 Timeout 参数的 Object.wait() 方法</td><td>Object.notify() / Object.notifyAll()</td></tr><tr><td>没有设置 Timeout 参数的 Thread.join() 方法</td><td>被调用的线程执行完毕</td></tr><tr><td>LockSupport.park() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table></li><li><p>限期等待(Timed-waiting)。</p><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>Thread.sleep() 方法</td><td>时间结束</td></tr><tr><td>设置了 Timeout 参数的 Object.wait() 方法</td><td>时间结束 / Object.notify() / Object.notifyAll()</td></tr><tr><td>设置了 Timeout 参数的 Thread.join() 方法</td><td>时间结束 / 被调用的线程执行完毕</td></tr><tr><td>LockSupport.parkNanos() 方法</td><td>LockSupport.unpark(Thread)</td></tr><tr><td>LockSupport.parkUntil() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table></li><li><p>终止。线程任务结束，或者是产生了异常而终止。</p></li></ul><h3 id="线程基本操作"><a href="#线程基本操作" class="headerlink" title="线程基本操作"></a>线程基本操作</h3><h4 id="sleep-and-wait"><a href="#sleep-and-wait" class="headerlink" title="sleep() and wait()"></a>sleep() and wait()</h4><p>sleep会休眠当前线程，等到了时间，自动苏醒。</p><p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，<strong>其它线程会调用</strong> <strong>notify() 或者 notifyAll() 来唤醒挂起的线程</strong>。</p><p>两者区别：</p><ul><li><p>sleep到点自己醒，<strong>wait需要其他线程调用notify来唤醒</strong>。</p></li><li><p>wait()方法必须要在<strong>同步方法或者同步块中调用</strong>，也就是必须已经获得对象锁。</p></li><li><p>sleep不释放锁，wait释放锁。</p></li></ul><h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><p>在<strong>线程中调用另一个线程的 join() 方法，会将当前线程挂起</strong>，而不是忙等待，<strong>直到目标线程结束</strong>。</p><p>对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。</p><h4 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h4><p>一旦执行，当前线程会让出cpu，但是，需要注意的是，让出的CPU并不是代表当前线程不再运行了，如果在下一次竞争中，又获得了CPU时间片当前线程依然会继续运行。另外，让出的时间片只会分配<strong>给当前线程相同优先级</strong>的线程。</p><p>sleep()和yield()方法，同样都是当前线程会交出处理器资源，而它们不同的是，sleep()交出来的时间片其他线程都可以去竞争，也就是说都有机会获得当前线程让出的时间片。而yield()方法只允许与当前线程具有相同优先级的线程能够获得释放出来的CPU时间片。</p><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p><p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。</p><p>main() 属于非守护线程。</p><p>使用 setDaemon() 方法将一个线程设置为守护线程</p><h3 id="线程中断问题"><a href="#线程中断问题" class="headerlink" title="线程中断问题"></a>线程中断问题</h3><p>线程可以调用interrupt()来中断别的线程。但这个操作并不一定会使线程中断，更像是给了线程一个通知，但具体是否中断还是要看线程本身。</p><h4 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h4><p>通过调用一个线程的 interrupt() 来中断该线程，<strong>如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程</strong>。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p><h4 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h4><p>如果线程不处在等待或者是阻塞状态，那么直接interrupt是不能中断线程的。但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。</p><p>这样，线程就可以对相应的中断请求进行处理了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Thread t1=<span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">while</span>(!isInterrupted()) &#123;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"end......."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">t1.start();</span><br><span class="line">t1.interrupt();</span><br><span class="line">System.out.println(t1.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;并发作用&quot;&gt;&lt;a href=&quot;#并发作用&quot; class=&quot;headerlink&quot; title=&quot;并发作用&quot;&gt;&lt;/a&gt;并发作用&lt;/h2&gt;&lt;p&gt;将多核CPU的计算能力发挥到极致，性能得到提升。&lt;/p&gt;
&lt;p&gt;面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>字节码执行引擎</title>
    <link href="http://yoursite.com/2019/09/25/%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <id>http://yoursite.com/2019/09/25/字节码执行引擎/</id>
    <published>2019-09-25T01:57:50.000Z</published>
    <updated>2019-09-30T06:07:50.237Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h2><p>重载和重写在JVM中是如何实现的？</p><h3 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h3><p>重载的实现。</p><p>重载时是通过参数的静态类型而不是实际类型决定使用哪个重载函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Father是静态类型 ， Son是实际类型。</span></span><br><span class="line">Father father = <span class="keyword">new</span> Son();</span><br></pre></td></tr></table></figure><p>发生在编译阶段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Son();          <span class="comment">//静态分派</span></span><br><span class="line">        print(father);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Father father)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is father"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Son son)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is son"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：this is father</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><h3 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h3><p>重写的实现。</p><p>发生在运行阶段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123; </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123; </span><br><span class="line">System.out.println(<span class="string">"man say hello!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123; </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123; </span><br><span class="line">System.out.println(<span class="string">"woman say hello!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Human man=<span class="keyword">new</span> Man();</span><br><span class="line">Human woman=<span class="keyword">new</span> Woman();</span><br><span class="line">man.sayHello();</span><br><span class="line">woman.sayHello();</span><br><span class="line">man=<span class="keyword">new</span> Woman();</span><br><span class="line">man.sayHello(); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从invokevirtual指令的多态查找过程开始说起，invokevirtual指令的运行时解析过程大致分为以下几个步骤：</p><p>1、找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。<br>2、如果在类型C中找到与常量中的描述符和简单名称相符合的方法，然后进行访问权限验证，如果验证通过则返回这个方法的直接引用，查找过程结束；如果验证不通过，则抛出java.lang.IllegalAccessError异常。<br>3、否则未找到，就按照继承关系从下往上依次对类型C的各个父类进行第2步的搜索和验证过程。<br>4、如果始终没有找到合适的方法，则跑出java.lang.AbstractMethodError异常。</p><p><strong>由于invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上</strong>，这个过程就是Java语言方法重写的本质。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分派&quot;&gt;&lt;a href=&quot;#分派&quot; class=&quot;headerlink&quot; title=&quot;分派&quot;&gt;&lt;/a&gt;分派&lt;/h2&gt;&lt;p&gt;重载和重写在JVM中是如何实现的？&lt;/p&gt;
&lt;h3 id=&quot;静态分派&quot;&gt;&lt;a href=&quot;#静态分派&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾收集机制</title>
    <link href="http://yoursite.com/2019/09/21/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/09/21/JVM垃圾收集机制/</id>
    <published>2019-09-21T07:19:28.000Z</published>
    <updated>2019-09-30T06:07:02.167Z</updated>
    
    <content type="html"><![CDATA[<p>GC需要完成三件事：</p><ul><li>哪些对象需要回收？</li><li>何时进行回收？</li><li>怎么样回收？</li></ul><a id="more"></a><h2 id="哪些对象需要回收"><a href="#哪些对象需要回收" class="headerlink" title="哪些对象需要回收"></a>哪些对象需要回收</h2><p>死掉的对象需要回收。</p><h3 id="如何判断对象已死？"><a href="#如何判断对象已死？" class="headerlink" title="如何判断对象已死？"></a>如何判断对象已死？</h3><p><strong>可达性分析算法+finalize().</strong></p><h4 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h4><p>把一系列称为”GC Roots”的对象作为起点，向下进行搜索，<strong>当GC Roots到某个对象不可达时</strong>，这个对象就是可回收的。</p><p>GC Roots对象包括：</p><ul><li><strong>虚拟机栈中引用的对象。</strong></li><li><strong>方法区中类静态属性引用的对象。</strong></li><li><strong>方法区中常量引用的对象。</strong></li><li><strong>本地方法栈中引用的对象</strong>。</li></ul><p>为什么不使用引用计数法呢？</p><p>引用计数法就是每当加了一个引用，引用计数器加一，一个引用失效，引用计数器减一，引用计数器为零时该对象死亡。</p><p>但是引用计数无法解决的是<strong>循环引用</strong>的问题。</p><p>循环引用：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/21/1699fd090876bda5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">MyObject object1 = <span class="keyword">new</span> MyObject();</span><br><span class="line">        MyObject object2 = <span class="keyword">new</span> MyObject();</span><br><span class="line">          </span><br><span class="line">        object1.object = object2;</span><br><span class="line">        object2.object = object1;</span><br><span class="line">          </span><br><span class="line">        object1 = <span class="keyword">null</span>;</span><br><span class="line">        object2 = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h4><p>即使某个对象是不可达的，也并不一定非死不可。宣告一个对象死亡，要经过两次标记过程：<strong>第一个是GC Roots不可达，第二步是此对象是否有必要执行finalize()方法</strong>。</p><p><strong>如果该对象重写了finalize()方法且finalize()方法还没有被虚拟机所调用，</strong>则其对象需要执行该方法。</p><p>那么，该对象会放入一个队列之中，并由一个Finalizer线程去执行finalize()方法。<strong>finalize方法是对象拯救自己的最后一次方法，只需要与任何一个GC Roots建立关联即可</strong>。这样他就还是存活的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscape</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscape SAVE=<span class="keyword">null</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">super</span>.finalize();</span><br><span class="line">System.out.println(<span class="string">"finalize excute...."</span>);</span><br><span class="line">FinalizeEscape.SAVE=<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" i am still alive ....."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">SAVE=<span class="keyword">new</span> FinalizeEscape();</span><br><span class="line">SAVE=<span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br><span class="line">Thread.sleep(<span class="number">500</span>);</span><br><span class="line"><span class="keyword">if</span>(SAVE==<span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">" i am dead ....."</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">SAVE.isAlive();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SAVE=<span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br><span class="line">Thread.sleep(<span class="number">500</span>);</span><br><span class="line"><span class="keyword">if</span>(SAVE==<span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">" i am dead ....."</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">SAVE.isAlive();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出：</span></span><br><span class="line"><span class="comment">    finalize excute....</span></span><br><span class="line"><span class="comment">    i am still alive .....</span></span><br><span class="line"><span class="comment">    i am dead .....</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure><p>由此可见，SAVE对象的finalize()方法确实执行了，并在收集前成功逃脱了。</p><p>代码中有两段完全一样的方法，第一次成功逃脱，第二次因为已经执行过了finalize()方法，所以也就不在执行了，因此第二段代码逃脱失败。</p><p>然而，并不鼓励使用finalize()方法。</p><h2 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h2><p><img src="https://user-gold-cdn.xitu.io/2019/3/21/1699fd090880f55d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li><p>强引用：</p><p>强引用是使用最普遍的引用。Object obj =new Object(); <strong>如果一个对象具有强引用，那垃圾回收器绝不会回收它</strong>。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。</p></li><li><p>软引用：</p><p>如果一个对象只具有软引用，则<strong>内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。使用SoftReferrnce类实现软引用。</strong></p></li><li><p>弱引用：</p><p>被弱引用引用的对象只能生存到下一次垃圾回收之前。当GC开始工作时，无论内存是否充足，都会回收弱引用引用的对象。使用WeakReference来实现弱引用类。</p></li><li><p>虚引用：</p><p>顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。</p></li></ul><h2 id="方法区GC"><a href="#方法区GC" class="headerlink" title="方法区GC"></a>方法区GC</h2><p>方法区主要回收废弃常量以及无用的类。</p><p>废弃常量，没有地方引用他。</p><p>废弃类需要满足以下条件：</p><ul><li>该类所有实例已经被回收。</li><li>加载该类classLoader已经被回收。</li><li>该类的class对象没有在任何地方被引用。</li></ul><p>对于jdk8之后方法区变为了元空间，如果Metaspace的空间占用达到了设定的最大值，也会触发GC来收集死亡对象和类的加载器。</p><p><a href="https://www.sczyh30.com/posts/Java/jvm-metaspace/" target="_blank" rel="noopener">MetaSpace GC</a></p><h2 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h2><h3 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h3><p><img src="https://user-gold-cdn.xitu.io/2019/3/21/1699fd090426063b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>标记出所有需要回收的对象，然后将做了标记的都给清除。缺点是导致内存碎片化。</p><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p><img src="https://user-gold-cdn.xitu.io/2019/3/21/1699fd09088768fc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>将内存一般分为A区域，一半分为B区域。图中我们将前两行分为A，后两行分为B。刚开始的时候，我们只使用A区域的内存，而不使用B区域的内存。</p><p>第一次GC，经过一次可达性分析后，我们将A中存活对象直接复制到B区域，然后直接将整块A区域清除。A区域变成未使用的。第二次GC，同理，将B的存活对象复制到A，将B清除，B变为空。</p><p>这样A和B区域交互使用。</p><p>这个算法可以解决内存碎片化的问题，但是会导致内存浪费，一次只能使用一半的内存。</p><p>新生代主要使用的是复制算法。一般来说，Eden：Survior1：Survior2=8：1：1，因为每次GC新生代垃圾都会有75%-90%，这样，直接将Eden幸存的对象复制到Survior1区域中，然后将Eden区域清除，第二次清除时，将Eden区域和S1区域幸村对象复制到S2区域，将Eden和S1区域清除，就这样，S1，S2两个区域交替使用，新生代内存利用空间可以达到90%，而且解决了内存碎片化的问题。注意，当Survior内存区域不够时（多于10%对象存活），可以向老年代进行分配担保。</p><p><strong>适用于存活率比较低的对象，要是存活率过高的话，会造成大量复制，效率变低</strong>。</p><h3 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h3><p>复制算法在对象存活率较高时就会产生一个问题，因为要进行过多的复制操作，效率会降低，而且浪费空间会比较多。对于老年代，存活对象率比较高，而且对象比较大，占用内存大，所以不宜使用复制算法，采用标记整理算法。</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/21/1699fd0908bddc3b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>将存活的对象移到回收对象留下的空间里，以形成连续的内存。</p><p>适用于存活率较高的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>新生代中，每次GC都有大量对象死去，少量存活，选用复制算法。</p><p>老年代中，对象存活率高，没有额外空间进行内存担保，使用标记-整理。</p><h2 id="HotSpot算法实现"><a href="#HotSpot算法实现" class="headerlink" title="HotSpot算法实现"></a>HotSpot算法实现</h2><p>两个问题</p><ul><li><p>寻找GC Roots效率问题，如果逐个检查引用，太慢。</p><p>使用OopMap来解决，这个数据结构存储了引用以及他的作用范围(从哪个指令开始到哪个指令结束)。</p><p>在类加载完成的时候，就生成了一个OopMap。</p></li><li><p>一致性问题。寻找GC Roots这个阶段需要保证引用情况不再发生变化，因此需要发生GC停顿。</p></li></ul><h3 id="OopMap与Rememebered-Set"><a href="#OopMap与Rememebered-Set" class="headerlink" title="OopMap与Rememebered Set"></a>OopMap与Rememebered Set</h3><h4 id="OopMap"><a href="#OopMap" class="headerlink" title="OopMap"></a>OopMap</h4><p><strong>编译时就有了。</strong></p><p>用于枚举GC Roots。</p><p>当垃圾回收时，收集线程会对栈上的内存进行扫描，看看那些位置上存储了Reference类型。如果发现了某个位置上存储的是Reference类型，就意味着这个引用所指向的对象在这一次垃圾回收过程中不能够回收。</p><p>但是要是逐个检查引用，这一样效率太低了。</p><p>于是采用空间换时间的方法，把栈中是引用类型的变量的位置记录下来，这样他指向的对象肯定是GC Roots。这样，再做GC的时候，就可以直接读取，不用全部扫描了。</p><p>一个线程意味着一个栈，一个栈由多个栈帧组成，一个栈帧对应着一个方法，一个方法里面可能有多个安全点。 gc 发生时，程序首先运行到最近的一个安全点停下来，然后更新自己的 OopMap ，记下栈上哪些位置代表着引用。枚举根节点时，递归遍历每个栈帧的 OopMap ，通过栈中记录的被引用对象的内存地址，即可找到这些对象（ GC Roots ）。</p><p>因为一个方法有多个安全点，每个安全点就有一个OopMap，所以，一个方法里有多个OopMap。</p><p><strong>可以把oopMap简单理解成是调试信息。在源代码里面每个变量都是有类型的，但是编译之后的代码就只有变量在栈上的位置了。oopMap就是一个附加的信息，告诉你栈上哪个位置本来是个什么东西。 这个信息是在JIT编译时跟机器码一起产生的。因为只有编译器知道源代码跟产生的代码的对应关系。 每个方法可能会有好几个oopMap，就是根据safepoint把一个方法的代码分成几段，每一段代码一个oopMap，作用域自然也仅限于这一段代码。 循环中引用多个对象，肯定会有多个变量，编译后占据栈上的多个位置。那这段代码的oopMap就会包含多条记录。</strong></p><h4 id="Rememebered-Set"><a href="#Rememebered-Set" class="headerlink" title="Rememebered Set"></a>Rememebered Set</h4><p>RememberedSet 用于处理这类问题：比如说，新生代 gc （它发生得非常频繁）。一般来说， gc 过程是这样的：首先枚举根节点。根节点有可能在新生代中，也有可能在老年代中。这里由于我们只想收集新生代（换句话说，不想收集老年代），所以没有必要对位于老年代的 GC Roots 做全面的可达性分析。但问题是，确实可能存在位于老年代的某个 GC Root，它引用了新生代的某个对象，这个对象你是不能清除的。那怎么办呢？</p><p>维护一个表，记录别的代对新生代的引用关系，这个表叫Remembered Set。</p><p>在G1收集器中，堆被分成一个个region，难免会存在别的region中的对象会引用某个region的对象，那么，就对每一个region维护一个Remembered Set，记录其他所有region对象对他其中对象的引用。</p><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>在OopMap的帮助下，可以很容易的寻找GC Roots，但是，每一个指令都可能导致OopMap的变化，<strong>如果为每一条指令都生成一个对应的OopMap，那么，将会需要大量的空间。于是，HotSpot只是在特定的点记录了这些信息，这些点叫做安全点</strong>，程序旨在安全点才停下来执行GC。</p><p>如何让让所有的线程跑到安全点中断呢？</p><p>抢先式中断和主动式中断。</p><p>抢先式中断是把所有的线程都中断，然后把不在安全点上的线程恢复，直到他到达安全点上。</p><p>主动式中断：设置一个中断标志，各个线程主动区轮询这个标志，发现中断标志为真时，自己主动挂起。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><strong>所有的收集器都避免不了stop the word，只可能尽可能的缩短。</strong></p><p><img src="https://user-gold-cdn.xitu.io/2019/3/21/1699fd093e82e813?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p><ul><li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li><li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li></ul><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><ul><li><p>适用于新生代和老年代。</p></li><li><p>单线程收集器，在他进行垃圾收集时，必须暂停所有其他工作的线程。</p></li><li><p>新生代采用复制算法，老年代采用标记-整理算法。</p></li></ul><h3 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h3><ul><li><p>Serial的多线程版本。除了Serial，只有ParNew可以与CMS一起使用。</p></li><li><p>适用于新生代和老年代。</p></li><li><p>新生代采用复制算法，老年代采用标记-整理算法。</p></li></ul><h3 id="Parallel-Scavenge-Parallel-old"><a href="#Parallel-Scavenge-Parallel-old" class="headerlink" title="Parallel Scavenge+Parallel old"></a>Parallel Scavenge+Parallel old</h3><p>Parallel Scavenge一个新生代收集器，特点是吞吐量优先。经常与Parallel Old一起使用 。</p><p>在<strong>注重吞吐量的情况下，使用Parallel Scavenge+Parallel old（科学计算，天文计算等）</strong>。</p><p>Parallel Scavenge新生代采用复制算法，Parallel old老年代采用标记-整理。</p><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p><strong>基于标记-清除算法。并不是标记整理。</strong></p><p>注重于获取最短停顿时间。并发收集，分区处理。停顿时间短，在垃圾收集的时候，JVM还可以运行。</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/21/1699fd093e8919b1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>分为以下四个流程：</p><ul><li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li><li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li><li>并发清除：不需要停顿。</li></ul><p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p><p>CMS具有以下缺点：</p><ul><li>在并发标记以及并发清除阶段，GC会占用一部分的CPU资源，会造成吞吐量下降CMS 默认启动的回收线程数=(CPU 数目+3)4 当 CPU 数&gt;4 时, GC线程一般占用不超过 25%的 CPU 资源, 但是当 CPU 数&lt;=4 时, GC线程 可能就会过多的占用用户 CPU 资源, 从而导致应用程序变慢, 总吞吐量降低.。</li><li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是<strong>指并发清除阶段</strong>由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li><li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li></ul><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>用来替代CMS的。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><p>采用的是标记-整理算法+复制算法，避免产生内存空间碎片。。标记整理出需要回收的region，region间使用复制算法。</p></li><li><p>将整个Java堆分成一个个相等的独立区域，虽然还有分代的概念，但各个代不再是连续的，<strong>新生代和老年代不再物理隔离</strong>。。</p></li><li><p>可预测的停顿。</p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/3/21/1699fd093e76a0ad?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="G1堆内存分布">通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>服务端多核CPU、JVM内存占用较大的应用。</li><li>运行过程中会产生大量内存碎片。</li><li>想要可控的，可预期的GC停顿时间。</li></ul><h3 id="收集过程"><a href="#收集过程" class="headerlink" title="收集过程"></a>收集过程</h3><ul><li>初始标记，标记GC Roots直接关联对象，需要暂停，时间短</li><li>并发标记，对GC Roots进行可达性分析，并发执行，时间比较长。</li><li>最终标记，修正并发标记阶段而产生的变动，这一段是暂停的。</li><li>筛选回收，将各个region根据回收价值和回收成本进行排序，然后进行收集。这个阶段需要暂停用户线程。<h2 id="Minor-GC-and-Full-GC"><a href="#Minor-GC-and-Full-GC" class="headerlink" title="Minor GC and Full GC"></a>Minor GC and Full GC</h2><h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3>回收新生代，因为新生代对象存活时间很短，因此Minor GC会频繁进行，执行速度也比较快。<br>当Eden区域满了的话，会触发Minor GC。<h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3>回收新生代和老年代，老年代因为存活时间比较长，因此Full GC很少执行，速度也比较慢。</li></ul><p>触发Full GC：</p><ul><li><p>老年代空间不足。</p></li><li><p>空间分配担保失败。</p><p>新生代采用复制收集算法，需要将存活的对象复制到survivor中，然后直接清理Eden区，但是会有一种情况，就是存活的对象大于survivor内存空间，这样，就需要老年代分配担保，将survivor中无法分配的对象放入老年代。但是，万一老年代也不够用呢？</p><p>加入老年代剩余最大连续可用空间大于Eden区，那么肯定可以直接放。</p><p>否则的话，看老年代是否允许担保失败，可以的话，检查老年代剩余最大连续可用空间是否大于历次晋升到老年代对象的平均大小，如果大于，尝试进行Minor GC，小于的话，直接Full GC。</p></li><li><p>CMS垃圾收集器浮动垃圾的问题。因为在CMS并发清理阶段用户线程也在运行，所以需要留出一定的空间做缓冲。这样，老年代没有满的时候就需要触发Full GC,默认是92%。但要是预留的空间无法满足程序需要，就会报 Concurrent Mode Failure 错误，并触发 Full GC。</p></li></ul><h2 id="对象分配策略"><a href="#对象分配策略" class="headerlink" title="对象分配策略"></a>对象分配策略</h2><ul><li><p>对象优先在Eden区分配。当Eden区没有足够的空间进行分配时，会触发Minor GC。如果启动了TLAB，那么优先在TLAB上分配，G1默认就是启动TLAB的。</p></li><li><p>大对象直接进入老年代。</p></li><li><p>长期存活对象将进入老年代，对象每熬过一次Minor GC，年龄增加一岁，当年龄达到阈值(默认是15),那么这个对象晋升到老年代。</p></li><li><p>动态对象年龄判定。虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/youyou1543724847/article/details/52728154" target="_blank" rel="noopener">OopMap详解</a></p><p><a href="https://www.iteye.com/blog/dsxwjhf-2201685" target="_blank" rel="noopener">OopMap与Remembered Set</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GC需要完成三件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哪些对象需要回收？&lt;/li&gt;
&lt;li&gt;何时进行回收？&lt;/li&gt;
&lt;li&gt;怎么样回收？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM类加载机制</title>
    <link href="http://yoursite.com/2019/09/20/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/09/20/JVM类加载机制/</id>
    <published>2019-09-20T13:37:24.000Z</published>
    <updated>2019-09-30T06:06:41.242Z</updated>
    
    <content type="html"><![CDATA[<p>Java程序运行时，有两个阶段，编译和运行。编译阶段将Java文件编译成class字节码文件，然后在运行阶段将class文件加载到内存，并对class文件解释执行。</p><a id="more"></a><h2 id="Java跨平台原因"><a href="#Java跨平台原因" class="headerlink" title="Java跨平台原因"></a>Java跨平台原因</h2><p><strong>Java语言跨平台的主要原因就是JVM以及字节码文件。</strong></p><p>C语言是将高级语言直接解释成机器码，通过CPU指令集执行机器码，但是，不同架构的CPU，他的指令集可能是不一样的，这样就造成C语言难以跨平台。可是Java就不一样了，Java在机器和程序之间加了一次抽象的虚拟机。直接将Java程序编译成字节码，由Java虚拟机来解释字节码文件，对于不同的平台，解释器是不同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwNTI5MTQxNTU4NDg3?x-oss-process=image/format,png" alt="这里写图片描述"></p><h2 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h2><p><img src="http://file.elecfans.com/web1/M00/4F/B0/pIYBAFrhQ-WAN_-bAAA9GHdpZic508.jpg" alt></p><p>将Java文件转换成字节码文件。字节码文件存储了所有信息。</p><p>class文件中有一个class常量池，里面存放了字符串。</p><p>所以，类似于String s = “a”+”b”;在<strong>编译阶段会</strong>直接被优化为”ab”。</p><p><img src="https://img-blog.csdn.net/20170329213804490?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU3VnYXJfUmFpbmJvdw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><h2 id="类加载阶段"><a href="#类加载阶段" class="headerlink" title="类加载阶段"></a>类加载阶段</h2><p>类加载就是将class文件加载到内存，并对数据进行校验，转换解析和初始化，最终转化成可被虚拟机使用的Java类型。<strong>类加载阶段是在运行期间完成的。</strong></p><p>类加载阶段主要包括五个阶段：加载，验证，准备，解析，初始化。。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvODc5ODk2LzIwMTYwNC84Nzk4OTYtMjAxNjA0MTQyMjQ1NDk3NzAtNjAwMDY2NTUucG5n?x-oss-process=image/format,png" alt="img"></p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ul><li>通过一个类的全限定名获取字节码文件。</li><li>将字节码文件静态存储结构转化为运行时内存区域。</li><li>生成这个类的java.lang.class对象。存在于方法区（元空间）。</li></ul><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>确保字节码文件信息是否合法。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为类变量(static 修饰<strong>)分配内存并设置初始值</strong>的阶段。</p><p>注意，这个阶段只是类变量设置初始值，而不包括实例变量。</p><p>设置初始值通常情况下指的是数据类型的零值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">23</span>;</span><br></pre></td></tr></table></figure><p>这里只会将a设置为0，将a设置为23需要等到初始化阶段。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>将class常量池内的符号引用替换为直接引用的过程。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>执行clinit()方法的过程，初始化类变量以及执行静态语句块。</p><p>clinit是类初始化的方法，init是对象初始化的方法，static静态语句块在clinit阶段执行，所以静态语句块肯定是先于构造函数执行的。</p><h3 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h3><p><strong>这几个阶段类必须要初始化</strong>，<strong>而不是类加载</strong>。</p><ul><li>遇到new实例化对象，读取或者设置static字段。</li><li>反射调用。</li><li>初始化一个类，若父类还没有初始化，需要先初始化父类。</li><li>初始化主类(执行main方法的)。</li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>对于任何一个类，都需要由加载他的类加载器以及这个类本身来确立他在JVM中的唯一性。比较两个类是否相等，首先应该是建立在同一个类加载器上的。两个类即使来自于同一个class文件，由不同的类加载器加载，这两个加载的类也是不相等的。</p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/09/30/1569822785993-1569822786000.png" alt="title"></p><p>   双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务(搜索范围内没有这个类)，子加载器才会尝试自己去加载，这就是双亲委派模式。</p><p>避免了类加载的混乱。比如说，在classpath下定义了一个java.lang.Object，要是没有双亲委派模型，那么应用程序类加载器会加载这个类，那么就会与启动类加载器加载的Object类冲突。但是要是有类加载机制，那么将会交给启动类加载器，这样加载的还是java自带的Object类，就不会产生冲突。</p><h3 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h3><p>如何破坏双亲委派模型？</p><p>继承ClassLoader，自己重写loadClass方法，然后加入自己逻辑，特定某些class可以按照你的方式处理。。</p><p>重写loadClass：</p><ul><li><p>findLoadedClass</p></li><li><p>委托parent加载器加载（这里注意bootstrap加载器的parent为null)</p></li><li><p>自行加载</p></li></ul><p>打破委派机制要做的就是打乱2和3的顺序，通过类名筛选自己要加载的类，其他的委托给parent加载器</p><h4 id="JDBC破坏"><a href="#JDBC破坏" class="headerlink" title="JDBC破坏"></a>JDBC破坏</h4><p>因为类加载器受到加载范围的限制，在某些情况下父类加载器无法加载到需要的文件，这时候就需要委托子类加载器去加载class文件。</p><p>JDBC的Driver接口定义在JDK中，其实现由各个数据库的服务商来提供，比如MySQL驱动包。DriverManager 类中要加载各个实现了Driver接口的类，然后进行管理，但是DriverManager位于 $JAVA_HOME中jre/lib/rt.jar 包，由BootStrap类加载器加载，而其Driver接口的实现类是位于服务商提供的 Jar 包，<strong>根据类加载机制，当被装载的类引用了另外一个类的时候，虚拟机就会使用装载第一个类的类装载器装载被引用的类。</strong>也就是说BootStrap类加载器还要去加载jar包中的Driver接口的实现类。我们知道，BootStrap类加载器默认只负责加载 $JAVA_HOME中jre/lib/rt.jar 里所有的class，所以需要由子类加载器去加载Driver实现，这就破坏了双亲委派模型。<br>通过线程上下文类加载器，默认是应用程序类加载器，可以通过Thread的方法进行设置。</p><h3 id="Tomcat破坏"><a href="#Tomcat破坏" class="headerlink" title="Tomcat破坏"></a>Tomcat破坏</h3><p><a href="https://www.jianshu.com/p/abf6fd4531e7" target="_blank" rel="noopener">tomcat破坏双亲委派模型</a></p><h4 id="OSGI"><a href="#OSGI" class="headerlink" title="OSGI"></a>OSGI</h4><p>类加载器不再是双亲委派模型的树状结构，而是网状结构。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java程序运行时，有两个阶段，编译和运行。编译阶段将Java文件编译成class字节码文件，然后在运行阶段将class文件加载到内存，并对class文件解释执行。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java内存管理</title>
    <link href="http://yoursite.com/2019/09/20/Java%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/09/20/Java内存管理/</id>
    <published>2019-09-20T06:30:04.000Z</published>
    <updated>2019-09-30T05:50:51.659Z</updated>
    
    <content type="html"><![CDATA[<p>运行时数据区域包括程序计数器，java虚拟机栈，本地方法栈，方法区和堆。其中，java虚拟机栈，本地方法栈，程序计数器是每个线程私有的。</p><p><strong>字节码文件经过类加载子系统从静态存储结构转化为方法区的运行时内存结构。</strong>运行时数据区域包括程序计数器，java虚拟机栈，本地方法栈，方法区和堆。其中，java虚拟机栈，本地方法栈，程序计数器是每个线程私有的，方法区以及堆是所有线程共享的。</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20190228160847399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dhbGxvbl9f,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>所有线程共享。</p><p>主要存放对象以及数组对象的。</p><p>但是，由于现在逃逸技术的存在，对象并不一定都是存在于堆，还有可能存放在栈上。</p><p>java堆分为新生代和老年代，新生代又分为Eden区以及Survivor区。</p><p>当内存不足时，会产生OOM异常。</p><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>线程私有，每一个线程都有一个自己的栈。</p><p>线程每执行一个方法，都会创建一个栈帧，用于存储局部变量表（对象引用，基本数据类型）等。方法调用直至完成的过程中，就是一个栈帧入栈和出栈的过程。<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/09/30/1569822524477-1569822524482.png" alt="title"><br>两种异常情况：</p><ul><li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；</li><li>栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xss512M HackTheJava</span><br></pre></td></tr></table></figure><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>与Java虚拟机栈类似，只不过一个是为Java方法服务，一个是为Native方法服务，其他都一样。Native方法就是Java调用非Java代码的接口。例如调用C语言实现的接口。</p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>可以看作是<strong>当前线程执行到的字节码的行号指示器。</strong>对于Java的多线程，为了使程序每次切换后能够恢复到正确的执行位置，因此<strong>每一个线程必须要有自己独立的程序计数器</strong>。如果线程执行的是Java方法，记录的是正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>各个线程共享的区域。存放的是虚拟机<strong>加载的类信息，常量，静态变量</strong>。</p><p>在HotSpot中，永久代是方法区的实现。因为GC分代收集拓展到方法区。方法区主要是废弃类和常量的收集，对于方法区，也可以选择不进行垃圾回收。</p><p>一般来说，方法区不进行垃圾收集。</p><p>在jdk1.8之后，HotSpot中，删去了永久代，永<strong>久代的相关信息存放在了元空间</strong>。</p><p>元空间与永久代最大的不同就是，元空间并不在JVM中，<strong>而是在本地内存</strong>。主要原因还是因为永久代的大小难以确定，容易发生OOM，而移到元空间，只会受到本地内存大小的限制。</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池是方法区的一部分。</p><p>class常量池：我们写的每一个Java类被编译后，就会形成一份class文件；class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)。</p><p><img src="https://img-blog.csdn.net/20170329213804490?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU3VnYXJfUmFpbmJvdw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><p>class常量池在类加载完成后就会放入运行时常量池存放。</p><p>字符串常量池：存放字符串，位于堆内。<strong>常量池中同时存在字符串常量和字符串引用。</strong>直接赋值和用字符串调用String构造函数都可能导致常量池中生成字符串常量;<strong>而intern()方法会尝试将堆中对象的引用放入常量池</strong>。</p><h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><p>类加载子系统负责<strong>从文件系统或者网络中</strong>加载 Class 信息，加载的类信息存放于一块称 为方法区的内存空间。</p><p>局部变量表所需要的内存空间在编译阶段就分配完毕。</p><h2 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h2><ul><li><p>虚拟机遇到一个new指令，首先从常量池中获取这个类的符号引用，检查这个符号引用代表的类是否被加载。</p></li><li><p>要是没有被加载，必须执行相应的类加载的过程。</p></li><li><p>为对象分配内存，主要有指针碰撞和空闲列表两种办法。指针碰撞是所有使用过的内存放一边，未使用过的内存放一边，中间一个指针作为分界线，当为一个对象分配内存的时候，直接移动指针即可。空闲列表适用于空闲内存和使用过的内存互相交错，内存的使用情况都存在一个表上，根据这个表再去分配内存。<strong>指针碰撞适用于标记-整理算法，空闲列表适用于标记-清除算法。</strong></p></li><li><p>但是，如何解决分配内存过程中的并发问题呢？</p><p><strong>一个就是同步加锁</strong>。</p><p><strong>另一个就是TLAB的使用</strong>，预先个每个线程在Java堆中都分配了一小块内存，哪个线程要给对象分配内存，直接在自己的TLAB中分配，当TLAB用完了，再分配新的，这一步才需要加锁。</p></li><li><p>设置对象头</p></li><li><p>执行init方法，初始化成员变量。</p></li></ul><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>对象在内存中主要分为三个部分：对象头，实例数据以及对齐填充。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/09/30/1569822602260-1569822602265.png" alt="title"></p><p>对象头主要结构是由Mark Word 和 Class Metadata Address 组成 。Class Metadata Address存储的是该对象属于类的地址，即可以判断这个对象属于哪一个类。</p><p>MarkWord有五种类型：<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/09/30/1569822636543-1569822636547.png" alt="title"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;运行时数据区域包括程序计数器，java虚拟机栈，本地方法栈，方法区和堆。其中，java虚拟机栈，本地方法栈，程序计数器是每个线程私有的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字节码文件经过类加载子系统从静态存储结构转化为方法区的运行时内存结构。&lt;/strong&gt;运行时数据区域包括程序计数器，java虚拟机栈，本地方法栈，方法区和堆。其中，java虚拟机栈，本地方法栈，程序计数器是每个线程私有的，方法区以及堆是所有线程共享的。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>面向对象概述</title>
    <link href="http://yoursite.com/2019/09/19/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2019/09/19/面向对象概述/</id>
    <published>2019-09-19T08:27:06.000Z</published>
    <updated>2019-09-30T05:37:29.619Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象有三大特性：</p><ul><li>封装。只对外提供接口由外界访问。</li><li>继承。</li><li>多态。多态的三个条件：继承，重写，以及向上转型（父类引用指向子类对象）。</li></ul><a id="more"></a><h2 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h2><p>private:除了自己没有其他任何类可以访问。<br>protected:同一包下的，以及自己的自类可以访问。<br>default：同一包下面的。<br>public：任何类都可以访问。</p><h2 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h2><p>重写：override，重新实现父类的方法。发生在运行期，动态分派。<br>重载：方法名称相同，参数不同。返回值类型不同，参数类型相同不算是重载。发生在编译器，静态分派。</p><h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>使用abstract关键字声明，且抽象类<strong>至少应该包含一个抽象方法</strong>(只有声明没有实现)。</p><p><strong>抽象类不可以被实例化</strong>。</p><p>抽象方法不能是private，这样方法就不能继承了。抽象类不能是final的。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>在JDK8之前，没有任何方法的实现。从JDK8之后，<strong>接口也可以有默认方法的实现</strong>。</p><p>接口的成员都只能是public的。</p><p>接口的字段是public static final的，因此，接口字段一旦定义就不可以改了。</p><p>但是，在JDK1.8之后，interface加了一些新的特性。</p><ul><li>可以添加静态方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello world!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可以为接口方法提供一个默认实现。使用default标记。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">myNewName</span><span class="params">(String newName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">myOldName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"chao"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>类只可以继承一个抽象类，却可以实现多个接口。</li><li>接口字段是static final的，不可以再去修改的，而抽象类却没有这种要求。</li><li>接口成员是public的，抽象类却没有这种要求。</li></ul><h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><h4 id="关于构造方法"><a href="#关于构造方法" class="headerlink" title="关于构造方法"></a>关于构造方法</h4><p>当new一个子类的时候，一定会先调用父类的构造方法，然后再去调用子类的构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"parent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"son"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son son = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：parent</span></span><br><span class="line"><span class="comment">     son</span></span><br><span class="line"><span class="comment">也就是说。当构造一个子类的时候，一定会先调用父类的构造方法。默认是调用父类无参的构造函数，若是想调用其它构造函数，可以通过super关键字实现。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>既然创建子类对象的时候，一定会先调用父类的构造方法，那么是否创建了父类呢？</p><p>答案是没有。</p><p><img src="https://img-blog.csdn.net/20170730101144951?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWluaW11bV9UaW1lX0hvdXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="è¿éåå¾çæè¿°"></p><p>只是创建了一个子类对象，<strong>this完全引用这个子类对象，super引用子类可以继承的成员变量以及方法</strong>。</p><h4 id="super作用"><a href="#super作用" class="headerlink" title="super作用"></a>super作用</h4><ul><li><p>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super 函数。</p></li><li><p>访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。</p></li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>在一个类中再定义一个类。</p><h3 id="内部类的好处"><a href="#内部类的好处" class="headerlink" title="内部类的好处"></a>内部类的好处</h3><ul><li><p>内部类可以访问外部类的所有成员，包括private。</p><p>为什么内部类可以随意访问外部类的成员？</p><p>持有引用。当外部类的对象创建了一个内部类的对象时，<strong>内部类对象必定会秘密捕获一个指向外部类对象的引用</strong>，然后访问外部类的成员时，就是用那个引用来选择外围类的成员的。当然这些编辑器已经帮我们处理了。</p></li><li><p>内部类可以对外隐藏。</p></li><li><p>可以实现多重继承。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类一</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"liutao"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">doSomeThing</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// doSomeThing</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类二</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">age</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">25</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类三</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainExample</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> <span class="keyword">extends</span> <span class="title">ClassA</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">super</span>.name();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> <span class="keyword">extends</span> <span class="title">ClassB</span></span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">age</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">super</span>.age();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Test1().name();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">age</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Test2().age();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">       MainExample mi=<span class="keyword">new</span> MainExample();</span><br><span class="line">       System.out.println(<span class="string">"姓名:"</span>+mi.name());</span><br><span class="line">       System.out.println(<span class="string">"年龄:"</span>+mi.age());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="内部类与外部类的关系"><a href="#内部类与外部类的关系" class="headerlink" title="内部类与外部类的关系"></a>内部类与外部类的关系</h3><ul><li>对于非静态内部类，内部类的创建依赖外部类的实例对象，在没有外部类实例之前是无法创建内部类的。先有外部类对象，再有内部类对象。</li><li>对于静态内部类，内部类并不依赖于外部类对象的创建，static依赖于类本身，并不依赖类实例对象。</li><li>普通内部类不可以有静态成员，因为普通内部类需要依赖于外部对象而存在，需要outer.new InnerClass();，他是与对象相关的。</li><li>静态可以访问静态的，不可以访问非静态的；非静态静态和非静态都可以访问。所以，静态内部类不可以访问外部类非静态成员。</li></ul><h3 id="内部类创建"><a href="#内部类创建" class="headerlink" title="内部类创建"></a>内部类创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassOuter outer = <span class="keyword">new</span> ClassOuter();</span><br><span class="line">ClassOuter.InnerClass inner = outer.new InnerClass();</span><br></pre></td></tr></table></figure><h3 id="普通内部类"><a href="#普通内部类" class="headerlink" title="普通内部类"></a>普通内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassA</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类对象可以访问外部类对象中所有访问权限的字段，同时，外部类对象也可以通过内部类的对象引用来访问内部类中定义的所有访问权限的字段。</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类<strong>就像外部类的一个静态成员</strong>一样，创建其对象无需依赖外部类对象（访问一个类的静态成员也无需依赖这个类的对象，因为它是独立于所有类的对象的）。但是于此同时，<strong>静态内部类中也无法访问外部类的非静态成员</strong>，因为外部类的非静态成员是属于每一个外部类对象的，而本身静态内部类就是独立外部类对象存在的，所以静态内部类不能访问外部类的非静态成员，而外部类依然可以访问静态内部类对象的所有访问权限的成员，这一点和普通内部类无异。</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> field1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> field2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> field3 = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> field4 = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerClassTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建 "</span> + <span class="keyword">this</span>.getClass().getSimpleName() + <span class="string">" 对象"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">anonymousClassTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在这个过程中会新建一个匿名内部类对象，</span></span><br><span class="line">        <span class="comment">// 这个匿名内部类实现了 OnClickListener 接口并重写 onClick 方法</span></span><br><span class="line">        OnClickListener clickListener = <span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">        <span class="comment">// 可以在内部类中定义属性，但是只能在当前内部类中使用，</span></span><br><span class="line">        <span class="comment">// 无法在外部类中使用，因为外部类无法获取当前匿名内部类的类名，</span></span><br><span class="line">        <span class="comment">// 也就无法创建匿名内部类的对象</span></span><br><span class="line">        <span class="keyword">int</span> field = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"对象 "</span> + obj + <span class="string">" 被点击"</span>);</span><br><span class="line">                System.out.println(<span class="string">"其外部类的 field1 字段的值为: "</span> + field1);</span><br><span class="line">                System.out.println(<span class="string">"其外部类的 field2 字段的值为: "</span> + field2);</span><br><span class="line">                System.out.println(<span class="string">"其外部类的 field3 字段的值为: "</span> + field3);</span><br><span class="line">                System.out.println(<span class="string">"其外部类的 field4 字段的值为: "</span> + field4);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// new Object() 过程会新建一个匿名内部类，继承于 Object 类，</span></span><br><span class="line">        <span class="comment">// 并重写了 toString() 方法</span></span><br><span class="line">        clickListener.onClick(<span class="keyword">new</span> Object() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"obj1"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InnerClassTest outObj = <span class="keyword">new</span> InnerClassTest();</span><br><span class="line">        outObj.anonymousClassTest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名内部类中可以使用外部类的属性，但是外部类却不能使用匿名内部类中定义的属性，因为是匿名内部类，因此在外部类中无法获取这个类的类名，也就无法得到属性信息。</p><p>当匿名内部类访问局部变量的时候，局部变量必须是final的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Button</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> params)</span></span>&#123;</span><br><span class="line">        <span class="comment">//匿名内部类，实现的是ActionListener接口</span></span><br><span class="line">        <span class="keyword">new</span> ActionListener()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAction</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"click action..."</span> + params);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.onAction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//匿名内部类必须继承或实现一个已有的接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ActionListener</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAction</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Button button=<span class="keyword">new</span> Button();</span><br><span class="line">        button.click();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因是：因为局部变量和匿名内部类的生命周期不同。</p><p>匿名内部类是创建后是存储在堆中的，而方法中的局部变量是存储在Java栈中，当方法执行完毕后，就进行退栈，同时局部变量也会消失。那么此时匿名内部类还有可能在堆中存储着，那么匿名内部类要到哪里去找这个局部变量呢？</p><p>为了解决这个问题编译器为自动地帮我们在匿名内部类中创建了一个局部变量的备份，也就是说即使方法执结束，匿名内部类中还有一个备份，自然就不怕找不到了。</p><p>但是问题又来了。如果局部变量中的a不停的在变化。那么岂不是也要让备份的a变量无时无刻的变化。为了保持局部变量与匿名内部类中备份域保持一致。编译器不得不规定死这些局部域必须是常量，一旦赋值不能再发生变化了。所以为什么匿名内部类应用外部方法的域必须是常量域的原因所在了。</p><p>特别注意：<strong>在Java8中已经去掉要对final的修饰限制，但其实只要在匿名内部类使用了，该变量还是会自动变为final类型（只能使用，不能赋值）。</strong></p><h3 id="内部类导致内存泄漏"><a href="#内部类导致内存泄漏" class="headerlink" title="内部类导致内存泄漏"></a>内部类导致内存泄漏</h3><ul><li><p>如果一个匿名内部类没有被任何引用持有，那么匿名内部类对象用完就有机会被回收。</p></li><li><p>如果内部类仅仅只是在外部类中被引用，当外部类的不再被引用时，外部类和内部类就可以都被GC回收。</p></li><li><p>如果当内部类的引用被外部类以外的其他类引用时，就会造成内部类和外部类无法被GC回收的情况，即使外部类没有被引用，因为内部类持有指向外部类的引用）。</p></li></ul><p>所以，内部类内存泄露的原因就是<strong>有外部类以外的其他引用，这样内部类和外部类都无法被回收</strong>。</p><p>可以通过使用<strong>静态内部类</strong>来解决。</p><p><a href="https://juejin.im/post/5a903ef96fb9a063435ef0c8" target="_blank" rel="noopener">分析内部类</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面向对象有三大特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;封装。只对外提供接口由外界访问。&lt;/li&gt;
&lt;li&gt;继承。&lt;/li&gt;
&lt;li&gt;多态。多态的三个条件：继承，重写，以及向上转型（父类引用指向子类对象）。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>java 基础</title>
    <link href="http://yoursite.com/2019/09/18/java-%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/09/18/java-基础/</id>
    <published>2019-09-18T01:42:28.000Z</published>
    <updated>2019-09-30T05:40:14.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><h3 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 装箱 调用了 Integer.valueOf(2)，将int变成了一个Integer对象</span></span><br><span class="line">Integer x = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>装箱转换是指将一个值类型隐式地转换成一个object 类型，也就是创建一个object 实例并将这个值复制给这个object。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/09/30/1569821993294-1569821993678.png" alt="title"></p><a id="more"></a><h3 id="拆箱"><a href="#拆箱" class="headerlink" title="拆箱"></a>拆箱</h3><p>拆箱转换是指将一个对象类型显式地转换成一个值类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="number">2</span>;     <span class="comment">//装箱</span></span><br><span class="line"><span class="keyword">int</span> y = x;         <span class="comment">// 拆箱 调用了 X.intValue()</span></span><br></pre></td></tr></table></figure><p>装箱和拆箱会造成相当大的性能损耗，因此尽量应该避免大量的装箱拆箱操作。</p><h3 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h3><p>new Integer()与Integer.Valueof()区别：</p><ul><li>new Integer每次都会新建一个对象</li><li>Integer.Valueof()会复用缓存池中的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false</span></span><br><span class="line">Integer z = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">Integer k = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>编译器会在<strong>自动装箱过程调用 valueOf() 方法</strong>，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a = b</span></span><br><span class="line">Integer a = <span class="number">123</span>;</span><br><span class="line">Integer b = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>基本类型的变量数据都是存在栈中的，String常量放在常量池里面，String对象放在堆里面。</p><h3 id="String常量"><a href="#String常量" class="headerlink" title="String常量"></a>String常量</h3><p>String常量存放在常量池里面，常量池中相同的值只有一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="string">"hello"</span>;</span><br><span class="line">String s2=<span class="string">"hello"</span>;</span><br><span class="line">System.out.println(s1==s2);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><ul><li>第一句代码执行后就在常量池中创建了一个值为hello的String对象；</li><li>第二句执行时，因为常量池中存在hello所以就不再创建新的String对象了。</li><li>此时该字符串的引用在虚拟机栈里面。</li><li>因为s1和s2指向的是同一个对象，所以s1==s2</li></ul><h3 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h3><p><strong>String对象的本质是一个不可变的char数组</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="keyword">new</span> String(<span class="string">"skj"</span>);</span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">"skj"</span>);</span><br><span class="line">System.out.println(a==b);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>new String(“skj”)这一步到底做了什么？</p><ul><li>在字符串常量池里面创建一个对象，就是”skj”,首先会检查常量池里面有没有这个对象”skj”，没有的话在创建并返回对象的引用，有的话就直接返回这个对象的引用。</li><li>在堆上创建一个对象， new String，String对象的本质就是一个char数组，所以String对象中的char数组指向之前返回对象的引用</li><li>所以，new String(“skj”)这一句实际上是创建了两个对象，一个在字符串常量池，一个在堆上。</li></ul><h3 id="String特性"><a href="#String特性" class="headerlink" title="String特性"></a>String特性</h3><blockquote><p>Strings are constant; their values cannot be changed after they are created. String buffers support mutable strings. Because String objects are immutable they can be shared.</p></blockquote><ul><li>String是不可变的，因为String的本质是一个final char[]，所以String同时又是线程安全的。</li><li>String由final修饰，是不可以继承的。</li></ul><h3 id="字符串拼接问题"><a href="#字符串拼接问题" class="headerlink" title="字符串拼接问题"></a>字符串拼接问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str0 = <span class="string">"a"</span>;</span><br><span class="line">String str1 = str0 + <span class="string">"b"</span>;</span><br></pre></td></tr></table></figure><p>编译成字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #2 // String a</span><br><span class="line">       <span class="number">2</span>: astore_1</span><br><span class="line">       3: new           #3 // class java/lang/StringBuilder</span><br><span class="line">       <span class="number">6</span>: dup</span><br><span class="line">       7: invokespecial #4 // Method java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">      <span class="number">10</span>: aload_1</span><br><span class="line">      11: invokevirtual #5 // Method java/lang/StringBuilder.append(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      14: ldc           #6 // String b</span><br><span class="line">      16: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      19: invokevirtual #7 // Method java/lang/StringBuilder.toString()Ljava/lang/String;</span><br><span class="line">      <span class="number">22</span>: astore_2</span><br><span class="line">      <span class="number">23</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换成java就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str0 = <span class="string">"a"</span>;</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">sb.append(str0).append(<span class="string">"b"</span>);</span><br><span class="line">String str1 = sb.toString();</span><br><span class="line"><span class="keyword">return</span> str1;</span><br></pre></td></tr></table></figure><p>所以，<strong>字符串的拼接主要是通过StringBuilder来实现的</strong>。</p><p>要注意的是最后还有toString，<strong>返回的是一个String对象</strong>。</p><p>为什么返回的是一个新的String对象呢？</p><p>因为String类的<strong>char数组是final的</strong>，他的指针一旦指向了常量池的某个String，就不可以再改变了.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str0 = <span class="string">"a"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;    </span><br><span class="line">      str0 += <span class="string">"a"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在循环体中进行字符串拼接，在循环体里面，每次拼接都会生成一个StringBuilder的临时对象，那么这个程序片段执行下去就会产生10000个StringBuilder的临时对象，这10000个临时对象都是必要的吗？显然不是，我们可以在循环体外直接创建一个StringBuilder对象，然后在循环体中通过append方法拼接字符串，这样就省下了创建并回收10000个临时对象的消耗。 </p><p>因此，当我们大量使用字符串拼接的时候，还是使用StringBuilder比较好。</p><h4 id="拼接示例"><a href="#拼接示例" class="headerlink" title="拼接示例"></a>拼接示例</h4><ul><li>使用字符串连接符拼接 ： String s2=”se”+”cond”;</li><li>使用字符串加引用拼接 ： String s12=”first”+s2;</li><li>使用new String(“”)创建 ： String s3 = new String(“three”);</li><li>使用new String(“”)拼接 ： String s4 = new String(“fo”)+”ur”;</li><li>使用new String(“”)拼接 ： String s5 = new String(“fo”)+new String(“ur”);</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC8xLzUvMTYwYzNkZDRiZTM3NzIwYz9pbWFnZXNsaW0?x-oss-process=image/format,png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><ul><li>s2 ：这个在<strong>编译期间就自动进行了优化的</strong>，在常量池中存储一个”second”，并且s2指向它。</li><li>s12 ： JVM对于字符串引用，由于在字符串的”+”连接中，有字符串引用存在，而引用的值在程序编译期是无法确定的，即<code>(&quot;first&quot;+s2)</code>无法被编译器优化，只有在程序运行期来动态分配使用<code>StringBuilder</code>连接后的新String对象赋给s12。<br>(编译器创建一个<code>StringBuilder</code>对象，并调用<code>append()</code>方法，最后调用<code>toString()</code>创建新<code>String</code>对象，以包含修改后的字符串内容)，常量池中并没有产生新的字符串常量。</li><li>s3 ： 用new String() 创建的字符串不是常量，不能在编译期就确定，所以new String() 创建的字符串不放入常量池中，它们有自己的地址空间。<br>但是”three”字符串常量在编译期也会被加入到字符串常量池（如果不存在的话）</li><li>s4 ： 同样不能在编译期确定，但是”fo”和”ur”这两个字符串常量也会添加到字符串常量池中，并且在堆中创建String对象。（字符串常量池并不会存放”four”这个字符串）</li><li>s5 ： 原理同s4。</li></ul><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>String的内部实现是一个用final的数组，因此String对象是不可变的，我们每次修改String时，实际上都是new出来了一个新的对象。因此，对于经常进行字符串的修改操作时，String类就需要不断创建新对象，性能极低。StringBuilder内部也是封装的一个字符数组，<strong>只不过该数组非final修饰</strong>，可以不断修改。所以对于一些经常需要<strong>修改字符串的情况，我们应首选StringBuilder</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The count is the number of characters used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure><h4 id="append"><a href="#append" class="headerlink" title="append()"></a>append()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            value = Arrays.copyOf(value,</span><br><span class="line">                    newCapacity(minimumCapacity));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，当StringBuilder添加元素的时候，首先判断char[]是否满了，要是满了，Arrays.copyOf对数组进行扩容（返回的是一个新数组）。最后append的方法返回的this，也就是说，与String不同，他并没有创建一个新的对象，<strong>主要原因还是char[]不是final的，是可变的</strong>，他就可以转换新的指向。</p><h3 id="StringBuilder，StringBuffer，String区别"><a href="#StringBuilder，StringBuffer，String区别" class="headerlink" title="StringBuilder，StringBuffer，String区别"></a>StringBuilder，StringBuffer，String区别</h3><p>StringBuffer和StringBuilder都继承了抽象类AbstractStringBuilder，这个抽象类和String一样也定义了char[] value和int count，但是与String类不同的是，<strong>它们没有final修饰符</strong>。因此得出结论：String、StringBuffer和StringBuilder在本质上都是字符数组，不同的是，在进行连接操作时，String每次返回一个新的String实例，而StringBuffer和StringBuilder的append方法直接返回this，所以这就是为什么在进行大量字符串连接运算时，不推荐使用String，而推荐StringBuffer和StringBuilder。那么，哪种情况使用StringBuffe？哪种情况使用StringBuilder呢？ </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.append(str);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       toStringCache = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">super</span>.append(str);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>区别很明显，StringBuffer加了synchronized关键字，是线程安全的。</p><h3 id="为何String要设计成不可变的？"><a href="#为何String要设计成不可变的？" class="headerlink" title="为何String要设计成不可变的？"></a>为何String要设计成不可变的？</h3><ul><li>线程安全</li><li>字符串常量池的需要。字符串常量池的诞生是为了提升效率和减少内存分配。可以说我们编程有百分之八十的时间在处理字符串，而处理的字符串中有很大概率会出现重复的情况。正因为String的不可变性，常量池很容易被管理和优化。</li><li>字符串不变，HashCode也不变，便于缓存Hash Code，不需要重复计算HashCode。</li></ul><h3 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h3><p><strong>字符串常量池是在编译期间产生的，通过String的intern()也可以在运行时向字符串常量池放入字符串。</strong></p><blockquote><p> <em>When the intern method is invoked, if the pool already contains a string equal to this String object as determined by the equals(Object) method, then the string from the pool is returned. Otherwise, this String object is added to the pool and a reference to this String object is returned.</em> </p></blockquote><p>简单来说就是intern用来返回常量池中的某字符串，如果常量池中已经存在该字符串，则直接返回常量池中该对象的引用。否则，在常量池中加入该对象，然后 返回引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">    s.intern();</span><br><span class="line">    String s2 = <span class="string">"1"</span>;</span><br><span class="line">    System.out.println(s == s2);</span><br><span class="line"></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">    s3.intern();</span><br><span class="line">    String s4 = <span class="string">"11"</span>;</span><br><span class="line">    System.out.println(s3 == s4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">输出：false true</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><p>分析一下：</p><ul><li>先看s3和s4.<code>String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);</code>，这样，在字符串常量池创建了一个”1”，并且在堆里也创建了一个对象”11”，但在11中是没有对象的。<code>s3.intern()</code>，先去常量池看看有没有”11”，没有，需要在常量池中存储一份”11”，<strong>但是在jdk8中常量池已经转移到堆中了，所以可以直接存储堆中的引用</strong>(在jdk6之前，常量池还在perm区，就需要再在常量池中存储一份)。所以，s4实际上是指向堆上对象的引用。</li><li>再看s1和s2.<code>String s = new String(&quot;1&quot;);</code>在常量池内已经存储了1，所以s3.intern()啥也没做，s还是指向堆上的对象，s1指向的是常量池的对象。</li><li>所以，<code>String#intern</code> 方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象。</li></ul><p><a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html" target="_blank" rel="noopener">String#intern的使用</a></p><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>&amp;:按位与</p><p>|:按位或</p><p>~:异或</p><p>^:取反</p><p>&lt;&lt;:左移位运算，同理还有右移位运算。</p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>数据：<strong>声明数据为常量</strong>，一旦初始化之后及不可以改变。</p><p>方法：声明方法不可以被重写。</p><p>类：声明类不可以被继承。</p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>静态变量：类变量，这个变量是属于这个类的，类的所有实例共享，<strong>在内存中只存在一份</strong>。</p><p>静态方法：他在类加载的时候就存在了，它不依赖于任何实例，所以static方法必须实现。</p><p>static代码块：在类初始化的时候执行一次。</p><p>静态成员不可以访问非静态成员，非静态成员可以访问静态成员和非静态成员。</p><h2 id="Object方法"><a href="#Object方法" class="headerlink" title="Object方法"></a>Object方法</h2><h3 id="equals-and-hashCode"><a href="#equals-and-hashCode" class="headerlink" title="equals() and hashCode()"></a>equals() and hashCode()</h3><p>hashcode()返回的是散列值，equals()用来判断两个对象是否等价，所以在重写equals()方法时一定要先重写hashcode()。等价的对象散列值一定相同，但是散列值相同对象不一定等价。</p><h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><p>需要<strong>实现Clonable接口并重写clone()方法</strong>，才可以实现拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>拷贝这个对象的时候，只对基本数据类型进行拷贝，而引用数据类型只是进行了引用的传递，这两个对象还是共享的引用数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShallowCloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShallowCloneExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ShallowCloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ShallowCloneExample) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ShallowCloneExample e1 = <span class="keyword">new</span> ShallowCloneExample();</span><br><span class="line">ShallowCloneExample e2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 222,e1修改了，e2也变了，说明两人引用的是同一个对象</span></span><br></pre></td></tr></table></figure><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>在对引用数据类型拷贝的时候，创建了一个新的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepCloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeepCloneExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DeepCloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        DeepCloneExample result = (DeepCloneExample) <span class="keyword">super</span>.clone();</span><br><span class="line">        result.arr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            result.arr[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DeepCloneExample e1 = <span class="keyword">new</span> DeepCloneExample();</span><br><span class="line">DeepCloneExample e2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>但是，一般来说，不推荐使用clone，可以使用拷贝构造函数来做。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneConstructorExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CloneConstructorExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CloneConstructorExample</span><span class="params">(CloneConstructorExample original)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[original.arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; original.arr.length; i++) &#123;</span><br><span class="line">            arr[i] = original.arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CloneConstructorExample e1 = <span class="keyword">new</span> CloneConstructorExample();</span><br><span class="line">CloneConstructorExample e2 = <span class="keyword">new</span> CloneConstructorExample(e1);</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</p><p>当我们的程序在运行时，需要动态的加载一些类这些类可能之前用不到所以不用加载到jvm，而是<strong>在运行时根据需要才加载</strong>，这样的好处对于服务器来说不言而喻。</p><p>举个例子我们的项目底层有时是用mysql，有时用oracle，需要动态地根据实际情况加载驱动类，这个时候反射就有用了，假设 com.java.dbtest.myqlConnection，com.java.dbtest.oracleConnection这两个类我们要用，这时候我们的程序就写得比较动态化，通过Class tc = Class.forName(“com.java.dbtest.TestConnection”);通过类的全类名让jvm在服务器中找到并加载这个类，而如果是oracle则传入的参数就变成另一个了。</p><h3 id="反射使用"><a href="#反射使用" class="headerlink" title="反射使用"></a>反射使用</h3><h4 id="获取class对象"><a href="#获取class对象" class="headerlink" title="获取class对象"></a>获取class对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class s = Class.forName(<span class="string">"java.lang.String"</span>);</span><br></pre></td></tr></table></figure><h4 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.newInstance();</span><br></pre></td></tr></table></figure><h4 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取类或接口生命的方法，但不包括继承的方法</span></span><br><span class="line"><span class="keyword">public</span> Method[] getDeclaredMethods() <span class="keyword">throws</span> SecurityException</span><br><span class="line"><span class="comment">//获取公有方法</span></span><br><span class="line"><span class="keyword">public</span> Method[] getMethods() <span class="keyword">throws</span> SecurityException</span><br><span class="line"><span class="comment">//获取特定的方法，根据参数方法名以及参数类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></span><br></pre></td></tr></table></figure><h4 id="获取变量信息"><a href="#获取变量信息" class="headerlink" title="获取变量信息"></a>获取变量信息</h4><ul><li><code>getFiled</code>：访问公有的成员变量</li><li><code>getDeclaredField</code>：所有已声明的成员变量，但不能得到其父类的成员变量</li></ul><h4 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h4><p>通过invoke</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; klass = methodClass.class;</span><br><span class="line">        <span class="comment">//创建methodClass的实例</span></span><br><span class="line">        Object obj = klass.newInstance();</span><br><span class="line">        <span class="comment">//获取methodClass类的add方法</span></span><br><span class="line">        Method method = klass.getMethod(<span class="string">"add"</span>,<span class="keyword">int</span>.class,<span class="keyword">int</span>.class);</span><br><span class="line">        <span class="comment">//调用method对应的方法 =&gt; add(1,4)</span></span><br><span class="line">        Object result = method.invoke(obj,<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问私有方法和私有变量"><a href="#访问私有方法和私有变量" class="headerlink" title="访问私有方法和私有变量"></a>访问私有方法和私有变量</h4><p>甚至可以通过反射访问私有成员。</p><p>只需要setAccessible(true)即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modifyPrivateFiled</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取 Class 类实例</span></span><br><span class="line">    TestClass testClass = <span class="keyword">new</span> TestClass();</span><br><span class="line">    Class mClass = testClass.getClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 获取私有变量</span></span><br><span class="line">    Field privateField = mClass.getDeclaredField(<span class="string">"MSG"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 操作私有变量</span></span><br><span class="line">    <span class="keyword">if</span> (privateField != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取私有变量的访问权</span></span><br><span class="line">        privateField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改私有变量，并输出以测试</span></span><br><span class="line">        System.out.println(<span class="string">"Before Modify：MSG = "</span> + testClass.getMsg());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用 set(object , value) 修改变量的值</span></span><br><span class="line">        <span class="comment">//privateField 是获取到的私有变量</span></span><br><span class="line">        <span class="comment">//testClass 要操作的对象</span></span><br><span class="line">        <span class="comment">//"Modified" 为要修改成的值</span></span><br><span class="line">        privateField.set(testClass, <span class="string">"Modified"</span>);</span><br><span class="line">        System.out.println(<span class="string">"After Modify：MSG = "</span> + testClass.getMsg());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://juejin.im/post/598ea9116fb9a03c335a99a4" target="_blank" rel="noopener">反射机制</a></p><p><a href="https://www.sczyh30.com/posts/Java/java-reflection-1/" target="_blank" rel="noopener">深入解析Java反射</a></p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>Exception可以通过try catch处理并且使程序恢复。</p><p>Error是程序运行时错误，程序会崩溃并且无法恢复。</p><p>   <img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/PPjwP.png" alt="img"></p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型就是<strong>参数化类型</strong>，在泛型使用过程中，操作类型的数据类型被定义为一个参数。</p><p>泛型最常见的使用是在容器中，我们给容器添加泛型，这样我们可以把所需要的类型作为参数传递给容器，这样，容器就可以接受所有类型的数据，而且同时只能是一个数据，保证了程序的健壮性。</p><p>泛型主要有泛型类，泛型接口，泛型方法。</p><p>在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123; </span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定  </span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataHolder</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    T item;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.item=t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛型方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">PrinterInfo</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>public 与返回值中间的E声明这是一个泛型方法，只有声明了才可以使用泛型</li><li>没有声明，只是传参的时候使用了泛型，并不是一个泛型方法。</li><li>与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个泛型类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericClassDemo</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个不是泛型方法，只是使用了泛型类中已声明的T</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        System.out.println(t.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</span></span><br><span class="line"><span class="comment">     * 由于下面的泛型方法在声明的时候声明了泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，</span></span><br><span class="line"><span class="comment">     * 编译器也能够正确识别泛型方法中识别的泛型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">show2</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        System.out.println(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型;</span></span><br><span class="line"><span class="comment">     * 可以与泛型类中声明的T不是同一种类型。</span></span><br><span class="line"><span class="comment">     * show3和show2的E和T只是简单的代指泛型,与泛型类中的T并不是一个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show3</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        System.out.println(t.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; integerArrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">Class classStringArrayList = stringArrayList.getClass();</span><br><span class="line">Class classIntegerArrayList = integerArrayList.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(classStringArrayList.equals(classIntegerArrayList))&#123;</span><br><span class="line">    System.out.println(<span class="string">"----equals----"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：----equals----</span></span><br></pre></td></tr></table></figure><p>通过上面的例子可以证明，在<strong>编译之后程序会采取去泛型化的措施</strong>。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段</p><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><h4 id="上界通配符"><a href="#上界通配符" class="headerlink" title="上界通配符"></a>上界通配符</h4><pre><code>&lt;? extends T&gt;,只能放置T以及T的子类。</code></pre><h4 id="下界通配符"><a href="#下界通配符" class="headerlink" title="下界通配符"></a>下界通配符</h4><pre><code>&lt;? superT&gt;,只能防止T以及T的父类。</code></pre><h4 id="无界通配符"><a href="#无界通配符" class="headerlink" title="无界通配符"></a>无界通配符</h4><pre><code>&lt;?&gt; ,没有要求。</code></pre><p><a href="https://juejin.im/post/5b614848e51d45355d51f792#comment" target="_blank" rel="noopener">深入理解泛型</a></p><p><a href="https://www.cnblogs.com/coprince/p/8603492.html" target="_blank" rel="noopener">泛型详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;包装类型&quot;&gt;&lt;a href=&quot;#包装类型&quot; class=&quot;headerlink&quot; title=&quot;包装类型&quot;&gt;&lt;/a&gt;包装类型&lt;/h2&gt;&lt;h3 id=&quot;装箱&quot;&gt;&lt;a href=&quot;#装箱&quot; class=&quot;headerlink&quot; title=&quot;装箱&quot;&gt;&lt;/a&gt;装箱&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 装箱 调用了 Integer.valueOf(2)，将int变成了一个Integer对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Integer x = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;装箱转换是指将一个值类型隐式地转换成一个object 类型，也就是创建一个object 实例并将这个值复制给这个object。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/09/30/1569821993294-1569821993678.png&quot; alt=&quot;title&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>DirectIO和PageCache</title>
    <link href="http://yoursite.com/2019/09/11/DirectIO%E5%92%8CPageCache/"/>
    <id>http://yoursite.com/2019/09/11/DirectIO和PageCache/</id>
    <published>2019-09-11T11:16:26.000Z</published>
    <updated>2019-09-30T06:07:35.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PageCache"><a href="#PageCache" class="headerlink" title="PageCache"></a>PageCache</h1><p>PageCache一页有4KB左右。</p><p>当需要写入磁盘的时候，若每写入一个字节数据就调用IO，这样效率就太低了，所以在操作系统的底层会有一个缓冲区，叫做PageCache，当PageCache中存满了，再写入磁盘，这样大大减少了磁盘IO的次数。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/09/11/1568203557001-1568203557007.png" alt="title"></p><p>上图是写入磁盘的过程，我们使用MMap或者是FileChannel都会经过PageCache层。例如，我们使用FileChannel的时候，先写进DirectByteBuffer中，当buffer中数据满的时候，先写入PageCache，再写入磁盘。</p><p>同样的，读取数据也是一样的，将数据以及其邻近的一些数据读取到PageCache。</p><p>例如，当用户发起一个 fileChannel.read(4kb) 之后，实际发生了两件事</p><ol><li>操作系统从磁盘加载了 16kb 进入 PageCache，这被称为预读</li><li>操作通从 PageCache 拷贝 4kb 进入用户内存</li></ol><p>最终我们在用户内存访问到了 4kb，为什么顺序读快？很容量想到，当用户继续访问接下来的[4kb,16kb]的磁盘内容时，便是直接从 PageCache 去访问了。试想一下，当需要访问 16kb 的磁盘内容时，是发生4次磁盘 IO 快，还是发生1次磁盘 IO+4 次内存 IO 快呢？答案是显而易见的，这一切都是 PageCache 带来的优化。</p><h1 id="DirectIO"><a href="#DirectIO" class="headerlink" title="DirectIO"></a>DirectIO</h1><p>虽然PageCache很好，但是我们有时候并不希望使用PageCache。</p><ul><li><p>当我们有时候进行随即读的时候，其实有时候并不需要PageCache的预读。</p></li><li><p>PageCache是操作系统层面上的概念，用很难干预，User BufferCache显然比PageCache要可控的多。</p></li><li><p>当操作系统回收 PageCache 内存的速度低于应用写缓存的速度时，会影响磁盘写入的速率，直接表现为写入 RT 增大，这被称之为“毛刺现象”。</p></li></ul><p>而DirectIO可以绕过PageCache。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PageCache&quot;&gt;&lt;a href=&quot;#PageCache&quot; class=&quot;headerlink&quot; title=&quot;PageCache&quot;&gt;&lt;/a&gt;PageCache&lt;/h1&gt;&lt;p&gt;PageCache一页有4KB左右。&lt;/p&gt;
&lt;p&gt;当需要写入磁盘的时候，若每写入一
      
    
    </summary>
    
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>零拷贝的问题</title>
    <link href="http://yoursite.com/2019/09/11/%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/09/11/零拷贝的问题/</id>
    <published>2019-09-11T06:58:30.000Z</published>
    <updated>2019-09-30T06:13:44.300Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="传统的IO的操作"><a href="#传统的IO的操作" class="headerlink" title="传统的IO的操作"></a>传统的IO的操作</h1><h2 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h2><p>缓冲技术是IO的基础，一次读取大量数据放在缓冲区，需要的时候从缓冲区取得数据。</p><p>详细可见：<a href="https://www.cnblogs.com/JohnABC/p/5821660.html" target="_blank" rel="noopener">内核缓冲区问题</a></p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/09/11/1568190754018-1568190754316.png" alt="title"></p><p>一个完整的read操作：当应用程序发起read请求后，会检查内核空间内是否有需要读取的数据（pageCache）,如果有，直接copy到用户空间；如果没有，那么需要从磁盘读取，磁盘控制器<strong>通过DMA操作将数据从磁盘读取到内核空间，然后才从内核空间拷贝到用户空间</strong>。</p><p>DMA：不需要通过CPU调度，由DMA控制器来处理，不需要麻烦CPU。</p><h2 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h2><p>使用传统的I/O程序读取文件内容, 并写入到另一个文件(或Socket)。<br>性能开销比较大：</p><ul><li>上下文切换(context switch), 此处<strong>有4次用户态和内核态的切换</strong></li><li>Buffer<strong>内存开销</strong>, 一个是应用程序buffer, 另一个是系统读取buffer以及socket buffer。</li><li>需要进行<strong>四次拷贝</strong>，2次DMA copy和两次CPU copy。<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/07/15/1563196128657-1563196128663.png" alt="title"><br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/07/15/1563196409757-1563196409765.png" alt="title"><br>传统IO四次内容拷贝：</li><li>先将文件内容从磁盘中拷贝到操作系统buffer</li><li>再从操作系统buffer拷贝到程序应用buffer</li><li>从程序buffer拷贝到socket buffer</li><li>从socket buffer拷贝到协议引擎.<h1 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h1></li></ul><h2 id="MMap"><a href="#MMap" class="headerlink" title="MMap"></a>MMap</h2><p>将物理内存映射到虚拟内存中。</p><p>在mmap之后，并没有在将文件内容加载到物理页上，只上在虚拟内存中分配了地址空间。当进程在访问这段地址时，若<strong>虚拟内存对应的page没有在物理内存中缓存，则产生”缺页”，将相应的页面载入物理内存</strong>。</p><p><strong>mmap()会返回一个指针ptr，它指向进程逻辑地址空间中的一个地址</strong>，这样以后，进程无需再调用read或write对文件进行读写，<strong>而只需要通过ptr就能够操作文件。但是ptr所指向的是一个逻辑地址，要操作其中的数据，必须通过MMU将逻辑地址转换成物理地址</strong>，若MMU没有相应的映射，产生缺页中断，将页面重新置入内存。</p><p>省去了从内核缓冲区复制到用户空间的过程，只有从磁盘调入到物理内存的过程。<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/07/15/1563201304883-1563201304890.png" alt="title"><br>它的最终目的是将磁盘中的文件映射到用户进程的虚拟地址空间，实现用户进程对文件的直接读写，减少了文件复制的开销，提高了用户的访问效率。<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/07/15/1563201505296-1563201505300.png" alt="title"></p><p>mmap+write<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/07/15/1563201645767-1563201645775.png" alt="title"><br>如何映射，见<a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html" target="_blank" rel="noopener">更多细节</a>。</p><h2 id="sendFile"><a href="#sendFile" class="headerlink" title="sendFile"></a>sendFile</h2><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/07/15/1563197393350-1563197393357.png" alt="title"><br>拷贝过程：</p><ul><li>首先通过DMA copy将数据从磁盘读取到kernel buffer中</li><li>然后通过CPU copy将数据从kernel buffer copy到sokcet buffer中</li><li>最终通过DMA copy将socket buffer中数据copy到网卡buffer中发送<br>sendfile与read/write方式相比，少了一次复制，少了两次上下文切换。<h3 id="改进后的sendFile"><a href="#改进后的sendFile" class="headerlink" title="改进后的sendFile"></a>改进后的sendFile</h3>sendFile中间copy到socket buffer这一步仍是多余的。<br>改进后的：<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/07/15/1563197595055-1563197595060.png" alt="title"><br>拷贝过程：</li><li>DMA copy将磁盘数据copy到kernel buffer中</li><li>向socket buffer中追加当前要发送的数据在kernel buffer中的位置和偏移量</li><li>DMA gather copy根据socket buffer中的位置和偏移量直接将kernel buffer中的数据copy到网卡上。</li></ul><p><strong>改进后的只有两次复制了</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;传统的IO的操作&quot;&gt;&lt;a href=&quot;#传统的IO的操作&quot; class=&quot;headerlink&quot; title=&quot;传统的IO的操作&quot;&gt;&lt;/a&gt;传统的IO的操作&lt;/h1&gt;&lt;h2 id=&quot;读操作&quot;&gt;&lt;a href=&quot;#读操作&quot; cla
      
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>java nio操作实践</title>
    <link href="http://yoursite.com/2019/07/26/java-nio%E6%93%8D%E4%BD%9C%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2019/07/26/java-nio操作实践/</id>
    <published>2019-07-26T08:50:52.000Z</published>
    <updated>2019-09-20T06:27:43.432Z</updated>
    
    <content type="html"><![CDATA[<p>java文件中文件IO主要包括普通IO，FileChannel以及MMap。本文主要介绍<strong>FileChannel以及MMap</strong>的一些原理以及使用，理解他们最好需要了解有关pageCache，内存零拷贝，堆外缓存的一些知识。</p><p>有关pageCache可见 <a href="https://gallonskj.github.io/2019/09/11/DirectIO%E5%92%8CPageCache/" target="_blank" rel="noopener">PageCache和DirectIO</a> ， 有关零拷贝可见 <a href="https://gallonskj.github.io/2019/09/11/%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">零拷贝问题</a> 。</p><a id="more"></a><h2 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取FileChannel</span></span><br><span class="line">FileChannel fileChannel = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">"db.data"</span>), <span class="string">"rw"</span>).getChannel();</span><br><span class="line"><span class="comment">//获取MMap</span></span><br><span class="line">MappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, filechannel.size());</span><br></pre></td></tr></table></figure><h2 id="FileChannel-写"><a href="#FileChannel-写" class="headerlink" title="FileChannel 写"></a>FileChannel 写</h2><p>``</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写</span></span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line"><span class="keyword">long</span> position = <span class="number">1024L</span>;</span><br><span class="line"><span class="comment">//指定 position 写入 data中 的数据</span></span><br><span class="line">fileChannel.write(ByteBuffer.wrap(data), position);</span><br><span class="line"><span class="comment">//从当前文件指针的位置写入 4kb 的数据</span></span><br><span class="line">fileChannel.write(ByteBuffer.wrap(data));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">4096</span>);</span><br><span class="line"><span class="keyword">long</span> position = <span class="number">1024L</span>;</span><br><span class="line"><span class="comment">//指定 position 读取 4kb 的数据到buffer</span></span><br><span class="line">fileChannel.read(buffer,position)；</span><br><span class="line"><span class="comment">//从当前文件指针的位置读取 4kb 的数据</span></span><br><span class="line">fileChannel.read(buffer);</span><br></pre></td></tr></table></figure><p>FileChannel+ByteBuffer可以达到写入速度比较快，要是没有缓冲区的存在，FileChannel写入速度并不比普通IO，一般来说缓冲区的大小是由磁盘决定的。</p><p>那么，FileChannel是直接把ByteBuffer写到磁盘的吗？</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/09/11/1568203557001-1568203557007.png" alt="title"></p><p>不是，中间还隔着一个PageCache。当ByteBUffer是堆内内存时，数据需要经历ByteBuffer-&gt;内核空间-&gt;PageCache。当<strong>ByteBufefr是直接内存，则省略到了从用户空间到内核空间的复制</strong>，直接ByteBuffer-&gt;PageCache，然后再从PageCache写回磁盘。</p><p>我们都知道磁盘 IO 和内存 IO 的速度可是相差了好几个数量级。我们可以认为 filechannel.write <strong>写入 PageCache 便是完成了落盘操作</strong>，但实际上，操作系统最终帮我们完成了 PageCache 到磁盘的最终写入（<strong>这是异步的</strong>），理解了这个概念，你就应该能够理解 FileChannel 为什么提供了一个 force() 方法，用于通知操作系统进行及时的刷盘。</p><p>例如，RocketMQ刷盘方式：</p><ul><li><p>异步刷盘方式：在返回写成功状态时，消息可能只是被写入了内存的PAGECACHE，写操作的返回快，吞吐量大；当内存里的消息量积累到一定程度时，统一触发写磁盘操作，快速写入</p></li><li><p>同步刷盘方式：在返回写成功状态时，消息已经被写入磁盘。具体流程是，消息写入内存的PAGECACHE后，立刻通知刷盘线程刷盘，然后等待刷盘完成，刷盘线程执行完成后唤醒等待的线程，返回消息写成功的状态。</p></li></ul><h2 id="MMap读写"><a href="#MMap读写" class="headerlink" title="MMap读写"></a>MMap读写</h2><p>``</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写</span></span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> position = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//从当前 mmap 指针的位置写入 4b 的数据</span></span><br><span class="line">mappedByteBuffer.put(data);</span><br><span class="line"><span class="comment">//指定 position 写入 4b 的数据</span></span><br><span class="line">MappedByteBuffer subBuffer = mappedByteBuffer.slice();</span><br><span class="line">subBuffer.position(position);</span><br><span class="line">subBuffer.put(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读</span></span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> position = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//从当前 mmap 指针的位置读取 4b 的数据</span></span><br><span class="line">mappedByteBuffer.get(data)；</span><br><span class="line"><span class="comment">//指定 position 读取 4b 的数据</span></span><br><span class="line">MappedByteBuffer subBuffer = mappedByteBuffer.slice();</span><br><span class="line">subBuffer.position(position);</span><br><span class="line">subBuffer.get(data);</span><br></pre></td></tr></table></figure><p>mmap是把文件映射到用户空间里的虚拟内存，这样就省去了从用户空间到内核空间的拷贝，这样，当我们需要向文件中写入数据时，先看虚拟内存中有没有对应的地址，即有没有将物理地址映射到虚拟内存，要是有的话，可以像操作内存一样操作这个文件，没有的话，产生缺页，加载相对应的页。</p><blockquote><p>mmap 把文件映射到用户空间里的虚拟内存，省去了从内核缓冲区复制到用户空间的过程，文件中的位置在虚拟内存中有了对应的地址，可以像操作内存一样操作这个文件，相当于已经把整个文件放入内存，但在真正使用到这些数据前却不会消耗物理内存，也不会有读写磁盘的操作，只有真正使用这些数据时，也就是图像准备渲染在屏幕上时，虚拟内存管理系统 VMS 才根据缺页加载的机制从磁盘加载对应的数据块到物理内存进行渲染。这样的文件读写文件方式少了数据从内核缓存到用户空间的拷贝，效率很高。</p></blockquote><p>但是，MMap是不适用于大量数据的。</p><ul><li>因为一次map的大小在1.5G左右，要是大量数据的话必然要进行多次MMap，重复的map会带来虚拟内存回收，重新分配的问题。</li><li>MMAP 使用的是虚拟内存，和 PageCache 一样是由操作系统来控制刷盘的，虽然可以通过 force() 来手动控制，但这个时间把握不好，在小内存场景下会很令人头疼。</li><li>MMAP 的回收问题，当 MappedByteBuffer 不再需要时，可以手动释放占用的虚拟内存，但非常麻烦。</li></ul><p>所以，对于小数据量刷盘的情况下，可以使用MMap，例如索引，但是其他场景，FileChannel+DirectByteBuffer完全可以替代，并且性能跟MMap差不多。</p><h2 id="堆内内存与堆外内存"><a href="#堆内内存与堆外内存" class="headerlink" title="堆内内存与堆外内存"></a>堆内内存与堆外内存</h2><table><thead><tr><th align="center"></th><th align="center">堆内内存</th><th align="center">堆外内存</th></tr></thead><tbody><tr><td align="center"><strong>底层实现</strong></td><td align="center">数组，JVM 内存</td><td align="center">unsafe.allocateMemory(size)返回直接内存</td></tr><tr><td align="center"><strong>分配大小限制</strong></td><td align="center">-Xms-Xmx 配置的 JVM 内存相关，并且数组的大小有限制，在做测试时发现，当 JVM free memory 大于 1.5G 时，ByteBuffer.allocate(900M) 时会报错</td><td align="center">可以通过 -XX:MaxDirectMemorySize 参数从 JVM 层面去限制，同时受到机器虚拟内存（说物理内存不太准确）的限制</td></tr><tr><td align="center"><strong>垃圾回收</strong></td><td align="center">不必多说，gc自动回收</td><td align="center">当 DirectByteBuffer 不再被使用时，会出发内部 cleaner 的钩子，保险起见，可以考虑手动回收：<strong>((DirectBuffer) buffer).cleaner().clean()</strong>;</td></tr><tr><td align="center"><strong>内存复制</strong></td><td align="center">堆内内存 -&gt; 堆外内存 -&gt; pageCache</td><td align="center">堆外内存 -&gt; pageCache</td></tr></tbody></table><p>对于堆外内存，可使用池+堆外内存组合。例如：<code>ThreadLocal&lt;ByteBuffer&gt;</code> 和 <code>ThreadLocal&lt;byte[]&gt;</code>。</p><h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><h2 id="Referrence"><a href="#Referrence" class="headerlink" title="Referrence"></a>Referrence</h2><p><a href="https://www.jianshu.com/p/d0b4ac90dbcb" target="_blank" rel="noopener">IO操作读写测试</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java文件中文件IO主要包括普通IO，FileChannel以及MMap。本文主要介绍&lt;strong&gt;FileChannel以及MMap&lt;/strong&gt;的一些原理以及使用，理解他们最好需要了解有关pageCache，内存零拷贝，堆外缓存的一些知识。&lt;/p&gt;
&lt;p&gt;有关pageCache可见 &lt;a href=&quot;https://gallonskj.github.io/2019/09/11/DirectIO%E5%92%8CPageCache/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PageCache和DirectIO&lt;/a&gt; ， 有关零拷贝可见 &lt;a href=&quot;https://gallonskj.github.io/2019/09/11/%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E9%97%AE%E9%A2%98/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;零拷贝问题&lt;/a&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java nio" scheme="http://yoursite.com/tags/java-nio/"/>
    
  </entry>
  
</feed>
