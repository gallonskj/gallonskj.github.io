<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gallon&#39;s Note</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-21T06:35:08.604Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>SKJin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>容器</title>
    <link href="http://yoursite.com/2019/10/19/%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/2019/10/19/容器/</id>
    <published>2019-10-19T11:28:19.000Z</published>
    <updated>2019-10-21T06:35:08.604Z</updated>
    
    <content type="html"><![CDATA[<p>容器主要包括 <strong>Collection 和 Map</strong> 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/19/1571485852603-1571485852609.png" alt="title"></p><p>Collection主要分为三类：Set，List，Queue。</p><p>Set是无序存储，而且不会存储重复的元素。</p><p>Queue是一个队列，只能从一端插入元素，从另一端取出元素。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/774d756b-902a-41a3-a3fd-81ca3ef688dc.png" alt="img"></p><p>Map存储的是键值对。</p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList的底层实现是一个数组，其访问速度比较快，但是插入删除速度比较慢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//transient表示这个成员不可以被序列化</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是旧容量的 1.5 倍。</p><p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查index是否合法</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//需要将index+1后面的位置都往前移动</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步,是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩容-1"><a href="#扩容-1" class="headerlink" title="扩容"></a>扩容</h3><p>Vector 的构造函数可以传入 capacityIncrement 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement。如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="与ArrayList不同"><a href="#与ArrayList不同" class="headerlink" title="与ArrayList不同"></a>与ArrayList不同</h3><ul><li>加了synchronized关键字，是线程安全的。</li><li>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。</li></ul><p>但是，一般来说，在面对多线程的情况，我们也很少使用Vector，因为效率比较低。</p><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>CopyOnWriteArrayList也是基于写时复制以及读写分离的思想。</p><p>当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，<strong>复制出一个新的容器</strong>，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。对CopyOnWrite容器进行并发的读的时候，不需要加锁，因为当前容器不会添加任何元素。</p><p>CopyOnWriteArrayList内部维护了一个数组，而且是volatile的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets the array.  Non-private so as to also be accessible</span></span><br><span class="line"><span class="comment"> * from CopyOnWriteArraySet class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现非常简单，因为根据写时复制，读取数据的时候数据不会修改，所以肯定是线程安全的。</p><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line"><span class="comment">//1. 使用Lock,保证写线程在同一时刻只有一个</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//2. 获取旧数组引用</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line"><span class="comment">//3. 创建新的数组，并将旧数组的数据复制到新数组中</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//4. 往新数组中添加新的数据        </span></span><br><span class="line">newElements[len] = e;</span><br><span class="line"><span class="comment">//5. 将旧数组引用指向新的数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>需要添加lock，避免出现多个线程写数据。</li><li>将旧数组拷贝，对新数组进行写操作，操作完成将数组引用指向新数据。</li><li>实际上核心就是读写其实是在两个不同的容器中，所以就可以进行同时读写。</li></ul><h3 id="与读写锁区别"><a href="#与读写锁区别" class="headerlink" title="与读写锁区别"></a>与读写锁区别</h3><p>COW与读写锁都使用了读写分离的思想，都可以同时多个线程读。</p><p>但是COW读写线程是可以同时的。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>数据一致性问题。COW实际上会有读延迟情况的发生。所以，假如对数据实时一致性很高，最好不使用COW。</li><li>内存问题。COW每次写数据都需要重新拷贝一个数组，假如高并发写或者对象比较大，会造成频繁GC。COW其实是不适用于高并发频繁写的场景。</li></ul><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>基于双向链表实现。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/19/1571492127073-1571492127077.png" alt="title"></p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>Set的核心概念就是<strong>集合内所有元素不重复</strong>。</p><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>基于HashTable实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>意思就是HashSet的集合其实就是HashMap的key的集合，然后HashMap的val默认都是PRESENT。HashMap的定义即是key不重复的集合。使用HashMap实现，这样HashSet就不需要再实现一遍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历的是HashMap的key</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>LinkedHashSet会根据add，remove这些操作的顺序在遍历时返回固定的集合顺序。</p><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>基于TreeMap实现。</p><p>TreeSet即是一组有次序的集合，如果没有指定排序规则Comparator，则会按照自然排序。</p><h1 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h1><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md" target="_blank" rel="noopener">Java容器</a></p><p><a href="https://juejin.im/post/5aeeb55f5188256715478c21" target="_blank" rel="noopener">CopyOnWriteArrayList</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;容器主要包括 &lt;strong&gt;Collection 和 Map&lt;/strong&gt; 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。&lt;/p&gt;
&lt;h2 id=&quot;Collection&quot;&gt;&lt;a href=&quot;#Collection&quot; cla
      
    
    </summary>
    
      <category term="容器" scheme="http://yoursite.com/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="容器" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>并发容器</title>
    <link href="http://yoursite.com/2019/10/19/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/2019/10/19/并发容器/</id>
    <published>2019-10-19T11:22:11.000Z</published>
    <updated>2019-10-19T11:37:28.780Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="容器" scheme="http://yoursite.com/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="容器" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://yoursite.com/2019/10/19/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2019/10/19/线程池/</id>
    <published>2019-10-19T08:03:48.000Z</published>
    <updated>2019-10-19T11:37:32.607Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//五个参数的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span></span></span><br></pre></td></tr></table></figure><ul><li><p>corePoolSize,核心线程数。</p><p>线程池新建线程的时候，如果当前线程总数小于corePoolSize，则新建的是核心线程，如果超过corePoolSize，则新建的是非核心线程。</p><p>即使核心线程处于闲置状态，核心线程也不会被销毁。</p></li><li><p>maximumPoolSize,最大线程数。线程池中能创建的最大的线程数。</p></li><li><p>keepAliveTime.当非核心线程数闲置时长超过keepAliveTime,就会将其销毁。</p></li><li><p>workQueue。</p><p>该线程池中的任务队列：维护着等待执行的Runnable对象。</p><p>当所有的核心线程都在干活时，新添加的任务会被添加到这个队列中等待处理，如果队列满了，则新建非核心线程执行任务。</p></li></ul><h2 id="ThreadPoolExecutor的策略"><a href="#ThreadPoolExecutor的策略" class="headerlink" title="ThreadPoolExecutor的策略"></a>ThreadPoolExecutor的策略</h2><p>当一个任务被添加进线程池时：</p><ol><li>线程数量未达到corePoolSize，则新建一个线程(核心线程)执行任务</li><li>线程数量达到了corePoolSize，则将任务移入队列等待</li><li>队列已满，新建线程(非核心线程)执行任务</li><li>队列已满，总线程数又达到了maximumPoolSize，抛出异常</li></ol><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/19/1571483685643-1571483685947.png" alt="title"></p><p><strong>饱和策略 (RejectedExecutionHandler)</strong>：当等待队列已满，线程数也达到最大线程数时，线程池会根据饱和策略来执行后续操作，默认的策略是抛弃要加入的任务。</p><h2 id="线程池种类"><a href="#线程池种类" class="headerlink" title="线程池种类"></a>线程池种类</h2><ul><li><p>newFixedThreadPool，固定线程数的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>newCachedThreadPool。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>newScheduledThreadPool().</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DelayedWorkQueue 这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>newSingleThreadPool().</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;创建线程池&quot;&gt;&lt;a href=&quot;#创建线程池&quot; class=&quot;headerlink&quot; title=&quot;创建线程池&quot;&gt;&lt;/a&gt;创建线程池&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
      
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Semaphore and CountDownLatch</title>
    <link href="http://yoursite.com/2019/10/16/%C2%96Semaphore-and-CountDownLatch/"/>
    <id>http://yoursite.com/2019/10/16/Semaphore-and-CountDownLatch/</id>
    <published>2019-10-16T02:41:50.000Z</published>
    <updated>2019-10-22T06:30:31.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore叫做信号量，是一种共享锁，当其permit大于0时，线程可以获取锁，当permits小于0时，线程只能等待获取锁，等其他线程释放。</p><p>Semophore也有公平锁和非公平锁两种状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公平共享锁尝试获取acquires个信号量</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors()) <span class="comment">//前面是否有排队，有则返回获取失败</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> available = getState(); <span class="comment">//剩余的信号量（旋转寿司店剩余的座位）</span></span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining)) <span class="comment">// 剩余信号量不够，够的情况下尝试获取（旋转寿司店座位不够，或者同时来两对情况抢座位）</span></span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非公平共享锁尝试获取acquires个信号量</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> available = getState(); <span class="comment">//剩余的信号量（旋转寿司店剩余的座位）</span></span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining)) <span class="comment">// 剩余信号量不够，够的情况下尝试获取（旋转寿司店座位不够，或者同时来两对情侣抢座位）</span></span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch用于协调多个线程的同步，能让一个线程在等待其他线程执行完任务后，再继续执行。内部是通过一个计数器去完成实现。</p><p>CountDownLatch是通过<strong>一个计数器</strong>来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，可以调用<strong>countDown()，计数器的值就会减1</strong>。当计数器值到达0时，它表示所有的线程已经完成了任务，然后<strong>在闭锁上等待的线程(使用await()阻塞)就可以恢复执行任务</strong>。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><p>一个线程执行需要等待其他线程执行完毕，才能继续执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">"---start"</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">"---finish"</span>);</span><br><span class="line">               <span class="comment">//计数器减一</span></span><br><span class="line">               latch.countDown();</span><br><span class="line">           &#125;).start();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//将主线程阻塞在latch，直到latch的计数器等于0</span></span><br><span class="line">           latch.await();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">"执行完毕-----"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>CountDownLatch通过state来表示计数器。</p><ul><li>await() 将当前线程阻塞在CountDownLatch上，直到计数器的数量减少至0.</li><li>await(long timeout, TimeUnit unit)，与await()不同的是，设置了超时等待，等到了时间，不管计数器是不是0，都会继续执行。</li><li>countDown()，计数器数量减一。当计数器数量减为0时，将await()的线程唤醒。</li></ul><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</p><p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p><p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。</p><p>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。</p><p><img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/f71af66b-0d54-4399-a44b-f47b58321984.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Semaphore&quot;&gt;&lt;a href=&quot;#Semaphore&quot; class=&quot;headerlink&quot; title=&quot;Semaphore&quot;&gt;&lt;/a&gt;Semaphore&lt;/h2&gt;&lt;p&gt;Semaphore叫做信号量，是一种共享锁，当其permit大于0时，线程可以获取锁
      
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>读写锁</title>
    <link href="http://yoursite.com/2019/10/14/%E8%AF%BB%E5%86%99%E9%94%81/"/>
    <id>http://yoursite.com/2019/10/14/读写锁/</id>
    <published>2019-10-14T07:30:06.000Z</published>
    <updated>2019-10-16T08:46:23.509Z</updated>
    
    <content type="html"><![CDATA[<p>ReentrantReadWriteLock：一个资源能够被<strong>多个读线程访问</strong>，或者被<strong>一个写线程访问</strong>，但是<strong>不能同时存在读写线程</strong>。</p><p>读锁是共享锁，可以有多个线程读；而写锁是独占锁，同时只可能有一个线程写。</p><h2 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h2><p>读锁可以多线程访问，写锁只可以有一个线程访问，我们很容易想到可以使用两个变量来表示读写状态。但是，AQS却只是使用一个state来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns the number of shared holds represented in count  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"><span class="comment">/** Returns the number of exclusive holds represented in count  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure><p>举个例子来看：</p><p>这里有两个关键方法sharedCount和exclusiveCount，通过名字可以看出sharedCount是共享锁的数量，exclusiveCount是独占锁的数量。</p><p><strong>共享锁通过对c像右位移16位获得，独占锁通过和16位的1与运算获得。</strong></p><p>state前十六位代表读锁，后十六位代表写锁。</p><p>举个例子，当获取读锁的线程有3个，写锁的线程有1个（当然这是不可能同时有的），state就表示为0000 0000 0000 0011 0000 0000 0000 0001，高16位代表读锁，通过向右位移16位（c &gt;&gt;&gt; SHARED_SHIFT）得倒10进制的3，通过和0000 0000 0000 0000 1111 1111 1111 1111与运算（c &amp; EXCLUSIVE_MASK），获得10进制的1。</p><p>由于16位最大全1表示为65535，<strong>所以读锁和写锁最多可以获取65535个</strong>。</p><h2 id="WriteLock"><a href="#WriteLock" class="headerlink" title="WriteLock"></a>WriteLock</h2><p>写锁是一把独占锁，同时只可能有一个线程访问，而且不可能与读锁同时存在，所以与ReentrantLock不同的是，<strong>WriteLock不仅要判断是否还有其它写线程占用，还要考虑是否还有读线程占用</strong>。</p><p>读锁是否存在。因为要确保写锁的操作对读锁是<strong>可见的</strong>。如果在存在读锁的情况下允许获取写锁，那么那些已经获取读锁的其他线程可能就无法感知当前写线程的操作。因此只有等读锁完全释放后，写锁才能够被当前线程所获取，一旦写锁获取了，所有其他读、写线程均会被阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();  <span class="comment">//获取共享变量state</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">//获取写锁数量</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123; <span class="comment">//有读锁或者写锁</span></span><br><span class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread()) <span class="comment">//写锁为0（证明有读锁），或者持有写锁的线程不为当前线程</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// Reentrant acquire</span></span><br><span class="line">        setState(c + acquires);  <span class="comment">//当前线程持有写锁，为重入锁，+acquires即可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires)) <span class="comment">//CAS操作失败，多线程情况下被抢占，获取锁失败。CAS成功则获取锁成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h2><p>在获取写锁的时候，如果资源存在读锁，那么肯定是无法获取写锁的。</p><p>但是，在获取读锁的时候， 如果对资源加了写锁，其他线程无法再获得写锁与读锁，但是持有写锁的线程，可以对资源加读锁（锁降级），主要原因是因为在同一个线程内，写锁所做的修改读锁时立即可见的，但是在别的线程内就没有可见性了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">   Object data;</span><br><span class="line">     <span class="comment">//保证状态可见性</span></span><br><span class="line">   <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;</span><br><span class="line">   ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     rwl.readLock().lock();</span><br><span class="line">     <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">        <span class="comment">// 在获取写锁前必须释放读锁</span></span><br><span class="line">        rwl.readLock().unlock();</span><br><span class="line">        rwl.writeLock().lock();</span><br><span class="line">        <span class="comment">//再次检查其他线程是否已经抢到  </span></span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">           <span class="comment">//获取数据</span></span><br><span class="line">          data = ...</span><br><span class="line">          cacheValid = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在释放写锁之前通过获取读锁来降级</span></span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        <span class="comment">//释放写锁，保持读锁</span></span><br><span class="line">        rwl.writeLock().unlock();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     use(data);</span><br><span class="line">     rwl.readLock().unlock();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="ReadLock"><a href="#ReadLock" class="headerlink" title="ReadLock"></a>ReadLock</h2><ul><li>申请读锁，资源上没有写锁，且读锁数量小于最大值，申请读锁成功。</li><li>申请读锁，资源上有写锁，且写锁就在本线程上，那么申请成功。</li></ul><p><a href="http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/" target="_blank" rel="noopener">读写锁</a></p><p><a href="https://blog.51cto.com/viphyy/2092670" target="_blank" rel="noopener">锁降级</a></p><p><a href="https://juejin.im/post/5b9df6015188255c8f06923a#heading-8" target="_blank" rel="noopener">读写锁</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ReentrantReadWriteLock：一个资源能够被&lt;strong&gt;多个读线程访问&lt;/strong&gt;，或者被&lt;strong&gt;一个写线程访问&lt;/strong&gt;，但是&lt;strong&gt;不能同时存在读写线程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;读锁是共享锁，可以有多个线程读；
      
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发，java" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91%EF%BC%8Cjava/"/>
    
  </entry>
  
  <entry>
    <title>ReentranrLock</title>
    <link href="http://yoursite.com/2019/10/13/ReentranrLock/"/>
    <id>http://yoursite.com/2019/10/13/ReentranrLock/</id>
    <published>2019-10-13T07:18:24.000Z</published>
    <updated>2019-10-14T07:29:26.827Z</updated>
    
    <content type="html"><![CDATA[<p>ReentrantLock是可重入锁，它实现了Lock接口。</p><p>可重入锁就是说同一个线程可以多次申请到该锁。</p><p>ReentrantLock有公平锁和非公平锁两种方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> *     lock.lock();  <span class="comment">// block until condition holds</span></span><br><span class="line"> *     <span class="keyword">try</span> &#123;</span><br><span class="line"> *       <span class="comment">// ... method body</span></span><br><span class="line"> *     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> *       lock.unlock()</span><br><span class="line"> *     &#125;</span><br><span class="line"> *   &#125;</span><br></pre></td></tr></table></figure><p>使用lock和unlock进行加锁和解锁。</p><p>而lock和unlock都是调用sync的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sync是ReentranrtLock的成员变量，他继承了AQS,所以，核心是AQS的实现，而且<strong>有两个内部类，一个可以实现公平锁，一个实现非公平锁</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>在构造函数中可以定义是公平锁还是非公平锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">       sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock主要还是基于AQS实现的，我们主要关注他重写的一些方法，包括tryAcquire()和release().</p><h3 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire()"></a>tryAcquire()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非公平锁 </span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="comment">//重入锁的实现</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>公平锁和非公平锁最大的区别就是!hasQueuedPredecessors()，<strong>公平锁需要先判断等待队列中是否有前驱节点在等待</strong>。如果有，则说明有线程比当前线程更早的请求资源，根据公平性，当前线程请求资源失败；如果当前节点没有前驱节点，才有做后面的逻辑判断的必要性。</p><h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><p>非公平锁的吞吐量较高例如默认状态的<strong>ReentrantLock</strong> 有新线程来了先争夺一下锁，没成功再去排队。<br>公平锁是java关键字synchronized的重锁模式，谁来了都乖乖排队，<strong>后来的线程不能争夺锁</strong>，一定要入队列等待前一个线程来unpark自己，除非队列里没有其他线程。</p><p>可以在构<strong>造函数中设置</strong>公平锁还是非公平锁。</p><h2 id="尝试锁定"><a href="#尝试锁定" class="headerlink" title="尝试锁定"></a>尝试锁定</h2><p>可以使用tryLock()来尝试上锁，<strong>假如在一定的时间内获取锁失败，那么就会放弃等待</strong>。</p><h2 id="可中断锁"><a href="#可中断锁" class="headerlink" title="可中断锁"></a>可中断锁</h2><p>lock.lockInterruptibly() 对线程中断 interrupt() 做出响应。</p><p>使用 lockInterruptibly() 则该线程在等待锁的过程中，如果被中断interrupt()，则直接抛出中断异常来立即响应中断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JUC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock3</span> </span>&#123;</span><br><span class="line">    Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">"t1 start"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">10000000</span>);</span><br><span class="line">            System.out.println(<span class="string">"t1 end"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lockInterruptibly();</span><br><span class="line">            System.out.println(<span class="string">"t2 start"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            System.out.println(<span class="string">"t2 interrupted!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLock3 test=<span class="keyword">new</span> ReentrantLock3();</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(test::m2);</span><br><span class="line">        <span class="keyword">new</span> Thread(test::m1).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t2.start();</span><br><span class="line">        t2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//t1 start</span></span><br><span class="line"><span class="comment">//t2 interrupted!</span></span><br></pre></td></tr></table></figure><h2 id="与synchronized区别"><a href="#与synchronized区别" class="headerlink" title="与synchronized区别"></a>与synchronized区别</h2><ul><li>ReentrantLock是JDK实现的，synchronized是JVM实现的。</li><li>ReentrantLock需要手动释放，而且最好在finally中释放。</li><li>ReentrantLock支持公平锁。</li><li>ReentrantLock支持中断锁。</li><li>ReentrantLock支持条件队列。</li></ul><p>现在来说，经过JVM的优化，synchronized的效率已经很高了，一般来说，如果没有必须要使用ReentrantLock的功能。最好使用synchronized。因为JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ReentrantLock是可重入锁，它实现了Lock接口。&lt;/p&gt;
&lt;p&gt;可重入锁就是说同一个线程可以多次申请到该锁。&lt;/p&gt;
&lt;p&gt;ReentrantLock有公平锁和非公平锁两种方式。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table
      
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JVM优化</title>
    <link href="http://yoursite.com/2019/10/12/JVM%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/10/12/JVM优化/</id>
    <published>2019-10-12T08:07:25.000Z</published>
    <updated>2019-10-14T07:29:30.977Z</updated>
    
    <content type="html"><![CDATA[<p>Java有三种编译器i，一种是前端编译器，就是将java文件转变为class文件，这是在编译阶段。一种运行期编译器(JIT编译器)，将字节码文件转变为机器码，这是在运行阶段。</p><h2 id="编译期优化"><a href="#编译期优化" class="headerlink" title="编译期优化"></a>编译期优化</h2><p>编译过程主要分为：</p><ul><li>词法语法分析。</li><li>填充符号表。</li><li>注解处理器。</li><li>语义分析。</li><li>生成字节码。</li></ul><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型是java语法糖的一种，他的本质是参数化类型。</p><p>泛型主要有泛型类，泛型接口，泛型方法。</p><p>Java中的泛型只存在于编译阶段，只是用来在编译阶段进行数据校验的作用，在运行时期，泛型就被擦除了，替换为他的原生类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; integerArrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">Class classStringArrayList = stringArrayList.getClass();</span><br><span class="line">Class classIntegerArrayList = integerArrayList.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(classStringArrayList.equals(classIntegerArrayList))&#123;</span><br><span class="line">    System.out.println(<span class="string">"----equals----"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：----equals----</span></span><br></pre></td></tr></table></figure><p>在运行阶段，泛型已被擦除，所以，都被替换为ArrayList，是相同的。</p><p>个人觉得泛型的作用就是在编译阶段进行语义的审查的作用。</p><p>泛型擦除只是从字节码中擦除了，但是元数据中还是保留了泛型信息，所以，我们还是可以通过反射手段取得参数化类型。</p><ul><li>获取方法返回泛型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method method = MyClass.class.getMethod(<span class="string">"getStringList"</span>, <span class="keyword">null</span>);</span><br><span class="line">Type returnType = method.getGenericReturnType();</span><br></pre></td></tr></table></figure><ul><li>获取成员变量泛型参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Field field = MyClass.class.getField(<span class="string">"stringList"</span>);</span><br><span class="line">Type genericFieldType = field.getGenericType();</span><br></pre></td></tr></table></figure><h2 id="运行期优化"><a href="#运行期优化" class="headerlink" title="运行期优化"></a>运行期优化</h2><p> javac 将程序源代码编译，转换成 java 字节码，JVM 通过<strong>解释字节码将其翻译成对应的机器指令</strong>，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢很多。为了提高执行速度，引入了 JIT 技术。</p><p>当JVM发现某一段代码执行特别频繁的时候，就会认为他是热点代码，为了提高执行效率，虚拟机就会用过JIT编译器将这些代码编译成机器码，缓存下来。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/12/1570883161206-1570883161218.png" alt="title"></p><p>那么，为什么不直接编译呢？</p><p>首先，如果这段代码本身在将来只会被执行一次，那么从本质上看，编译就是在浪费精力。因为将代码翻译成 java 字节码相对于编译这段代码并执行代码来说，要快很多。当然，如果一段代码频繁的调用方法，或是一个循环，也就是这段代码被多次执行，那么编译就非常值得了。因此，编译器具有的这种权衡能力会首先执行解释后的代码，然后再去分辨哪些方法会被频繁调用来保证其本身的编译。</p><p>JVM是采<strong>用解释器与编译器并行</strong>的架构。</p><p>程序启动时，解释器首先发挥作用，省掉编译的时间，迅速执行。</p><p>程序运行后，随着时间的推移，编译器发挥作用，将代码编译成机器码，获取更高执行效率。</p><p>HotSpot有两个即时编译器，Client Compiler和Server Compiler，一个注重优化速度，一个注重优化质量。</p><p>Client Compiler：<strong>编译速度快，优化简单可靠</strong>。</p><p>Server Compiler：<strong>会有一些编译时间比较长的优化</strong>。</p><h3 id="热点代码"><a href="#热点代码" class="headerlink" title="热点代码"></a>热点代码</h3><p>热点代码有两类。</p><ul><li>被多次调用的方法。</li><li>被多次执行的循环体。</li></ul><p>那么，怎么计数呢？</p><ul><li>基于采样的热点探测。虚拟机周期性的检查各个线程栈顶，如果某个方法频繁出现，那么这就是一个热点方法。</li><li>基于计数器的热点探测。为每个方法(代码块)建立计数器，统计执行次数。</li></ul><p>在HotSpot采用的是第二种，有方法计数器来统计方法调用次数，回边计数器来统计循环代码调用次数。当计数器超过阈值的时候，就会对其进行编译。</p><h3 id="优化技术"><a href="#优化技术" class="headerlink" title="优化技术"></a>优化技术</h3><h4 id="公共子表达式消除"><a href="#公共子表达式消除" class="headerlink" title="公共子表达式消除"></a>公共子表达式消除</h4><p>如果一个表达式E计算过了，且他的值没有任何变化，那么E再次出现就没必要再次计算，直接用结果。</p><h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><p>内联举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b , <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">          <span class="keyword">return</span> add(a, b) + add(c, d);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>内联之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b , <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">          <span class="keyword">return</span> a + b + c + d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用一个方法需要建立栈帧等，成本比较大，方法内联可以很好的消除方法调用的成本。</p><p>内联条件：</p><ul><li><strong>热点代码</strong>。</li><li>方法体不是太大。</li><li>如果希望方法被内联，<strong>尽量用private、static、final修饰</strong>，这样jvm可以直接内联。如果是public、protected修饰方法jvm则需要进行类型判断，因为这些方法可以被子类继承和覆盖，jvm需要判断内联究竟内联是父类还是其中某个子类的方法。</li></ul><p>但是，内联并不是这么简单的，我们的程序中大多都是虚方法(不用private，final，static修饰的)，那么就会有多态的可能，不知道会不会有子类重写了方法。</p><p>JVM团队采用CHA来解决这个问题。</p><ul><li>方法是非虚方法，直接内联即可。</li><li>是虚方法，看程序内该方法是否有多个实现，若只有一个，直接内联。</li><li>若有多个，采取内联缓存。内联缓存中保存的是第一次调用使用的版本，并且以后每次调用都会比较版本信息，一致，继续使用。</li><li>不一致，取消内联。</li></ul><h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><ul><li>方法逃逸：一个对象在方法中被定义后，可能被其他方法使用。</li><li>线程逃逸：一个对象在方法中定义后，可以被别的线程访问到。</li></ul><p>如果一个对象没有逃逸，可以对其做以下优化。</p><ul><li>栈上分配。如果一个对象没有逃逸出方法之外，那么只会在一个方法内部访问，这样的话，将其分配在栈上，方法结束，对象自动被销毁，GC压力会小很多。</li><li>同步消除。因为一个对象没有逃逸，所以不会被外部线程访问到，所以同步措施也可以消除。</li><li>标量替换。标量是指一个数据无法再分解成更小的数据，例如基本数据类型，引用类型等。如果一个对象不会被外部访问，可以选择不创建这个对象，转而直接创建这个对象会被方法调用的成员变量。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java有三种编译器i，一种是前端编译器，就是将java文件转变为class文件，这是在编译阶段。一种运行期编译器(JIT编译器)，将字节码文件转变为机器码，这是在运行阶段。&lt;/p&gt;
&lt;h2 id=&quot;编译期优化&quot;&gt;&lt;a href=&quot;#编译期优化&quot; class=&quot;header
      
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Lock and AQS</title>
    <link href="http://yoursite.com/2019/10/10/Lock-and-AQS/"/>
    <id>http://yoursite.com/2019/10/10/Lock-and-AQS/</id>
    <published>2019-10-10T12:26:05.000Z</published>
    <updated>2019-10-19T11:37:43.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JUC包"><a href="#JUC包" class="headerlink" title="JUC包"></a>JUC包</h2><p>JUC包目录。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/13/1570936405191-1570936405441.png" alt="title"></p><p>其中包含了两个子包：atomic以及lock，另外在concurrent下的阻塞队列以及executors，<strong>这些类主要是依靠volatile以及CAS实现的</strong>。</p><p>整体结构如图：</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/13/1570936455857-1570936455857.png" alt="title"></p><h2 id="Lock简介"><a href="#Lock简介" class="headerlink" title="Lock简介"></a>Lock简介</h2><p>Lock是一个接口。</p><p>与synchronized相比，Lock<strong>拥有了锁获取和释放的可操作性，可中断的获取锁以及超时获取锁等</strong>多种synchronized关键字所不具备的同步特性。</p><a id="more"></a><p>Lock是一个接口，有许多实现他的类，比如ReentranrLock，但是查看他的源码会发现大部分方法都是在调用他的内部类Sync的方法，而Sync继承了AQS，因此，Lock实现的核心还是AQS。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/13/1570955895636-1570955895643.png" alt="title"></p><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AQS的设计是使用模板方法设计模式，他将一些相同部分的代码实现，将不同的代码放到不同的子类中去；而且，在AQS的方法中，也会调用子类的代码。<a href="https://blog.csdn.net/carson_ho/article/details/54910518" target="_blank" rel="noopener">模板设计模式</a></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类需要重写tryAcquire()</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//但是在AQS的模板方法中又调用了tryAcquire()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>因此，AQS只需要实现各自不同的tryAquire()就行了,比如是公平锁还是非公平锁，是独占锁还是共享锁。</p><p>AQS提供的模板方法可以分为3类：</p><ul><li><p>独占式获取与释放同步状态；</p></li><li><p>共享式获取与释放同步状态；</p></li><li><p>查询同步队列中等待线程情况；</p></li></ul><p>AQS的功能分为两种：<strong>独占和共享</strong></p><ul><li>独占锁，每次只能有一个线程持有锁，比如ReentrantLock就是以独占方式实现的互斥锁.</li><li>共享锁，允许多个线程同时获取锁，并发访问共享资源，比如ReentrantReadWriteLock.</li></ul><h2 id="AQS实现"><a href="#AQS实现" class="headerlink" title="AQS实现"></a>AQS实现</h2><p>AQS中有两个重要的成员，一个是CLH队列，一个是state。</p><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>AQS使用一个int类型的成员变量state来<strong>表示同步状态</strong>，当state&gt;0时表示已经获取了锁，当state = 0时表示释放了锁。</p><h3 id="CLH"><a href="#CLH" class="headerlink" title="CLH"></a>CLH</h3><p>CLH是一个先进先出的队列。如果当前线程竞争锁失败，那么AQS会把当前线程以及等待状态信息<strong>构造成一个Node</strong>加入到同步队列中，同时再阻塞该线程。当获取锁的线程释放锁以后，会从队列中唤醒一个阻塞的节点(线程)。</p><p>CLH的头节点是空的，啥也不存的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Node代表的是一个正在阻塞等待的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前节点处于共享模式的标记</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//当前节点处于独占模式的标记</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程被取消了</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//释放资源后需唤醒后继节点</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//等待condition唤醒</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//工作于共享锁状态，需要向后传播，</span></span><br><span class="line">        <span class="comment">//比如根据资源是否剩余，唤醒后继节点</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待状态，有1,0,-1,-2,-3五个值。分别对应上面的值</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//前驱节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//后继节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待锁的线程</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待条件的下一个节点，ConditonObject中用到</span></span><br><span class="line">        Node nextWaiter;</span><br></pre></td></tr></table></figure><h3 id="独占锁的获取"><a href="#独占锁的获取" class="headerlink" title="独占锁的获取"></a>独占锁的获取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过子类的tryAcquire()获取锁，不同的子类有不同的实现，要是获取失败，则执行acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，将该线程放入CLH  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>入队操作：<strong>主要采取CAS+自旋的方式</strong>，一开始采用CAS快速入队，失败了之后再采用自旋操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入队操作，mode = Node.EXCLUSIVE，独占锁</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这段代码进行快速入队，实际上与enq中差不多。这样做的原因是：</span></span><br><span class="line"><span class="comment">        把最有可能成功执行的代码直接写在最常用的调用处，因为在线程数不多的情况下，CAS还是很难失败的。因此  这种写法可以节省多条指令。因为调用enq需要一次方法调用，进入循环，比较null，然后才到了红框中一样 的代码。大概类似于内联函数的优化</span></span><br><span class="line"><span class="comment">总而言之，节省指令，提高效率。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;<span class="comment">//记录尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">//由于采用lazy initialize,当队列为空时，需要进行初始化</span></span><br><span class="line">            <span class="comment">//通过CAS设置head和tail节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;<span class="comment">//将node的前节点设置为原tail节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;<span class="comment">//CAS更新tail节点，更新成功则将原tail节点的后节点设置为node，返回原tail节点，入列成功；</span></span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在把node插入队列末尾后,它并不立即挂起该节点中线程,因为在插入它的过程中,前面的线程可能已经执行完成,所以它会先进行自旋操作acquireQueued(node, arg),尝试让该线程重新获取锁!当条件满足获取到了锁则可以从自旋过程中退出，否则继续。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//如果节点的前驱是队列的头节点并且能拿到资源，获取锁成功，结束</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断当前节点是否应该被挂起。</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>判断节点是否应该被挂起，当前驱节点是SIGNAL的时候，直接挂起线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="comment">//前驱节点的状态是SIGNAL，说明前驱节点释放资源后会通知自己</span></span><br><span class="line">            <span class="comment">//此时当前节点可以安全的park()，因此返回true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//前驱节点的状态是CANCLLED，说明前置节点已经放弃获取资源了</span></span><br><span class="line">            <span class="comment">//此时一直往前找，直到找到最近的一个处于正常等待状态的节点</span></span><br><span class="line">            <span class="comment">//并排在它后面，返回false</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//前驱节点的状态是0或PROPGATE，则利用CAS将前置节点的状态置</span></span><br><span class="line">            <span class="comment">//为SIGNAL，让它释放资源后通知自己</span></span><br><span class="line">            <span class="comment">//如果前置节点刚释放资源，状态就不是SIGNAL了，这时就会失败</span></span><br><span class="line">            <span class="comment">// 返回false</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>acquire()整个流程：</p><ul><li><p><strong>调用子类的tryAquire()尝试获取资源</strong>，成功，直接返回。失败，继续。</p></li><li><p>获取失败，将该线程生成一个Node节点通过addWaiter(Node.EXCLUSIVE), arg)<strong>添加到等待队列</strong>。</p></li><li><p>插入等待队列后，防止在这个阶段资源又有了。根据<strong>前置节点状态状态判断是否应该继续获取资源</strong>。如果前驱是头结点，继续尝试获取资源；获取成功，返回；否则，继续。</p></li><li><p>在每一次自旋获取资源过程中，失败后调用shouldParkAfterFailedAcquire(Node, Node)检测当前节点是否应该park()。</p><p>如果前置节点是SIGNAL状态，就挂起，返回true。</p><p>如果前置节点状态为CANCELLED，就一直往前找，直到找到最近的一个处于正常等待状态的节点，并排在它后面，返回false，acquireQueed()接着自旋尝试。</p><p>前置节点处于其他状态，利用CAS将前置节点状态置为SIGNAL。当前置节点刚释放资源，状态就不是SIGNAL了，导致失败，返回false。但凡返回false，就导致acquireQueed()接着自旋尝试。</p></li><li><p>若返回true，则调用parkAndCheckInterrupt()中断当前节点中的线程。若返回false，则接着自旋获取资源。</p></li><li><p>parkAndCheckInterrupt()挂起线程。</p></li></ul><h3 id="共享锁的获取"><a href="#共享锁的获取" class="headerlink" title="共享锁的获取"></a>共享锁的获取</h3><p>共享锁就是同时可以有多个线程访问。实现与独占锁差不多，唯一的不同就是需要<strong>判断是否还有剩余资源</strong>。</p><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>非公平锁的吞吐量较高例如默认状态的<strong>ReentrantLock</strong> 有新线程来了先争夺一下锁，没成功再去排队。<br>公平锁是java关键字synchronized的重锁模式，谁来了都乖乖排队，<strong>后来的线程不能争夺锁</strong>，一定要入队列等待前一个线程来unpark自己，除非队列里没有其他线程。</p><h3 id="中断锁"><a href="#中断锁" class="headerlink" title="中断锁"></a>中断锁</h3><p>当线程等待的时候，如果被interrupt()，那么直接抛出中断异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            doAcquireInterruptibly(arg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="超时锁"><a href="#超时锁" class="headerlink" title="超时锁"></a>超时锁</h3><p>在获取锁的过程中，超过某一个时长，自动放弃获取。</p><h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><p>首先调用子类的tryRelease()方法释放锁,然后唤醒后继节点,在唤醒的过程中,需要判断后继节点是否满足情况,如果后继节点不为空且不是作废状态,则唤醒这个后继节点,否则从tail节点向前寻找合适的节点,如果找到,则唤醒。</p><h3 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h3><p>这是AQS的一个内部类，其维护了一个condition队列。主要有await()和signal()等方法。</p><h4 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h4><p>await()：当前线程处于阻塞状态，直到调用signal()或中断才能被唤醒。</p><ul><li>将当前线程封装成node且等待状态为CONDITION。</li><li>释放当前线程持有的所有资源，让下一个线程能获取资源。</li><li>加入到条件队列后，则阻塞当前线程，等待被唤醒。</li><li>如果是因signal被唤醒，则节点会从条件队列转移到等待队列；如果是因中断被唤醒，则记录中断状态。两种情况都会跳出循环。</li><li>若是因signal被唤醒，就自旋获取资源；否则处理中断异常。</li></ul><p>condition队列与CLH最大的不同就是CLH是双向列表，condition队列是单向列表。</p><p>CLH是单向列表的原因是可能需要获取前置节点的一些属性，比如说查看前置节点是不是头节点之类的。</p><h2 id="ConditionObject详解"><a href="#ConditionObject详解" class="headerlink" title="ConditionObject详解"></a>ConditionObject详解</h2><p>ConditionObject用来实现<strong>锁的等待通知</strong>机制。ConditionObject内部维护了一个等待队列，与CLH不同的是这个队列是单向链表。</p><h3 id="与Object-wait-notify区别"><a href="#与Object-wait-notify区别" class="headerlink" title="与Object wait/notify区别"></a>与Object wait/notify区别</h3><p>Object的wait和notify/notify是与<strong>对象监视器配合完成线程间的等待/通知机制</strong>，而<strong>Condition与Lock配合</strong>完成等待通知机制，前者是java底层级别的，后者是语言级别的，具有更高的可控制性和扩展性。</p><p>Condition能够支<strong>持多个等待队列</strong>（new 多个Condition对象），而Object方式只能支持一个。</p><p>Condition能够支持超时时间的设置，而Object不支持。</p><h3 id="await方法"><a href="#await方法" class="headerlink" title="await方法"></a>await方法</h3><ul><li>void await() throws InterruptedException:当前线程进入等待状态，如果其他线程调用condition的signal或者signalAll方法并且当前线程获取Lock从await方法返回，如果在等待状态中被中断会抛出被中断异常；</li><li>long awaitNanos(long nanosTimeout)：当前线程进入等待状态直到被通知，中断或者<strong>超时</strong>。</li><li>boolean awaitUntil(Date deadline) throws InterruptedException：当前线程进入等待状态直到被通知，中断或者<strong>到了某个时间</strong>。</li></ul><h3 id="signal方法"><a href="#signal方法" class="headerlink" title="signal方法"></a>signal方法</h3><ul><li>void signal()：唤醒一个等待在condition上的线程(第一个线程，<strong>条件队列是一个FIFO的队列</strong>)，将该线程从<strong>等待队列</strong>中转移到<strong>同步队列</strong>中，如果在同步队列中能够竞争到Lock则可以从等待方法中返回。</li><li>void signalAll()：与1的区别在于能够唤醒所有等待在condition上的线程。</li></ul><h3 id="await实现原理"><a href="#await实现原理" class="headerlink" title="await实现原理"></a>await实现原理</h3><p>await主要做了三件事：</p><ul><li>将线程包装成Node，插入到条件队列。</li><li>释放线程拥有的锁。</li><li>阻塞当前线程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line"><span class="comment">// 1. 将当前线程包装成Node，尾插入到等待队列中</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line"><span class="comment">// 2. 释放当前线程所占用的lock，在释放的过程中会唤醒同步队列中的下一个节点</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line"><span class="comment">// 3. 当前线程进入到等待状态</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 4. 自旋等待获取到同步状态（即获取到lock）</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line"><span class="comment">// 5. 处理被中断的情况</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入到条件队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//将当前线程包装成Node</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"><span class="comment">//尾插入</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line"><span class="comment">//更新lastWaiter</span></span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与等待队列不同的是，条件队列没有头节点。</p><p>释放锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line"><span class="comment">//成功释放同步状态</span></span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//不成功释放同步状态抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结束await()状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前节点被移动到了同步队列中（即另外线程调用的condition的signal或者signalAll方法），while中逻辑判断为false后结束while循环</span></span><br><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line"><span class="comment">// 3. 当前线程进入到等待状态</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//当线程被中断，会退出循环</span></span><br><span class="line">    <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/65349219" target="_blank" rel="noopener">AQS详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JUC包&quot;&gt;&lt;a href=&quot;#JUC包&quot; class=&quot;headerlink&quot; title=&quot;JUC包&quot;&gt;&lt;/a&gt;JUC包&lt;/h2&gt;&lt;p&gt;JUC包目录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/13/1570936405191-1570936405441.png&quot; alt=&quot;title&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中包含了两个子包：atomic以及lock，另外在concurrent下的阻塞队列以及executors，&lt;strong&gt;这些类主要是依靠volatile以及CAS实现的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;整体结构如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/13/1570936455857-1570936455857.png&quot; alt=&quot;title&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Lock简介&quot;&gt;&lt;a href=&quot;#Lock简介&quot; class=&quot;headerlink&quot; title=&quot;Lock简介&quot;&gt;&lt;/a&gt;Lock简介&lt;/h2&gt;&lt;p&gt;Lock是一个接口。&lt;/p&gt;
&lt;p&gt;与synchronized相比，Lock&lt;strong&gt;拥有了锁获取和释放的可操作性，可中断的获取锁以及超时获取锁等&lt;/strong&gt;多种synchronized关键字所不具备的同步特性。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://yoursite.com/2019/10/10/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/10/10/单例模式/</id>
    <published>2019-10-10T11:00:09.000Z</published>
    <updated>2019-10-11T02:33:26.638Z</updated>
    
    <content type="html"><![CDATA[<p>一开始，我们写的单例模式是这样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这种方式有一个问题，就是无法解决多线程问题。</p><a id="more"></a><p>于是，对方法加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;  <span class="comment">//lineA</span></span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就解决了并发的问题。</p><p>但是，在每次调用方法我们都需要加锁，加锁实际上性能会变低，实际上调用方法只会出现一次instance==null，以后的每一次调用都是直接返回instance对象。</p><p>因此，可以将if判断语句提取出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123; <span class="comment">//lineA</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这样还是有问题，假设线程A执行完了lineA进入同步语句，但还并没有创建实例，此时线程B也执行到了lineA，但是instance==null，还是会重复创建实例。</p><p>于是，采用DCL解决，在同步语句块内部再进行一次if判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，这样就没有问题了吗？</p><p>并不是，因为<strong>new Singleton()这个语句实际上它并不是一个原子操作</strong>。</p><p>它有三条指令构成：</p><ul><li><p>1.在堆中开辟一块内存（new）</p></li><li><p>2.调用对象的构造函数对内存进行初始化（invokespecial）</p></li><li><p>3.<strong>最后将引用赋值给变量（astore），这一句instance就赋值了</strong>。</p></li></ul><p>所以，因为重排序的存在，CPU有可能产生指令重排序，比如1-3-2，这样的话，另一个线程可能在对象还没有初始化的时候就拿走了instance，造成问题。</p><p>于是，我们可以加上volatile，禁止指令重排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.iteye.com/blog/crud0906-576321" target="_blank" rel="noopener">单例模式</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一开始，我们写的单例模式是这样的。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Singleton instance = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Singleton &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(instance==&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;但是，这种方式有一个问题，就是无法解决多线程问题。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>volatile关键字</title>
    <link href="http://yoursite.com/2019/10/09/volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/10/09/volatile关键字/</id>
    <published>2019-10-09T12:18:33.000Z</published>
    <updated>2019-10-11T11:49:08.184Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><p>JMM定义了内存中各个共享变量访问的规则。</p><p>共享变量包括包括实例字段 静态字段和构成数组的元素，即所有线程都可以访问到的，不包括局部变量和方法参数，这是线程私有的。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/11/1570784481491-1570784481498.png" alt="title"></p><p>JMM规定了所有共享变量都存储在主内存，每条线程还有自己的工作内存，工作内存除了存储线程私有的局部变量以及方法参数等，还有该线程中需要用到的主内存中的共享变量的拷贝。</p><a id="more"></a><p><strong>线程对变量的操作(读取赋值等)必须在工作内存中进行</strong>，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量。</p><p>工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。</p><p>设置工作内存的<strong>目的主要是为了解决内存与处理器速度不一致的问题</strong>，一般来说，主内存存放在内存中，工作内存存放在高速缓存中，因此，工作内存数据操作速度很快。</p><p>但是，JMM有一个问题，就是主内存与工作内存不一致的问题，可能工作内存修改了某个工作变量，但是没有同步到主内存中。</p><h2 id="重排序问题"><a href="#重排序问题" class="headerlink" title="重排序问题"></a>重排序问题</h2><p>计算机在执行程序时，为了提高性能，编译器和处理器的常常会对指令做重排。</p><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。</p><p>当两条指令没有数据依赖性的时候，就又可能对他进行指令重排序。</p><h2 id="JMM-三个特性"><a href="#JMM-三个特性" class="headerlink" title="JMM 三个特性"></a>JMM 三个特性</h2><p>JMM规定了三个特性，原子性，有序性，可见性。</p><p>其中，重排序破坏了有序性，JMM内存结构破坏了可见性。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子性是指<strong>一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着“同生共死”的感觉</strong>。</p><p>JMM中read，load，use，store，write都是原子操作，所以，基本数据类型的操作都是具备原子性的(long和double例外，因为long和double占64位，可能存在读取半个变量)。</p><p>如果应用场景需要一个更大的原子范围，可以使用sychronized等来解决。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>可见性是指当一个线程修改了共享变量后，其他线程能够立即得知这个修改。变量更新后，主内存中立即更新，并且根据缓存一致性协议，其他线程中的变量也会更新。</p><p>除了sychronized和volatile，final也具有可见性，因为final是不可以被修改的。但是，也有一个前提，被final修饰的字段在构造器中一旦初始化完成，并且没有this引用逃逸，那么其他线程就能看到final字段的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisEscape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">ThisEscape</span><span class="params">(EventSource&lt;EventListener&gt; source)</span> </span>&#123;</span><br><span class="line">            id = <span class="number">1</span>;</span><br><span class="line">            source.registerListener(<span class="keyword">new</span> EventListener() &#123;</span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"id: "</span>+ThisEscape.<span class="keyword">this</span>.id);</span><br><span class="line">                        System.out.println(<span class="string">"name: "</span>+ThisEscape.<span class="keyword">this</span>.name);</span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            name = <span class="string">"flysqrlboy"</span>;</span><br><span class="line">            </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>ThisEscape在构造函数中引入了一个内部类EventListener，而内部类会自动的持有其外部类（这里是ThisEscape）的this引用。source.registerListener会将内部类发布出去，从而ThisEscape.this引用也随着内部类被发布了出去。但此时ThisEscape对象还没有构造完成 —— id已被赋值为1，但name还没被赋值，仍然为null。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile保证可见性与有序性，但是不保证原子性。</p><h3 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h3><p>在生成汇编代码时会在volatile修饰的共享变量进行写操作的时候会多出<strong>Lock前缀的指令。</strong></p><p>如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。</p><p>所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现<strong>缓存一致性</strong>协议：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p><p>这样针对volatile变量通过这样的机制就使得每个线程都能获得该变量的最新值。</p><h3 id="保证顺序性"><a href="#保证顺序性" class="headerlink" title="保证顺序性"></a>保证顺序性</h3><p>volatile会在内存中和插入一个内存屏障指令(lock指令)，来禁止指令重排序。</p><p>因此，volatile读操作跟普通变量相比，没有什么差别，但是写操作因为要插入许多内存屏障，因此，效率会低一些。</p><h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>在发生操作B之前，操作A产生的影响都能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等，它与时间上的先后发生基本没有太大关系。</p><ul><li><p>程序次序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作</p></li><li><p>管程锁定规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。同步快中线程安全。</p></li><li><p>volatile变量规则：对一个volatile变量的写操作happens-before对这个变量的读操作。</p></li><li><p>线程启动规则：Thread.start() happens before 所有操作。</p></li><li><p>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C</p></li><li><p>线程终止规则：线程中所有操作都happens-before对此线程的终止检测。</p></li><li><p>对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始</p></li><li><p>程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。</p></li></ul><p>满足任意一个原则，对于读写共享变量来说，就是线程安全。</p><h2 id="关于可见性的一些问题"><a href="#关于可见性的一些问题" class="headerlink" title="关于可见性的一些问题"></a>关于可见性的一些问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"><span class="comment">/*volatile*/</span> <span class="keyword">boolean</span> running=<span class="keyword">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"m start"</span>);</span><br><span class="line"><span class="keyword">while</span>(running) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"m end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">T t =<span class="keyword">new</span> T();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;t.m(),<span class="string">"t1"</span>).start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//睡眠1s，保证t1先执行</span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">t.running=<span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码肯定是无法停止t1线程的，加上volatile就可以了。</p><p>那么，对m加上sychronized呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> running=<span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"m start"</span>);</span><br><span class="line">        <span class="keyword">while</span>(running) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"m end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        T t =<span class="keyword">new</span> T();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;t.m(),<span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t.running=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样还是不可以的，因为sychronied修饰的代码块中并没有改写running变量,synchronized会把同步块内更新的值再给同步到内存中。</p><p>但是，当我在循环里里面加了一个打印输出的语句，就可以终止线程了，为什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> running=<span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"m start"</span>);</span><br><span class="line">        <span class="keyword">while</span>(running) &#123;</span><br><span class="line">            System.out.println(<span class="string">"2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"m end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        T t =<span class="keyword">new</span> T();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;t.m(),<span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t.running=<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，JVM对于现代的机器做了最大程度的优化，也就是说，最大程度的保障了线程和主存之间的及时的同步，也就是相当于虚拟机尽可能的帮我们加了个volatile，但是，当CPU被一直占用的时候，同步就会出现不及时，也就出现了后台线程一直不结束的情况。</p><p>也就是说，在cpu空闲的时候，可能会更新一下主内存的内容。</p><p>比如，我们在循环中sleep一下，亦可以结束线程。</p><h2 id="volatile使用场景"><a href="#volatile使用场景" class="headerlink" title="volatile使用场景"></a>volatile使用场景</h2><h3 id="状态标志"><a href="#状态标志" class="headerlink" title="状态标志"></a>状态标志</h3><p>用<code>volatile</code>来修饰一个<code>Boolean</code>状态标志，用于指示发生了某一次的重要事件，例如完成初始化或者请求停机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> shutdownRequested;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123; shutdownRequested = <span class="keyword">true</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (!shutdownRequested) &#123; </span><br><span class="line">        <span class="comment">// do stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><p>通过volatile禁止指令重排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 volatile 修饰。</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton sInstance;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123; <span class="comment">//(0)</span></span><br><span class="line">           <span class="keyword">synchronized</span> (Singleton.class) &#123; <span class="comment">//(1)         </span></span><br><span class="line">               <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;  <span class="comment">//(2)           </span></span><br><span class="line">                   sInstance = <span class="keyword">new</span> Singleton(); <span class="comment">//(3)    </span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sInstance;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="读操作远远大于写操作"><a href="#读操作远远大于写操作" class="headerlink" title="读操作远远大于写操作"></a>读操作远远大于写操作</h3><p>如果读操作远远超过写操作，您可以结合使用内部锁和<code>volatile</code>变量来减少公共代码路径的开销。下面的代码中使用<code>synchronized</code>确保增量操作是原子的，并使用<code>volatile</code>保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及<code>volatile</code>读操作，这通常要优于一个无竞争的锁获取的开销。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheesyCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java-内存模型&quot;&gt;&lt;a href=&quot;#Java-内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java 内存模型&quot;&gt;&lt;/a&gt;Java 内存模型&lt;/h2&gt;&lt;p&gt;JMM定义了内存中各个共享变量访问的规则。&lt;/p&gt;
&lt;p&gt;共享变量包括包括实例字段 静态字段和构成数组的元素，即所有线程都可以访问到的，不包括局部变量和方法参数，这是线程私有的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/11/1570784481491-1570784481498.png&quot; alt=&quot;title&quot;&gt;&lt;/p&gt;
&lt;p&gt;JMM规定了所有共享变量都存储在主内存，每条线程还有自己的工作内存，工作内存除了存储线程私有的局部变量以及方法参数等，还有该线程中需要用到的主内存中的共享变量的拷贝。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>synchronized关键字</title>
    <link href="http://yoursite.com/2019/10/09/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/10/09/synchronized关键字/</id>
    <published>2019-10-09T07:40:32.000Z</published>
    <updated>2019-10-22T08:46:15.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="锁定的是对象"><a href="#锁定的是对象" class="headerlink" title="锁定的是对象"></a>锁定的是对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class T &#123;</span><br><span class="line">private Object o=new Object();</span><br><span class="line">private int count=10;</span><br><span class="line">public void m() &#123;</span><br><span class="line">synchronized(o) &#123;</span><br><span class="line">count--;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;count=&quot;+count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>1.当一个线程想要去执行这段代码，必须要获得o的锁，当o被其他线程占用时，该线程必须要等其他线程释放o的锁，再去获得o的锁，才能执行。</p><p>2.synchronized关键字锁定的是对象不是代码块,demo中锁的是object对象的实例</p><p>3.可能锁对象包括： this， 临界资源对象，Class 类对象。</p><p>4.关于线程安全：加synchronized关键字之后不一定能实现线程安全，具体还要看锁定的对象是否唯一。</p><p>5.synchronized关键字修饰普通方法等同于synchronized(this)</p><h3 id="静态方法上锁"><a href="#静态方法上锁" class="headerlink" title="静态方法上锁"></a>静态方法上锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 静态方法加锁相当于给T.class文件枷锁</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">count--;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">"count="</span>+count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;复制代码</span><br></pre></td></tr></table></figure><p>给静态方法上锁，<strong>锁定的是类对象</strong>，类的.class文件是唯一的，所以说synchronize修饰静态方法或者锁定的对象是类的.class文件的时候在多线程中是可以实现线程安全的.。</p><p>需要注意的是如果一个线程A调用一个实例对象的非static synchronized方法，而线程B需要调用这个实例对象所属类的静态 synchronized方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法<strong>占用的锁是当前类的class对象</strong>，而访问非静态 synchronized 方法<strong>占用的锁是当前实例对象锁</strong>。</p><h3 id="同步和非同步方法同时调用"><a href="#同步和非同步方法同时调用" class="headerlink" title="同步和非同步方法同时调用"></a>同步和非同步方法同时调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"m1 start------"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"m1 end--------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"m2-----"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">T t=<span class="keyword">new</span> T();</span><br><span class="line"><span class="comment">//相当于new 一个线程，在run方法里执行m1 lamda表达式</span></span><br><span class="line"><span class="comment">/*new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@Override</span></span><br><span class="line"><span class="comment">public void run() &#123;</span></span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;t.m1(),<span class="string">"t1"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;t.m2(),<span class="string">"t1"</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 线程t1首先获得了当前对象t的锁，并执行m1。因为m2非同步的，不需要获得锁就可以执行，所以t2不需要获得锁就可以直接执行m2.只有执行synchronized方法才需要申请那把锁。</p><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">" m1"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">m2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">" m2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Test1 t=<span class="keyword">new</span> Test1();</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">t.m1();</span><br><span class="line">&#125;,<span class="string">"t1"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">t.m1();</span><br><span class="line"></span><br><span class="line">&#125;,<span class="string">"t2"</span>).start();;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">t1 m1</span><br><span class="line">t1 m2</span><br><span class="line">t2 m1</span><br><span class="line">t2 m2</span><br></pre></td></tr></table></figure><p>所谓重入锁，指的是以线程为单位，<strong>当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，</strong>而其他的线程是不可以的，synchronized和ReentrantLock都是可重入锁。<strong>可重入锁的意义在于防止死锁</strong>。实现原理实现是通过为每个锁关联一个请求计数和一个占有它的线程。当计数为0时，认为锁是未被占有的。线程请求一个未被占有的锁时，jvm讲记录锁的占有者，并且讲请求计数器置为1 。如果同一个线程再次请求这个锁，计数将递增；每次占用线程退出同步块，计数器值将递减。直到计数器为0,锁被释放。可重入锁锁定的必须得是同一个对象(或者是父类子类对象)。</p><h3 id="不要以字符串常量作为锁的对象。"><a href="#不要以字符串常量作为锁的对象。" class="headerlink" title="不要以字符串常量作为锁的对象。"></a>不要以字符串常量作为锁的对象。</h3><p>因为锁定的是对象。比如说你用到了一个类库，里边锁定了一个”Hello”,而你在你的代码中也锁定了”Hello”,实际上这锁定的是是同一个对象，容易发生死锁。</p><h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_11</span> </span>&#123;</span><br><span class="line">AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line"><span class="comment">/*if(count.get() &lt; 1000)*/</span></span><br><span class="line">count.incrementAndGet();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> Test_11 t = <span class="keyword">new</span> Test_11();</span><br><span class="line">List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">threads.add(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">t.m();</span><br><span class="line">&#125;</span><br><span class="line">&#125;));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(Thread thread : threads)&#123;</span><br><span class="line">thread.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(Thread thread : threads)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">thread.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(t.count.intValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AtoXXX本身的方法是<strong>具有原子性的</strong>，但是他<strong>比synchronized效率要高。</strong></p><h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p>synchronized使用的锁对象是存储在Java对象头里的，jvm中采用2个字来存储对象头(如果对象是数组则会分配3个字，多出来的1个字记录的是数组长度)，其主要结构是由Mark Word 和 Class Metadata Address 组成 。Class Metadata Address存储的是该对象属于类的地址，即可以判断这个对象属于哪一个类。</p><p>MarkWord有五种类型：</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/22/1571733588820-1571733588825.png" alt="title"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>MarkWord：</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/22/1571733631761-1571733631767.png" alt="title"></p><p>重量级锁(sychronized)：</p><p>锁标识位为10，<strong>其中指针指向的是monitor对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个 monitor 与之关联</strong>。只有获取到对象的monitor的线程，才可以执行方法或代码块，其他获取失败的线程会被阻塞，并放入同步队列中，进入BLOCKED状态。</p><h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p>当我们使用synchronized修饰方法名时，编译后会在方法名上生成一个ACC_SYNCHRONIZED标识来实现同步；当使用synchronized修饰代码块时，编译后会在代码块的前后生成monitorenter和monitorexit字节码来实现同步。</p><p>无论使用哪种方式实现，本质上都是<strong>对指定对象相关联的monitor的获取</strong>，只有获取到对象的monitor的线程，才可以执行方法或代码块，其他获取失败的线程会被阻塞，并放入同步队列中，进入BLOCKED状态。</p><p>为了解决线程安全的问题，Java提供了同步机制、互斥锁机制，这个机制保证了在同一问题内只有一个线程能访问共享资源。这个机制的保障来源于监视锁Monitor，每个对象都拥有自己的监视锁Monitor。</p><h3 id="Monitor的实现"><a href="#Monitor的实现" class="headerlink" title="Monitor的实现"></a>Monitor的实现</h3><p>数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = 0;</span><br><span class="line">    _waiters      = 0,</span><br><span class="line">    _recursions   = 0;</span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL;</span><br><span class="line">    _WaitSet      = NULL;</span><br><span class="line">    _WaitSetLock  = 0 ;</span><br><span class="line">    _Responsible  = NULL ;</span><br><span class="line">    _succ         = NULL ;</span><br><span class="line">    _cxq          = NULL ;</span><br><span class="line">    FreeNext      = NULL ;</span><br><span class="line">    _EntryList    = NULL ;</span><br><span class="line">    _SpinFreq     = 0 ;</span><br><span class="line">    _SpinClock    = 0 ;</span><br><span class="line">    OwnerIsThread = 0 ;</span><br><span class="line">  &#125;复制代码</span><br></pre></td></tr></table></figure><p>关键属性：</p><p>_owner：指向持有ObjectMonitor对象的线程</p><p>_WaitSet：存放处于wait状态的线程队列</p><p>_EntryList：存放处于等待锁block状态的线程队列</p><p>_recursions：锁的重入次数</p><p>_count：用来记录该线程获取锁的次数、</p><p>ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表( 每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSe t集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。</p><p>若执行线程调用 notify/notifyAll 方法，WaitSet 中的线程被唤醒，进入EntryList 中阻塞，等 待获取锁标记。若执行线程的同步代码执行结束，同样会释放锁标记，monitor 中的_Owner 标记赋值为 null，且计数器赋值为 0 计算。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/22/1571733665296-1571733665302.png" alt="title"></p><h3 id="等待唤醒机制与synchronized"><a href="#等待唤醒机制与synchronized" class="headerlink" title="等待唤醒机制与synchronized"></a>等待唤醒机制与synchronized</h3><p>所谓等待唤醒机制本篇主要指的是notify/notifyAll和wait方法，在使用这3个方法时，必须处于synchronized代码块或synchronized方法中，否则就会抛出IllegalMonitorStateException异常。</p><p>这是因为调用这几个方法前必须拿到当前对象的监视器monitor对象，也就是说notify/notifyAll和wait方法依赖于monitor对象，在前面的分析中，我们知道monitor 存在于对象头的Mark Word 中(存储monitor引用指针)，而synchronized关键字可以获取 monitor ，这也就是为什么notify/notifyAll和wait方法必须在synchronized代码块或者synchronized方法调用的原因。</p><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>锁的状态总共有四种：<strong>无锁状态、偏向锁、轻量级锁和重量级锁</strong>。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁。但是不可以降级。</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>sychronized就是重量级锁。</p><p>Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。JDK为了sychronized的优化，引入了轻量级锁和偏向锁。</p><p>一个依据：“<strong>对于绝大部分的锁，在整个同步周期内都是不存在竞争的</strong>。”</p><p>这是轻量级锁和偏向锁的依据。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>在大多数情况下，<strong>锁不仅不存在多线程竞争，而且总是由同一线程多次获得</strong>，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。</p><p>偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程<strong>再次请求锁时，无需再做任何同步操作，即获取锁的过程</strong>，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。</p><p>所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</p><p><strong>当有另外一个线程去尝试获取这个锁对象时</strong>，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态偏向锁可以提高有同步但竞争比较少的程序性能。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。</p><p>当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。</p><p>如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>重量级锁通过Monitor来实现，状态转换效率低。</p><p>轻量级锁基于CAS来实现。</p><p>偏向锁不需要同步，要是同一个线程申请锁。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/22/1571733707618-1571733707623.png" alt="title"></p><h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><ul><li>synchronized是悲观锁，这种线程一旦得到锁，其他需要锁的线程就挂起的情况就是悲观锁。</li><li>CAS操作的就是乐观锁，每次不加锁而是<strong>假设没有冲突</strong>而去完成某项操作，如果因为冲突失败就重试，直到成功为止。</li></ul><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>Atomic底层的实现就是CAS。</p><p>CAS是一个原子操作。</p><p>CAS机制当中使用了3个基本操作数：内存地址V，旧的值A，要修改的新值B。</p><p>更新一个变量的时候，<strong>只有当变量旧的值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B</strong>。 </p><p>这样说或许有些抽象，我们来看一个例子：</p><p>1.在内存地址V当中，存储着值为10的变量。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/22/1571733771170-1571733771178.png" alt="title"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>2.此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A=10，要修改的新值B=11。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/22/1571733804825-1571733804830.png" alt="title"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>3.在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/22/1571733837941-1571733837945.png" alt="title"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>4.线程1开始提交更新，首先进行A和地址V的实际值比较（Compare），发现A不等于V的实际值，提交失败。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/22/1571733873772-1571733873779.png" alt="title"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>5.线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为自旋。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/22/1571733898828-1571733898835.png" alt="title"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>6.这一次比较幸运，没有其他线程改变地址V的值。线程1进行Compare，发现A和地址V的实际值是相等的。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/22/1571733932675-1571733932684.png" alt="title"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>7.线程1进行SWAP，把地址V的值替换为B，也就是12。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/22/1571733960743-1571733960748.png" alt="title"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>当多个线程同时使用CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会挂起，仅是被告知失败，并且允许再次尝试，当然也允许实现的线程放弃操作。基于这样的原理，CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰。</p><p>Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。</p><p>CAS缺点：</p><ul><li><p>CPU开销较大<br>在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</p></li><li><p>ABA问题。</p><p>假设一个变量 A ，修改为 B之后又修改为 A，CAS 的机制是无法察觉的，但实际上已经被修改过了。如果在基本类型上是没有问题的，但是如果是引用类型呢？这个对象中有多个变量，我怎么知道有没有被改过？加个版本号啊。每次修改就检查版本号，如果版本号变了，说明改过，就算你还是 A，也不行。</p><p>AtomicReference就是这样做的。</p></li></ul><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除.</p><p>主要通过逃逸分析来判定。</p><p>何为逃逸？</p><p>当一个对象在方法中被定义后，如果被外部方法所引用，甚至可能会被外部线程所访问到，称为线程逃逸。</p><p>如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p><p>因为代码中会有许多隐形的锁，比如String。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p><p>例如在一个for循环里枷锁，就可以把锁提到外面。</p><h3 id="自旋锁（空转打圈儿）"><a href="#自旋锁（空转打圈儿）" class="headerlink" title="自旋锁（空转打圈儿）"></a>自旋锁（空转打圈儿）</h3><p>适用于共享数据只会锁定很短的一段时间。</p><p>当获取锁的过程中，未获取到。为了提高效率，JVM 自动执行若干次空循环（while循环中啥也不做），再次申请 锁，而不是进入阻塞状态的情况。称为自旋锁。自旋锁提高效率就是避免线程状态的变更。<strong>避免线程挂起导致的花费</strong>。</p><p>互斥同步对性能影响最大的是阻塞，即线程的挂起和恢复。许多应用中，<strong>共享数据的锁定状态只会持续很短的一段时间</strong>。如果有两个以上的处理器，能让两个或者以上的线程并行执行，我们就可以让后面请求锁的线程等待一下，但是并不放弃处理器的执行时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p><p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p><p>自适应的自旋锁：</p><p>自适应的自旋锁意味着自旋的时间不在固定了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得锁，并且持有者的线程正在运行中，那么虚拟机认为这次自旋也很有可能再次成功，因此会自旋等待较长的时间。相反的是，假如对于某个锁，自旋等待很少成功，那么以后获取这个锁的时候即有可能省略掉这个过程。</p><p><strong>一般自旋锁可以搭配CAS来使用。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h2&gt;&lt;h3 id=&quot;锁定的是对象&quot;&gt;&lt;a href=&quot;#锁定的是对象&quot; class=&quot;headerlink&quot; title=&quot;锁定的是对象&quot;&gt;&lt;/a&gt;锁定的是对象&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class T &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	private Object o=new Object();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	private int count=10;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public void m() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		synchronized(o) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			count--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			System.out.println(Thread.currentThread().getName()+&amp;quot;count=&amp;quot;+count);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>操作系统同步互斥</title>
    <link href="http://yoursite.com/2019/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/"/>
    <id>http://yoursite.com/2019/10/08/操作系统同步互斥/</id>
    <published>2019-10-08T12:21:50.000Z</published>
    <updated>2019-10-09T06:35:36.533Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TSL指令"><a href="#TSL指令" class="headerlink" title="TSL指令"></a>TSL指令</h2><p>类似于java的CAS。</p><p>Test and set lock.<strong>这是一个原子操作，他的读写操作是不分开的</strong>。</p><a id="more"></a><p>TSL指令实现锁机制：当lock为0时，任何进程都可以使用TSL指令将其设置为1，然后访问临界区，操作结束时，再将lock重新设置为0.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void acquire(int *lock)&#123;</span><br><span class="line">    while(TestAndSet(*lock));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void release(int *lock)&#123;</span><br><span class="line">    *lock = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在acquire函数中，如果TestAndSet返回1，那么while循环就一直执行（也就是在这里等待），直到另一个线程调用release。当然，这个实现看起来不太好，主要是<strong>等待的线程会不停的检查，浪费CPU，这个问题称之为忙等待</strong>（busy-wait or spin-wait），所以这个lock的实现也叫自旋锁spinlock。解决办法是如果需要等待，那么该线程主动交出执行权，让其他线程有机会执行，这种方式称之为让权等待（yield-wait or sleep-wait），应用开发人员使用的互斥锁一都是指这种情况。</p><p>以上的这些机制都是忙等待。<br>当一个进程想进入临界区，先检查是否允许进入，若不允许，将会原地等待，直到允许为止。<br>浪费CPU。</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>可以同时多个线程访问临界区，有P,V两个原子操作。</p><p>P(): 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</p><p>V(); 对信号量执行 +1 操作，唤醒睡眠的进程让其完成 P操作。</p><p>要是信号量的取值变为了1，那么就变成了互斥量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mutex=<span class="keyword">new</span> Semaphore(<span class="number">1</span>)</span><br><span class="line">mutex.P();</span><br><span class="line">临界区</span><br><span class="line">mutex.V();</span><br></pre></td></tr></table></figure><p>信号量主要可以解决两类问题。</p><ul><li><strong>互斥问题</strong>。同一时刻只可以有一个线程访问某一个临界资源。</li><li><strong>同步问题</strong>。线程A需要等待线程B执行完毕后才可以继续执行。</li></ul><h3 id="信号量解决生产者消费者问题"><a href="#信号量解决生产者消费者问题" class="headerlink" title="信号量解决生产者消费者问题"></a>信号量解决生产者消费者问题</h3><ul><li>同一时刻，只能有一个生产者或者是消费者访问缓冲区。(互斥问题)</li><li>缓冲区满时，生产者需要等待消费者消费。(同步问题)</li><li>缓冲区空时，消费者需要等待生产者生产。(同步问题)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥量</span></span><br><span class="line">mutex = <span class="keyword">new</span> Semophore(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//代表缓冲区有多少产品</span></span><br><span class="line">products = <span class="keyword">new</span> Semophore(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//代表缓冲区里有多大位置</span></span><br><span class="line">remainPosition = <span class="keyword">new</span> Semophore(n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line">remainPosition-&gt;P();</span><br><span class="line">mutex-&gt;P();</span><br><span class="line">Add();</span><br><span class="line">mutex-&gt;V();</span><br><span class="line">products-&gt;V();</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者，先去申请产品，在空出一个位置</span></span><br><span class="line">products-&gt;P();</span><br><span class="line">mutex-&gt;P();</span><br><span class="line">Remove();</span><br><span class="line">mutex-&gt;V();</span><br><span class="line">remainPosition-V();</span><br></pre></td></tr></table></figure><p>注意，empty-&gt;P()和mutex-&gt;P()不可以交换顺序。</p><p>要是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mutex-&gt;P()</span><br><span class="line">empty-P();</span><br></pre></td></tr></table></figure><p><strong>假设我们现在的empty已经是0了，mutex先执行也变为了0，但是当执行到下一步empty-P()，发现自己需要阻塞，但是mutex还未释放，会造成死锁。</strong><br>两个V()操作可以交换顺序。</p><h2 id="管程-Monitor"><a href="#管程-Monitor" class="headerlink" title="管程(Monitor)"></a>管程(Monitor)</h2><p><strong>管程=互斥量+条件变量</strong>。<br><strong>互斥量：可以保证共享资源在同一时间只能有一个进程访问</strong>。<br><strong>条件变量：正在管程内的线程可以放弃对管程的控制权，等待某些条件发生再继续执行</strong>。<br>每个条件变量实际上代表的是一个等待队列。<br>当wait时，进程释放锁，挂起，并插入该条件变量的等待队列。<br>signal时，唤醒条件变量等待队列中的进程。</p><p>任意时刻管程中只能有一个活跃进程。<br>条件变量：解决死锁问题，挂起进程。<br>条件变量。wait：释放锁，挂起 notify：<strong>唤醒等待队列中一个线程</strong>。防止死锁。</p><h3 id="管程解决生产者消费者问题"><a href="#管程解决生产者消费者问题" class="headerlink" title="管程解决生产者消费者问题"></a>管程解决生产者消费者问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">mutex buffer;<span class="comment">//互斥量，一次只能由一个进程访问</span></span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">Condition full,empty;<span class="comment">//条件变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Produce</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//获取互斥量</span></span><br><span class="line">   mutex.acquire();</span><br><span class="line">   <span class="comment">//容器满了，线程挂起</span></span><br><span class="line">   <span class="keyword">while</span>(count==n)&#123;</span><br><span class="line">      wait(full);</span><br><span class="line">   &#125;</span><br><span class="line">   Add c;</span><br><span class="line">   count++;</span><br><span class="line">   <span class="comment">//唤醒因没有产品挂起的线程</span></span><br><span class="line">   notify(empty);</span><br><span class="line">   mutex.release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Produce</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//获取互斥量</span></span><br><span class="line">   mutex.acquire();</span><br><span class="line">   <span class="comment">//容器满了，线程挂起</span></span><br><span class="line">   <span class="keyword">while</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">      wait(empty);</span><br><span class="line">   &#125;</span><br><span class="line">   Remove c;</span><br><span class="line">   count--;</span><br><span class="line"><span class="comment">//唤醒因容器满了挂起的线程</span></span><br><span class="line">   notify(full); </span><br><span class="line">   mutex.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TSL指令&quot;&gt;&lt;a href=&quot;#TSL指令&quot; class=&quot;headerlink&quot; title=&quot;TSL指令&quot;&gt;&lt;/a&gt;TSL指令&lt;/h2&gt;&lt;p&gt;类似于java的CAS。&lt;/p&gt;
&lt;p&gt;Test and set lock.&lt;strong&gt;这是一个原子操作，他的读写操作是不分开的&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统进程</title>
    <link href="http://yoursite.com/2019/10/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/10/07/操作系统进程/</id>
    <published>2019-10-07T13:54:57.000Z</published>
    <updated>2019-10-09T05:51:55.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是<strong>资源分配的基本单位</strong>，他是程序运行时的一个实例。<br>程序运行时，系统会创建一个进程，并分配相关的资源。</p><p><strong>程序是静态的，进程是动态的</strong>。一个程序可以对应多个进程，一个进程可以包括多个程序。</p><p>进程=程序+数据+状态信息。</p><a id="more"></a><h3 id="PCB-进程控制块"><a href="#PCB-进程控制块" class="headerlink" title="PCB(进程控制块)"></a>PCB(进程控制块)</h3><p>每个进程都有一个进程控制块，他是<strong>进程的唯一标识</strong>。<br>进程块描述进程的基本信息和运行状态。所谓的进程的创建与销毁，就是对PCB的创建与销毁。</p><p>各个进程块在内存中<strong>应该是以链表的形式存储</strong>的，因为进程块需要频繁的进行插入与删除。</p><h3 id="进程的生命周期"><a href="#进程的生命周期" class="headerlink" title="进程的生命周期"></a>进程的生命周期</h3><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/06/09/1560068275561-1560068275567.png" alt="title"><br><strong>最主要的就是就绪，运行，阻塞三个状态。</strong><br>操作系统创建一个进程完成后，并为其分配了除了cpu之外的所有的资源，那么进程进入<strong>就绪(ready)状态</strong>，当CPU处于空闲的时候，就绪状态的进程占用CPU，进入<strong>运行（running）状态</strong>。正在执行的进程，由于等待某个事件发生而无法执行时，便放弃CPU而处于<strong>阻塞（waiting）状态</strong>。</p><ul><li><p>ready-&gt;running<br>当没有其他进程占用CPU，所有的ready进程就可以去竞争CPU，获得CPU的进程进入running状态。</p></li><li><p>running-&gt;waiting<br>正在执行的进程，因为等待某个事件发生而放弃CPU时，进入waiting状态。比如I/O阻塞，申请缓冲区不能满足、等待信件等。</p></li><li><p>running-&gt;ready<br>处于执行状态的进程在其执行过程中，因分配给它的一个时间片已用完或更高优先级的进程抢占而不得不让出处理机，于是进程从执行状态转变成就绪状态。</p></li><li><p>waiting-&gt;ready<br>当等待事件完成的时候，从阻塞进入就绪态。<br>需要正在运行的进程对他唤醒。</p></li></ul><h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>因为所有的进程都有自己独立的地址空间。</p><ul><li><p>页表以及地址空间的切换。</p></li><li><p>寄存器，程序计数器，堆栈的切换。</p></li></ul><p>进程上下文切换过程：</p><ul><li><p>保存现场。暂停当前进程，从运行态变为其他状态，保存当前进程的上下文，包括CPU寄存器状态，程序计数器状态等。保存在PCB中。</p></li><li><p>选取进程。调度另一个进程从就绪转为运行。</p></li><li><p>恢复现场。从内存中恢复下一个要执行的进程的上下文，恢复该进程原来的状态到寄存器，恢复程序执行上一次暂停的地方。从PCB中取。</p><p>在进程切换的过程中，页表会改变，地址空间会改变，高速缓存中的存储的数据过期，也需要进行切换。</p></li></ul><h3 id="进程挂起"><a href="#进程挂起" class="headerlink" title="进程挂起"></a>进程挂起</h3><p>将<strong>进程从内存转移到磁盘上</strong>。<br>进程挂起状态包括<strong>阻塞挂起</strong>（在外存，处于阻塞）和就绪挂起（在外存，就绪状态）。</p><p>进程挂起状态转换：</p><ul><li>阻塞到阻塞挂起。内存不够时，将阻塞状态的进程移到外存，变为阻塞挂起状态。</li><li>就绪到就绪挂起。有高优先级阻塞和低优先级就绪，那么将低优先级挂起。</li><li>运行到就绪挂起。</li></ul><p>挂起是将进程从内存转移到磁盘，而阻塞是由于资源得不到满足暂时无法获取CPU，还是在内存的。</p><h3 id="状态队列"><a href="#状态队列" class="headerlink" title="状态队列"></a>状态队列</h3><p><strong>操作系统中维护了多个队列，不同的队列来表示不同的状态。</strong><br>就绪队列，阻塞队列，运行队列等。<br>方便操作系统管理进程。<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/06/09/1560078704085-1560078704092.png" alt="title"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>当我们并发的需求时，如果采用多进程的话，因为进程每个进程都有自己的独立空间，进程间通信麻烦，还有进程切换的时候需要进行保护现场恢复现场，十分耗费资源，效率低下。<br>于是，引入了线程。</p><p>线程是轻量级的进程。所有的线程共享进程的地址空间，进程间开销小，通信方便。<br>进程中的所有线程共享代码，文件等资源。<br>但是，<strong>他们都有自己的堆栈，寄存器等</strong>。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/06/09/1560080472816-1560080472823.png" alt="title"></p><p>进程是资源分配的角色，线程是执行功能的角色。<br>一个线程崩溃，整个进程崩溃。因此，在对于安全性过高的场合，我们一般使用进程来解决并发问题。比如说，我们的浏览器，每开一个界面，就创建一个进程。</p><h3 id="OS中两种线程"><a href="#OS中两种线程" class="headerlink" title="OS中两种线程"></a>OS中两种线程</h3><p><strong>根据操作系统能够感知到线程，分为用户线程以及内核线程。</strong></p><h4 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h4><p>内核完成线程的创建以及管理。<br>内核分配CPU是以线程为单位的。</p><p>优点：</p><ul><li>一个线程阻塞不会导致整个进程阻塞。</li><li>内核会为每一个线程分配CPU，对于多线程的进程，时间片时间大大增加。</li></ul><p>缺点：</p><ul><li>线程切换要从用户态转移到内核态，耗费大，速度慢。</li></ul><h4 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h4><p>用户级的线程库完成线程的创建以及管理。<br><strong>内核资源的分配仍然是按照进程（用户进程）进行分配的。</strong><br>不依赖于操作系统的内核，<strong>操作系统感受不到用户线程的存在</strong>。</p><p>缺点：</p><ul><li>因此，对于操作系统来说，这个用户线程所属的进程是没有线程的，因此，<strong>一个线程的阻塞将导致整个进程的阻塞</strong>，因为，对于操作系统来说，他看到的只是这个进程，这个用户线程阻塞，对操作系统来说就是整个进程阻塞，所以这个进程将会阻塞。</li><li>因为没有操作系统的管制，一个用户线程拿到了分配给这个进程的时间片，他会一直霸占着，除非她主动放弃，或者到这个时间片结束，可能会导致别的用户线程没有机会执行。</li></ul><p>优点：</p><ul><li>但是，用户线程切换不需要从用户态转到内核态，消耗小，速度快。</li></ul><p>总的来说，对于用户线程，操作系统是感受不到，<strong>还是会把它看作一个进程来进行处理</strong>。</p><p><a href="https://www.cnblogs.com/Lee-johnH/p/6663618.html" target="_blank" rel="noopener">内核线程与用户线程</a></p><h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><p>将用户线程与内核线程绑定。主要有一对一，多对一，以及多对多。操作系统中主要使用多对多。</p><h4 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a>多对一</h4><p>多个用户线程与一个内核线程绑定。</p><p>缺点是一个线程阻塞，这多个用户线程都会被阻塞。</p><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>一个用户线程绑定一个内核线程。</p><p>缺点是每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大，会影响到应用程序的性能。</p><h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>将 n 个用户级线程映射到 m 个内核级线程上，要求 m &lt;= n。</p><p>不会出现一个用户线程阻塞，所有线程都阻塞的情况。</p><p>详解<a href="https://www.cnblogs.com/stemon/p/4855583.html" target="_blank" rel="noopener">多线程模型</a></p><h2 id="与进程区别"><a href="#与进程区别" class="headerlink" title="与进程区别"></a>与进程区别</h2><ul><li>进程是资源分配的最小单位，线程是程序执行的最小单位。</li><li>进程有自己的独立空间，每创建一个进程，都要为他分配独立的地址空间，花费很大。而线程是共享进程地址空间的，花费要小很多。</li><li>进程之间的通信需要以通信的方式（IPC)进行，需要通过内核来通信。而线程可以通过共享变量等方式进行。</li><li>进程之间切换时间比线程之间切换时间要大得多。因为进程之间页表是不同的，需要切换页表，开销比较大。因为各个进程页表不同，TLB，缓存信息可能都需要重新加载。而线程是共享的。</li><li>一个进程死掉，对其他进程没有影响；一个线程死掉，整个进程就会崩溃。<br><strong>当一个线程向非法地址读取或者写入，无法确认这个操作是否会影响同一进程中的其它线程，所以只能是整个进程一起崩溃。</strong></li></ul><h2 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h2><p>与进程上下文切换不同的是，线程上下文切换没有页表以及地址空间的切换，因为同一个进程的线程共享同一个地址空间。只需要进行程序计数器，寄存器，以及线程的堆栈的切换。</p><h2 id="fork-and-exec"><a href="#fork-and-exec" class="headerlink" title="fork and exec"></a>fork and exec</h2><p>linux的fork 和exec 函数。</p><p>fork() 复制出一个子进程，<strong>这个进程几乎是当前进程的一个拷贝</strong>：子进程和父进程使用相同的代码段；子进程复制父进程的堆栈段和数据段。这样，父进程的所有数据都可以留给子进程，但是，子进程一旦开始运行，<strong>虽然它继承了父进程的一切数据，但实际上数据却已经分开，相互之间不再有影响了</strong>，也就是说，它们之间不再共享任何数据了。它们再要交互信息时，只有通过进程间通信来实现，这将是我们下面的内容。既然它们如此相象，系统如何来区分它们呢？这<strong>由函数的返回值来决定的</strong>。对于父进程， fork函数返回了子程序的进程号，而对于子程序，fork函数则返回零。在操作系统中，我们用ps函数就可以看到不同的进程号，对父进程而言，它的进程号是由比它更低 层的系统调用赋予的，而对于子进程而言，它的进程号即是fork函数对父进程的返回值。在程序设计中，父进程和子进程都要调用函数fork（）下面的代码，而我们就是利用fork（）函数对父子进程的不同返回值用if…else…语句来实现让父子进程完成不同的功能。</p><p>exec将替换现有进程，执行exec的程序。</p><p>一个进程一旦调用exec类函数，它本身就”死亡”了，<strong>系统把代码段替换成新的程序的代码，废弃原有的数据段和堆栈段</strong>，并为新程序分配新的数据段与堆栈段，唯一留下的，就是进程号，也就是说，对系统而言，还是同一个进程，不过已经是另一个程序了。</p><h2 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="headerlink" title="僵尸进程和孤儿进程"></a>僵尸进程和孤儿进程</h2><p>正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。</p><p>一个子进exit()之后，内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。直到父进程通过wait / waitpid来取时才释放。这样，一个进程才算是完全终止掉。</p><p>当一个父进程迟迟没有调用wait()，这个子进程内存中保存的信息就迟迟不会释放，包括进程号也不会释放，操作系统的进程号是有限的，因此僵尸进程的危害很大。</p><p>当一个父进程退出，子进程还在运行，那么子进程将会称为孤儿进程。孤儿进程会被init进程处理，使用wait()完成进程的终止等，因此，孤儿进程是没有坏处的。</p><p><strong>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</strong></p><p><strong>僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h2&gt;&lt;p&gt;进程是&lt;strong&gt;资源分配的基本单位&lt;/strong&gt;，他是程序运行时的一个实例。&lt;br&gt;程序运行时，系统会创建一个进程，并分配相关的资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序是静态的，进程是动态的&lt;/strong&gt;。一个程序可以对应多个进程，一个进程可以包括多个程序。&lt;/p&gt;
&lt;p&gt;进程=程序+数据+状态信息。&lt;/p&gt;
    
    </summary>
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统概述</title>
    <link href="http://yoursite.com/2019/10/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2019/10/07/操作系统概述/</id>
    <published>2019-10-07T12:47:33.000Z</published>
    <updated>2019-10-11T02:34:30.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><p>操作系统主要进行应用程序管理，资源管理，外设管理等工作。</p><p><strong>在操作系统中，将CPU抽象为进程，将内存抽象为地址空间，将磁盘抽象为文件。</strong><br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/30/1559223725482-1559223725514.png" alt="title"></p><p>OS=shell+kernel.shell就是GUI或者是命令行。Kernel是操作系统的核心。</p><a id="more"></a><p>kernel主要完成的工作包括<strong>CPU调度，物理内存虚拟内存的管理，文件系统的管理，中断处理，外设管理等</strong>。</p><p>kernel的特征：</p><ul><li><strong>并发</strong>（应用并发执行）。</li><li><strong>共享</strong>。某一个公共资源是可以共享访问的还是互斥访问的。</li><li><strong>虚拟化</strong>。将物理实体虚拟化为逻辑实体。主要包括时分复用(时间片)和空分复用(虚拟内存)。</li><li><strong>异步</strong>。</li></ul><h2 id="OS启动过程"><a href="#OS启动过程" class="headerlink" title="OS启动过程"></a>OS启动过程</h2><p>Disk：存储bootloader以及OS.<br>BIOS:基本IO处理系统。</p><p>最先放入内存的是BIOS启动固件。BIOS的第一步是检测外设，完成后，将bootloader加载进内存，并且CPU控制权转交给bootloader，bootloader再将磁盘上的OS加载进内存，这是OS掌控CPU。</p><p>BIOS—&gt;加载bootloader—&gt;加载OS。（所以说我们安装系统的时候要先进入BIOS设置启动项，这个启动项就是bootloader）。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/30/1559224752551-1559224752559.png" alt="title"></p><h2 id="系统调用，中断，异常"><a href="#系统调用，中断，异常" class="headerlink" title="系统调用，中断，异常"></a>系统调用，中断，异常</h2><p>都需要从用户态转移到内核态。</p><h3 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h3><p>来源于外设。</p><p>为了<strong>支持CPU 和设备之间 的 并行操作</strong>。当IO事件完成之后，设备中断通知CPU，CPU在进行相应事件的处理。可以看作是一种异步操作啊。</p><p>当CPU 启动设备进行输入/输出后 ，设备便可以独立工作，CPU 转去处理与此次输入/输出不相关的 事情；当设备完成输入/输出后，通过向CPU 发中断报告此次 输入/输出的结果，让CPU 决定如何处理以后的事情。</p><h4 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h4><ul><li>设备（硬件）将中断事件的ID传递给中断寄存器。不<strong>同的中断ID范围代表不同的中断类型</strong>。</li><li>CPU在执行完一条指令后，会查看中断寄存器，假如有中断的话，进行中断处理。</li><li>CPU保存现场。保存各种寄存器等。</li><li>CPU 根据中断码查中断向量表，获得与该中断相关的处理程序的入口地址。</li><li>进行相应中断处理。</li><li>恢复之前保存的处理状态。</li></ul><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>来源于应用程序。CPU执行指令非法。</p><p>异常过程与中断过程差不多，也是保存现场，处理，恢复现场这几个过程。</p><p>但是不同的是，异常一般是交给进程自己来处理，而中断是由内核的中断函数来处理，根据不同的中断类型执行不同的中断函数。</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>当应用程序需要调用系统级别的函数请求。</p><h4 id="系统调用过程"><a href="#系统调用过程" class="headerlink" title="系统调用过程"></a>系统调用过程</h4><ul><li>每一个系统调用对应一个系统调用号。</li><li>根据系统调用号选取相应的系统调用例程进行系统调用。</li><li>返回系统调用结果。</li></ul><p>系统调用需要从用户态切换到内核态。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>系统调用，中断，异常机制其实都是大同小异。在操作系统中都维持着一个表，中断是中断号和中断函数对应，系统调用是系统调用号和系统调用函数，根据ID去调用相应的函数，返回结果。</p><p>而且OS都需要从用户态转到内核态。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是操作系统&quot;&gt;&lt;a href=&quot;#什么是操作系统&quot; class=&quot;headerlink&quot; title=&quot;什么是操作系统&quot;&gt;&lt;/a&gt;什么是操作系统&lt;/h2&gt;&lt;p&gt;操作系统主要进行应用程序管理，资源管理，外设管理等工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在操作系统中，将CPU抽象为进程，将内存抽象为地址空间，将磁盘抽象为文件。&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/30/1559223725482-1559223725514.png&quot; alt=&quot;title&quot;&gt;&lt;/p&gt;
&lt;p&gt;OS=shell+kernel.shell就是GUI或者是命令行。Kernel是操作系统的核心。&lt;/p&gt;
    
    </summary>
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>IO线程模型</title>
    <link href="http://yoursite.com/2019/09/30/IO%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/09/30/IO线程模型/</id>
    <published>2019-09-30T11:31:56.000Z</published>
    <updated>2019-10-11T02:36:41.933Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阻塞I-O"><a href="#阻塞I-O" class="headerlink" title="阻塞I/O"></a>阻塞I/O</h1><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/07/1557216950760-1557216950760.png" alt="title"></p><ul><li>每一条连接都需要建立一个独立的线程来处理，机器耗费线程资源。</li><li>当没有数据读写时，线程还会阻塞。</li></ul><a id="more"></a><h1 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h1><p><strong>IO多路复用+线程池来实现</strong>。<br>I/O多路复用来解决会有多个线程阻塞的问题，IO多路复用只会造成一个线程阻塞。<br>线程池不必为每个连接都建立一个新的线程。</p><p>Reactor模型，是指通过一个或多个输入同时传递给服务处理器的服务请求的事件驱动处理模式。 服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor模式也叫Dispatcher模式，即<strong>I/O多路复用统一监听事件，收到事件后分发</strong>(Dispatch给某进程)。</p><p>Reactor两个关键组成：</p><ul><li>Reactor<br>负责监听和分发事件，分发给适当的处理程序来对IO事件做出反应。</li><li>Handler<br>处理程序执行I/O事件要完成的实际事件.<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/07/1557217752478-1557217752483.png" alt="title"><h2 id="单Reactor"><a href="#单Reactor" class="headerlink" title="单Reactor"></a>单Reactor</h2><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/07/1557217879896-1557217879896.png" alt="title"></li><li>Reactor对象通过select不断轮询监控客户端请求事件，收到事件后通过dispatch进行分发</li><li>如果是建立连接请求事件，则由Acceptor通过accept处理连接请求，然后创建一个Handler对象处理连接完成后的后续业务处理</li><li>如果不是建立连接事件，则Reactor会分发调用连接对应的Handler来响应</li><li>Handler会完成read-&gt;业务处理-&gt;send的完整业务流程<h2 id="单Reactor多线程"><a href="#单Reactor多线程" class="headerlink" title="单Reactor多线程"></a>单Reactor多线程</h2>主要通过建立一个线程池。<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/07/1557218020262-1557218020277.png" alt="title"><br>Worker线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给Handler进行处理。</li></ul><h2 id="主从Reactor多线程"><a href="#主从Reactor多线程" class="headerlink" title="主从Reactor多线程"></a>主从Reactor多线程</h2><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/07/1557218140668-1557218140683.png" alt="title"></p><ul><li>Reactor主线程MainReactor对象通过select监控建立连接事件，收到事件后通过Acceptor接收，处理建立连接事件。</li><li>Accepto处理建立连接事件后，MainReactor将Socket分配Reactor子线程给<strong>SubReactor进行处理</strong>。</li><li>SubReactor将Socket加入连接队列进行监听，并创建一个Handler用于处理各种连接事件，例如读写操作。</li><li>当有新的事件发生时，SubReactor会调用连接对应的Handler进行响应</li><li>Handler通过read读取数据后，会分发给后面的Worker线程池进行业务处理</li><li>Worker线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给Handler进行处理</li><li>Handler收到响应结果后通过send将响应结果返回给client<h2 id="NIO代码"><a href="#NIO代码" class="headerlink" title="NIO代码"></a>NIO代码</h2></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> nioDemo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.CharBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*服务器端，:接收客户端发送过来的数据并显示，</span></span><br><span class="line"><span class="comment"> *服务器把上接收到的数据加上"echo from service:"再发送回去*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceSocketChannelDemo</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPEchoServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="comment">/*服务器地址*/</span></span><br><span class="line">        <span class="keyword">private</span> InetSocketAddress localAddress; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TCPEchoServer</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.localAddress = <span class="keyword">new</span> InetSocketAddress(port);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            ServerSocketChannel ssc = <span class="keyword">null</span>;</span><br><span class="line">            Selector selector = <span class="keyword">null</span>;           </span><br><span class="line">            Random rnd = <span class="keyword">new</span> Random();   </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/*创建选择器*/</span></span><br><span class="line">                selector = Selector.open();</span><br><span class="line">                <span class="comment">/*创建服务器通道*/</span></span><br><span class="line">                ssc = ServerSocketChannel.open();</span><br><span class="line">                ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">/*设置监听服务器的端口，设置最大连接缓冲数为100*/</span></span><br><span class="line">                ssc.bind(localAddress, <span class="number">100</span>);</span><br><span class="line">                <span class="comment">/*服务器通道只能对tcp链接事件感兴趣*/</span></span><br><span class="line">                ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                System.out.println(<span class="string">"server start failed"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            System.out.println(<span class="string">"server start with address : "</span> + localAddress);  </span><br><span class="line">            <span class="comment">/*服务器线程被中断后会退出*/</span></span><br><span class="line">            <span class="keyword">try</span>&#123;   </span><br><span class="line">                <span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;      </span><br><span class="line">                    <span class="keyword">int</span> n = selector.select();</span><br><span class="line">                    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Set&lt;SelectionKey&gt; keySet = selector.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; it = keySet.iterator();</span><br><span class="line">                    SelectionKey key = <span class="keyword">null</span>; </span><br><span class="line">                    <span class="keyword">while</span>(it.hasNext())&#123;               </span><br><span class="line">                        key = it.next();</span><br><span class="line">                        <span class="comment">/*防止下次select方法返回已处理过的通道*/</span></span><br><span class="line">                        it.remove();           </span><br><span class="line">                        <span class="comment">/*若发现异常，说明客户端连接出现问题,但服务器要保持正常*/</span></span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            <span class="comment">/*ssc通道只能对链接事件感兴趣*/</span></span><br><span class="line">                            <span class="keyword">if</span>(key.isAcceptable())&#123;  </span><br><span class="line">                                <span class="comment">/*accept方法会返回一个普通通道，</span></span><br><span class="line"><span class="comment">                                     每个通道在内核中都对应一个socket缓冲区*/</span></span><br><span class="line">                                SocketChannel sc = ssc.accept();</span><br><span class="line">                                sc.configureBlocking(<span class="keyword">false</span>);      </span><br><span class="line">                     <span class="comment">/*向选择器注册这个通道和普通通道感兴趣的事件，同时提供这个新通道相关的缓冲区*/</span></span><br><span class="line">                                <span class="keyword">int</span> interestSet = SelectionKey.OP_READ;                   </span><br><span class="line">                                sc.register(selector, interestSet, <span class="keyword">new</span> Buffers(<span class="number">256</span>,<span class="number">256</span>));</span><br><span class="line">                                System.out.println(<span class="string">"accept from"</span>+ sc.getRemoteAddress());</span><br><span class="line">                            &#125;    </span><br><span class="line">                            <span class="comment">/*（普通）通道感兴趣读事件且有数据可读*/</span></span><br><span class="line">                            <span class="keyword">if</span>(key.isReadable())&#123;           </span><br><span class="line">                                <span class="comment">/*通过SelectionKey获取通道对应的缓冲区*/</span></span><br><span class="line">                                Buffers  buffers = (Buffers)key.attachment();</span><br><span class="line">                                ByteBuffer readBuffer = buffers.getReadBuffer();</span><br><span class="line">                                ByteBuffer writeBuffer = buffers.gerWriteBuffer();</span><br><span class="line">                                 </span><br><span class="line">                                <span class="comment">/*通过SelectionKey获取对应的通道*/</span></span><br><span class="line">                                SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                                 </span><br><span class="line">                                <span class="comment">/*从底层socket读缓冲区中读入数据*/</span></span><br><span class="line">                                sc.read(readBuffer);</span><br><span class="line">                                readBuffer.flip();</span><br><span class="line">                                 </span><br><span class="line">                                <span class="comment">/*解码显示，客户端发送来的信息*/</span></span><br><span class="line">                                CharBuffer cb = utf8.decode(readBuffer);</span><br><span class="line">                                System.out.println(cb.array());                 </span><br><span class="line">                                readBuffer.rewind(); </span><br><span class="line">                                <span class="comment">/*准备好向客户端发送的信息*/</span></span><br><span class="line">                                <span class="comment">/*先写入"echo:"，再写入收到的信息*/</span></span><br><span class="line">                                writeBuffer.put(<span class="string">"echo from service:"</span>.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">                                writeBuffer.put(readBuffer);</span><br><span class="line">                                readBuffer.clear();  </span><br><span class="line">                                <span class="comment">/*设置通道写事件*/</span></span><br><span class="line">                                key.interestOps(key.interestOps() | SelectionKey.OP_WRITE);</span><br><span class="line">                                                                 </span><br><span class="line">                            &#125;</span><br><span class="line">                             </span><br><span class="line">                            <span class="comment">/*通道感兴趣写事件且底层缓冲区有空闲*/</span></span><br><span class="line">                            <span class="keyword">if</span>(key.isWritable())&#123; </span><br><span class="line">                                doSomething();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                            System.out.println(<span class="string">"service encounter client error"</span>);</span><br><span class="line">                            <span class="comment">/*若客户端连接出现异常，从Seletcor中移除这个key*/</span></span><br><span class="line">                            key.cancel();</span><br><span class="line">                            key.channel().close();</span><br><span class="line">                        &#125;</span><br><span class="line"> </span><br><span class="line">                    &#125;   </span><br><span class="line">                    Thread.sleep(rnd.nextInt(<span class="number">500</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                 </span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                System.out.println(<span class="string">"serverThread is interrupted"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                System.out.println(<span class="string">"serverThread selecotr error"</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    selector.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"selector close failed"</span>);</span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"server close"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException</span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> TCPEchoServer(<span class="number">8080</span>));</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">        <span class="comment">/*结束服务器线程*/</span></span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Proactor模型（异步）"><a href="#Proactor模型（异步）" class="headerlink" title="Proactor模型（异步）"></a>Proactor模型（异步）</h1><p>主要的核心在于回调机制。<br>Reactor在接收事件后需要交给Reactor处理。而Proactor直接由操作系统来处理相关事件，然后返回结果。<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/07/1557218800106-1557218800122.png" alt="title"></p><p><a href="https://juejin.im/post/5b908419e51d450e704230f0#heading-11" target="_blank" rel="noopener">理解高性能网络模型</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;阻塞I-O&quot;&gt;&lt;a href=&quot;#阻塞I-O&quot; class=&quot;headerlink&quot; title=&quot;阻塞I/O&quot;&gt;&lt;/a&gt;阻塞I/O&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/07/1557216950760-1557216950760.png&quot; alt=&quot;title&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每一条连接都需要建立一个独立的线程来处理，机器耗费线程资源。&lt;/li&gt;
&lt;li&gt;当没有数据读写时，线程还会阻塞。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="IO" scheme="http://yoursite.com/categories/IO/"/>
    
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>I/O模型</title>
    <link href="http://yoursite.com/2019/09/29/IO%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/09/29/IO模型/</id>
    <published>2019-09-29T07:12:09.000Z</published>
    <updated>2019-10-11T02:37:01.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Socket与ServerSocket"><a href="#Socket与ServerSocket" class="headerlink" title="Socket与ServerSocket"></a>Socket与ServerSocket</h2><p>网络通信需要一对socket，即通信的两端各有一个socket，两个socket之间形成一个管道，进行数据流的通信。<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/05/1557035867781-1557035868213.png" alt="title"><br>ServerSocket<br>ServerSocket监听服务器端的一个端口，当一个客户端发送来连接时，ServerSocket来处理连接，成功后返回一个常规的Socket对象，用来与客户端socket进行数据传输。</p><h1 id="同步-异步-阻塞-非阻塞"><a href="#同步-异步-阻塞-非阻塞" class="headerlink" title="同步 异步 阻塞 非阻塞"></a>同步 异步 阻塞 非阻塞</h1><p><strong>同步与异步主要是从消息通知机制角度来说的。</strong><br>当一个同步调用发出后，调用者要一直等待返回消息（结果）后，才能进行后续的执行；当一个异步过程调用发出后，调用者不能立刻得到返回消息（结果），实际处理这个调用的部件在完成后，通过<strong>状态、通知和回调</strong>来通知调用者。异步是调用完成后由别人来通知他。</p><a id="more"></a><p>阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的。<br>阻塞调用是指调用结果返回之前，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务。<br>非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。如果在这个等待的过程中，等待者除了等待消息通知之外不能做其它的事情，那么该机制就是阻塞的。</p><p>阻塞与同步是不同的。如果这个线程在等待函数返回时，仍在执行其他消息处理，那么这就是同步非阻塞。如果这个线程在等待函数返回时，没有执行其他消息处理，而是挂起等待，那么就是同步阻塞</p><h1 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h1><p>操作系统将内存空间分为了<strong>内核空间和用户空间</strong>。<br>进程切换非常的耗资源，所以能不挂起进程就不挂起进程。<br>将进程阻塞是让出CPU资源。</p><p>对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：1. 等待数据准备 (Waiting for the data to be ready)2. 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</p><h1 id="Linux-IO的五种模型"><a href="#Linux-IO的五种模型" class="headerlink" title="Linux IO的五种模型"></a>Linux IO的五种模型</h1><h2 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h2><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/05/1557037472070-1557037472074.png" alt="title"></p><p><img src="https://user-gold-cdn.xitu.io/2019/3/25/169b2de92af4b59b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>当应用进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在进程这边，整个应用进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，应用进程才解除block的状态，重新运行起来。在内核执行I/O的两个阶段，都是阻塞的。<strong>每个连接都需要配套一个线程，不适合高并发的情况。</strong></p><p><strong>在阻塞的过程中，这个线程被挂起了，但是他让出了CPU，其他应用进程可以继续占用CPU执行。</strong></p><h2 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h2><p>基于轮询的方式。<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/05/1557037653186-1557037653231.png" alt="title"><br>当所请求的I/O操作不能满足要求时候，不把本进程投入睡眠，而是返回一个错误。也就是说当数据没有到达时并不等待，而是以一个错误返回。并且进程会多次轮询的请求I/O操作。应用程序的线程需要不断的进行 I/O 系统调用，轮询数据是否已经准备好，如果没有准备好，继续轮询，直到完成系统调用为止 。这样，好处是线程不需要一直阻塞，但是需要不断地进行I/O系统调用，<strong>不断轮询，浪费CPU</strong>。不断发起I/O操作及其浪费CPU资源。同步非阻塞就是 “每隔一会儿瞄一眼进度条” 的轮询（polling）方式。<br>需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。</p><h2 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h2><p>基于操作系统的poll，select，epoll。<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/05/1557037849336-1557037849341.png" alt="title"><br>非阻塞IO问题：<br>由于同步非阻塞方式需要不断主动轮询，轮询占据了很大一部分过程，轮询会消耗大量的CPU时间，但是服务器端可能会有多个连接，这样他对每一个连接都这样做，要是连接数量太多时，是不适合的。</p><p>IO多路复用有两个特别的系统调用select、poll、epoll函数。select调用是内核级别的，select轮询相对非阻塞的轮询的区别在于—<strong>前者可以等待多个socket，能实现同时对多个IO端口进行监听</strong>，当其中任何一个socket的数据准好了，就能返回进行可读，然后进程再进行recvform系统调用，将数据由内核拷贝到用户进程，当然这个过程是阻塞的。</p><p>select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function<strong>会不断的轮询所负责的所有socket</strong>，当某个socket有数据到达了，就通知用户进程。</p><p>这几个函数也会使进程阻塞，但是和阻塞I/O所不同的的，<strong>这两个函数可以同时阻塞多个I/O操作</strong>（只需要阻塞一个select函数）。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时（注意不是全部数据可读或可写），才真正调用I/O操作函数。</p><p>上面的图和blocking IO的图其实并没有太大的不同，在两个阶段都需要阻塞。当连接数量很少的时候，I/O多路复用可能比BIO效率还要低，因为I/O多路复用需要多执行一个select内核操作。但是I/O多路复用的优势在于他可以处理更多的连接，而不是处理单个连接速度更快。与传统的多线程/多进程模型比，I/O多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降底了系统的维护工作量，节省了系统资源。</p><h2 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h2><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/05/1557039387817-1557039387825.png" alt="title"><br>在信号驱动式I/O模型中，应用程序使用套接口进行信号驱动I/O，并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。</p><p>基本不怎么用。</p><h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/05/1557039496514-1557039496560.png" alt="title"><br>用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会<strong>直接返回给用户进程</strong>，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核<strong>向进程发送通知（回调函数）</strong>。IO两个阶段，进程都是非阻塞的。</p><p>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>注意：同步非阻塞I/O和I/O多路复用，在返回可读条件后，都需要再调用一次I/O操作，进行复制数据。首先一个IO操作其实分成了两个步骤：发起IO请求和实际的IO操作，同步IO和异步IO的区别就在于第二个步骤是否阻塞，如果实际的IO读写阻塞请求进程，那么就是同步IO，因此阻塞IO、非阻塞IO、IO复用、信号驱动IO都是同步IO，如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，那么就是异步IO。阻塞IO和非阻塞IO的区别在于第一步，发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。</p><h1 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select poll epoll"></a>select poll epoll</h1><p>目前支持I/O多路复用的系统调用有 select，poll，epoll，I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，<strong>一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作</strong>。select，pselect，poll，epoll本质上都是同步I/O。</p><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>用于表述指向文件的引用的抽象化概念。。<br>当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p><h2 id="Linux的socket事件wakeup-callback机制"><a href="#Linux的socket事件wakeup-callback机制" class="headerlink" title="Linux的socket事件wakeup callback机制"></a>Linux的socket事件wakeup callback机制</h2><p>linux wakeup callback机制是IO多路复用的本质。</p><p>Linux通过socket睡眠队列来管理所有等待socket的某个事件的进程（Process），同时通过wakeup机制来异步唤醒整个睡眠队列上等待事件的Process，通知Process相关事件发生。</p><p>每个socket维护了一个队列，比如socket可读的时候，内核就会唤醒队列里的各个Process，并且执行每个Process的callback函数。</p><p>每一个socket都有sleep_list,当某个进程所关心的事件在socket中并没有发生，那么将进程插入到sleep_list，当socket的时间发生了，那么就去遍历他sleep_list中的每个进程的callback函数。</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>我们以read事件为例子。<br>当socket上所监听的事件发生了，那么相应的进程就去处理。那么怎么获取监听的事件发生呢？<br>我们应该block在等待事件的发生上，这个事件简单点就是关心的N个socket中一个或多个socket有数据可读了，当block解除的时候，就意味着，我们一定可以找到一个或多个socket上有可读的数据。</p><p>根据wakeup callback。<br>所以，进程需要同时插入到我们管理的这好多个socket的sleep_list上等待任意一个socket可读事件发生而被唤醒，当Process被唤醒的时候，其callback里面应该有个逻辑去检查具体哪些socket可读了。</p><p>举个例子：<br>假设c1，c2，c3连接到了服务器端，我们想监听他们的读事件，因此我们将进程p1插入到他们与服务器各自的socket中sleep_list中去，此时没有事件发生，因此进程处于睡眠状态，当c1客户端发送来了数据，有数据读取的时候，p1进程被唤醒。<br>伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private int sk_event;</span><br><span class="line"></span><br><span class="line">void poll() &#123;</span><br><span class="line">    //其他逻辑...</span><br><span class="line">    when (receive queue is not empty) &#123;</span><br><span class="line">        sk_event |= POLL_IN；</span><br><span class="line">    &#125;</span><br><span class="line">   //其他逻辑...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当receive queue不为空的时候（即收到了消息），我们就给这个socket的sk_event添加一个POLL_IN事件，用来<strong>表示当前这个socket可读</strong>。将来Process遍历到这个socket，发现其sk_event包含POLL_IN的时候，就可以对这个socket进行读取数据操作了。</p><p>接下来，p1执行select，select会将需要监控的readfds集合拷贝到内核空间（因为内核才能通知说某个socket可读），然后遍历自己监控的socket，挨个调用socket的poll逻辑以便检查该socket是否有可读事件。<br>遍历完所有的socket后，如果没有任何一个sk可读，那么select会调用schedule，使得Process进入睡眠（或者睡眠timeout这么长时间）。如果在timeout时间内某个socket上有数据可读了，或者等待timeout了，则调用select的Process会被唤醒。<br>伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (socket in readfds) &#123;</span><br><span class="line">    sk_event.evt = socket.poll();</span><br><span class="line">    sk_event.sk = socket;</span><br><span class="line">    return_event_for_process;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</span><br></pre></td></tr></table></figure><p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，<strong>直到有描述符就绪</strong>（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），<strong>函数返回</strong>。<strong>当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</strong><br>select缺点：<br>1.文件描述符的数量存在最大限制，在Linux上一般为1024。</p><p>2.对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。<br>每次select()都需要扫描所有的fd_set。而epoll是通过注册回调函数来实现的，所以epoll效率大大高于select.</p><p>3.需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</p><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>解决了文件描述符数量限制的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int poll (struct pollfd *fds, unsigned int nfds, int timeout);</span><br></pre></td></tr></table></figure><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。<br>与select两点区别：<br>1.文件描述符大小不限制。<br>2.不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct pollfd &#123;</span><br><span class="line">    int fd; /* file descriptor */</span><br><span class="line">    short events; /* requested events to watch */</span><br><span class="line">    short revents; /* returned events witnessed */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>pollfd结构包含了要监视的event和发生的event。</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>解决了需要循环遍历文件描述符的缺点，解决了需要将大量的fds从内核拷贝到用户空间的问题。</p><p>将大量的fds从内核拷贝到用户空间的解决：<br>共享内存。<br>epoll通过内核与用户空间mmap同一块内存来解决。mmap将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址（不管是用户空间还是内核空间都是虚拟地址，最终要通过地址映射映射到物理地址），使得这块物理内存对内核和对用户均可见，减少用户态和内核态之间的数据交换。</p><p>需要循环遍历文件描述符的解决：<br>epoll引入了一个中间层，一个双向链表ready_list，一个单独的睡眠队列single_epoll_wait_list。<br><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/07/1557212167413-1557212167863.png" alt="title"><br>1.调用epoll之前，我们希望我们的MyProcess可以管理四个socket。<br>2.四个socket都没有事件，这时候MyProcess进入single_epoll_wait_list并且sleep。<br>3.有一个socket（大红色）收到了数据，触发其wait_entry_sk，把这个socket加入到ready_list里。<br>4.MyProcess被唤醒（从single_epoll_wait_list出来了表示被唤醒），来处理ready_list中的所有socket：遍历epoll的ready_list，挨个调用每个socket的poll逻辑收集发生的事件，对于监控可读事件而已，ready_list上的每个socket都是有数据可读的，这里的遍历必要的。</p><p>epoll有两种工作模式，LT和ET。<br>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p><p><a href="https://blog.csdn.net/j080624/article/details/78468396" target="_blank" rel="noopener">ServerSocket与Socket</a><br><a href="https://www.jianshu.com/p/486b0965c296" target="_blank" rel="noopener">Linux 五种IO模型</a><br><a href="https://www.jianshu.com/p/dfd940e7fca2" target="_blank" rel="noopener">select、poll、epoll详解</a><br><a href="https://segmentfault.com/a/1190000003063859#articleHeader15" target="_blank" rel="noopener">Linux IO模式及 select、poll、epoll详解</a><br><a href="https://wyj.shiwuliang.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SELECT%E3%80%81POLL%E5%92%8CEPOLL%20.html" target="_blank" rel="noopener">深入理解select，poll，epoll</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Socket与ServerSocket&quot;&gt;&lt;a href=&quot;#Socket与ServerSocket&quot; class=&quot;headerlink&quot; title=&quot;Socket与ServerSocket&quot;&gt;&lt;/a&gt;Socket与ServerSocket&lt;/h2&gt;&lt;p&gt;网络通信需要一对socket，即通信的两端各有一个socket，两个socket之间形成一个管道，进行数据流的通信。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/05/05/1557035867781-1557035868213.png&quot; alt=&quot;title&quot;&gt;&lt;br&gt;ServerSocket&lt;br&gt;ServerSocket监听服务器端的一个端口，当一个客户端发送来连接时，ServerSocket来处理连接，成功后返回一个常规的Socket对象，用来与客户端socket进行数据传输。&lt;/p&gt;
&lt;h1 id=&quot;同步-异步-阻塞-非阻塞&quot;&gt;&lt;a href=&quot;#同步-异步-阻塞-非阻塞&quot; class=&quot;headerlink&quot; title=&quot;同步 异步 阻塞 非阻塞&quot;&gt;&lt;/a&gt;同步 异步 阻塞 非阻塞&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;同步与异步主要是从消息通知机制角度来说的。&lt;/strong&gt;&lt;br&gt;当一个同步调用发出后，调用者要一直等待返回消息（结果）后，才能进行后续的执行；当一个异步过程调用发出后，调用者不能立刻得到返回消息（结果），实际处理这个调用的部件在完成后，通过&lt;strong&gt;状态、通知和回调&lt;/strong&gt;来通知调用者。异步是调用完成后由别人来通知他。&lt;/p&gt;
    
    </summary>
    
      <category term="IO" scheme="http://yoursite.com/categories/IO/"/>
    
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Java线程</title>
    <link href="http://yoursite.com/2019/09/29/Java%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/09/29/Java线程/</id>
    <published>2019-09-29T05:53:25.000Z</published>
    <updated>2019-10-11T02:35:45.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发作用"><a href="#并发作用" class="headerlink" title="并发作用"></a>并发作用</h2><p>将多核CPU的计算能力发挥到极致，性能得到提升。</p><p>面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分。</p><a id="more"></a><h2 id="并发缺点"><a href="#并发缺点" class="headerlink" title="并发缺点"></a>并发缺点</h2><ul><li>线程安全问题。</li><li>频繁的上下文切换。</li></ul><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p>Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once。并发指的是多个任务交替进行，而<strong>并行则是指真正意义上的“同时进行</strong>”。实际上，如果系统内只有一个CPU，而使用多线程时，那么真实系统环境下不能并行，只能通过切换时间片的方式交替进行，而成为并发执行任务。真正的并行也只能出现在拥有多个CPU的系统中。</p><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>主要从消息通知角度来看。</p><p>同步是说在调用一个函数后，直到执行完成才返回结果。</p><p>异步是在调用一个函数之后，立即返回，等待函数执行完成之后，通过<strong>状态、通知和回调</strong>来通知调用者。</p><h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><p>主要从等待返回结果时的状态来看。</p><p>阻塞就是在等待返回结果时，当前线程会被挂起，让出CPU，不能执行其他业务。</p><p>非阻塞就是在等待返回结果时，当前线程不会阻塞，可以去执行其他的业务。</p><h3 id="临界区资源"><a href="#临界区资源" class="headerlink" title="临界区资源"></a>临界区资源</h3><p>临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每个线程使用时，一旦临界区资源被一个线程占有，那么其他线程必须等待。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><ul><li>继承Thread</li><li>实现Runnable</li><li>实现Callable</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extends thread</span></span><br><span class="line">     Thread t1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             System.out.println(<span class="string">"t1"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     t1.start();</span><br><span class="line">     <span class="comment">// implements Runnable</span></span><br><span class="line">     Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             System.out.println(<span class="string">"t2"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     t2.start();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// implements Callable,Callable可以有返回值</span></span><br><span class="line">     ExecutorService service=Executors.newSingleThreadExecutor();</span><br><span class="line">     Future&lt;String&gt; future=service.submit(<span class="keyword">new</span> Callable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="string">"thread 3"</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         String result=future.get();</span><br><span class="line">         System.out.println(result);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/07/1570450394461-1570450394478.png" alt="title"></p><ul><li><p>新建(new)，创建线程。</p></li><li><p>Runnable。包括Running和Ready两个阶段，Running就是占用CPU运行，Ready是线程还处于等待阶段。</p></li><li><p>阻塞(Blocked)。等待获取临界区资源，一旦他获得了锁就会结束这个状态。</p></li><li><p>无限期等待(Waiting)。</p><p>等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>没有设置 Timeout 参数的 Object.wait() 方法</td><td>Object.notify() / Object.notifyAll()</td></tr><tr><td>没有设置 Timeout 参数的 Thread.join() 方法</td><td>被调用的线程执行完毕</td></tr><tr><td>LockSupport.park() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table></li><li><p>限期等待(Timed-waiting)。</p><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>Thread.sleep() 方法</td><td>时间结束</td></tr><tr><td>设置了 Timeout 参数的 Object.wait() 方法</td><td>时间结束 / Object.notify() / Object.notifyAll()</td></tr><tr><td>设置了 Timeout 参数的 Thread.join() 方法</td><td>时间结束 / 被调用的线程执行完毕</td></tr><tr><td>LockSupport.parkNanos() 方法</td><td>LockSupport.unpark(Thread)</td></tr><tr><td>LockSupport.parkUntil() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table></li><li><p>终止。线程任务结束，或者是产生了异常而终止。</p></li></ul><h3 id="线程基本操作"><a href="#线程基本操作" class="headerlink" title="线程基本操作"></a>线程基本操作</h3><h4 id="sleep-and-wait"><a href="#sleep-and-wait" class="headerlink" title="sleep() and wait()"></a>sleep() and wait()</h4><p>sleep会休眠当前线程，等到了时间，自动苏醒。</p><p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，<strong>其它线程会调用</strong> <strong>notify() 或者 notifyAll() 来唤醒挂起的线程</strong>。</p><p>两者区别：</p><ul><li><p>sleep到点自己醒，<strong>wait需要其他线程调用notify来唤醒</strong>。</p></li><li><p>wait()方法必须要在<strong>同步方法或者同步块中调用</strong>，也就是必须已经获得对象锁。</p></li><li><p>sleep不释放锁，wait释放锁。</p></li></ul><h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><p>在<strong>线程中调用另一个线程的 join() 方法，会将当前线程挂起</strong>，而不是忙等待，<strong>直到目标线程结束</strong>。</p><p>对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。</p><h4 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h4><p>一旦执行，当前线程会让出cpu，但是，需要注意的是，让出的CPU并不是代表当前线程不再运行了，如果在下一次竞争中，又获得了CPU时间片当前线程依然会继续运行。另外，让出的时间片只会分配<strong>给当前线程相同优先级</strong>的线程。</p><p>sleep()和yield()方法，同样都是当前线程会交出处理器资源，而它们不同的是，sleep()交出来的时间片其他线程都可以去竞争，也就是说都有机会获得当前线程让出的时间片。而yield()方法只允许与当前线程具有相同优先级的线程能够获得释放出来的CPU时间片。</p><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p><p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。</p><p>main() 属于非守护线程。</p><p>使用 setDaemon() 方法将一个线程设置为守护线程</p><h3 id="线程中断问题"><a href="#线程中断问题" class="headerlink" title="线程中断问题"></a>线程中断问题</h3><p>线程可以调用interrupt()来中断别的线程。但这个操作并不一定会使线程中断，更像是给了线程一个通知，但具体是否中断还是要看线程本身。</p><h4 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h4><p>通过调用一个线程的 interrupt() 来中断该线程，<strong>如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程</strong>。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p><h4 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h4><p>如果线程不处在等待或者是阻塞状态，那么直接interrupt是不能中断线程的。但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。</p><p>这样，线程就可以对相应的中断请求进行处理了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Thread t1=<span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">while</span>(!isInterrupted()) &#123;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"end......."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">t1.start();</span><br><span class="line">t1.interrupt();</span><br><span class="line">System.out.println(t1.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;并发作用&quot;&gt;&lt;a href=&quot;#并发作用&quot; class=&quot;headerlink&quot; title=&quot;并发作用&quot;&gt;&lt;/a&gt;并发作用&lt;/h2&gt;&lt;p&gt;将多核CPU的计算能力发挥到极致，性能得到提升。&lt;/p&gt;
&lt;p&gt;面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JVM字节码执行引擎</title>
    <link href="http://yoursite.com/2019/09/25/%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <id>http://yoursite.com/2019/09/25/字节码执行引擎/</id>
    <published>2019-09-25T01:57:50.000Z</published>
    <updated>2019-10-22T07:03:16.416Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法调用就是确定调用哪一个方法。</p><p>在编译阶段，即将java文件转化为class文件，<strong>class文件中存储的是方法的符号引用(类似于一个代号吧)，而不是直接引用</strong>(内存地址)，因为类还没有加载到内存嘛，所以具体的内存地址肯定是不知道的。</p><p>因此，需要到类加载期间，甚至是运行期间才可能确定目标方法的直接引用。</p><a id="more"></a><p>在类加载的阶段，会将一部分符号引用转化为直接引用，前提是</p><blockquote><p>方法在程序运行前就可以确定他是哪一个。</p></blockquote><p>比如说private和static两类方法，这是因为<strong>这两类方法都不可能被继承或者是被重写，只可能有唯一的版本</strong>。别的方法就有可能被重写，存在多个版本，难以确定。</p><p>除了这两类，还有构造方法以及final方法，这几个都是不可能被重写的，可以唯一确定。</p><p>所以，<strong>私有方法，final方法，构造方法，static方法在编译期间既可以完全确定</strong>，<strong>在类加载阶段</strong>直接将符号引用转化为直接引用，其他方法都是在运行期间才能确定。</p><h2 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h2><p>重载和重写在JVM中是如何实现的？</p><h3 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h3><p>重载的实现。</p><p>重载时是<strong>通过参数的静态类型</strong>而不是实际类型决定使用哪个重载函数。</p><p>所以，重载的实现需要参数类型或者个数不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Father是静态类型 ， Son是实际类型。</span></span><br><span class="line">Father father = <span class="keyword">new</span> Son();</span><br></pre></td></tr></table></figure><p>所以，<strong>在编译阶段就可以确定重载的函数是哪一个</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Son();          <span class="comment">//静态分派</span></span><br><span class="line">        print(father);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Father father)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is father"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Son son)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is son"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：this is father</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><h3 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h3><p>重写的实现。</p><p>在运行阶段才可以确定重写的函数是哪一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123; </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123; </span><br><span class="line">System.out.println(<span class="string">"man say hello!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123; </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123; </span><br><span class="line">System.out.println(<span class="string">"woman say hello!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Human man=<span class="keyword">new</span> Man();</span><br><span class="line">Human woman=<span class="keyword">new</span> Woman();</span><br><span class="line">man.sayHello();</span><br><span class="line">woman.sayHello();</span><br><span class="line">man=<span class="keyword">new</span> Woman();</span><br><span class="line">man.sayHello(); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从invokevirtual指令的多态查找过程开始说起，invokevirtual指令的运行时解析过程大致分为以下几个步骤：</p><p>1、找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。<br>2、如果在类型C中找到与常量中的描述符和简单名称相符合的方法，然后进行访问权限验证，如果验证通过则返回这个方法的直接引用，查找过程结束；如果验证不通过，则抛出java.lang.IllegalAccessError异常。<br>3、否则未找到，就按照继承关系从下往上依次对类型C的各个父类进行第2步的搜索和验证过程。<br>4、如果始终没有找到合适的方法，则跑出java.lang.AbstractMethodError异常。</p><p><strong>由于invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上</strong>，这个过程就是Java语言方法重写的本质。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;方法调用&quot;&gt;&lt;a href=&quot;#方法调用&quot; class=&quot;headerlink&quot; title=&quot;方法调用&quot;&gt;&lt;/a&gt;方法调用&lt;/h2&gt;&lt;p&gt;方法调用就是确定调用哪一个方法。&lt;/p&gt;
&lt;p&gt;在编译阶段，即将java文件转化为class文件，&lt;strong&gt;class文件中存储的是方法的符号引用(类似于一个代号吧)，而不是直接引用&lt;/strong&gt;(内存地址)，因为类还没有加载到内存嘛，所以具体的内存地址肯定是不知道的。&lt;/p&gt;
&lt;p&gt;因此，需要到类加载期间，甚至是运行期间才可能确定目标方法的直接引用。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾收集机制</title>
    <link href="http://yoursite.com/2019/09/21/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/09/21/JVM垃圾收集机制/</id>
    <published>2019-09-21T07:19:28.000Z</published>
    <updated>2019-10-22T08:29:47.569Z</updated>
    
    <content type="html"><![CDATA[<p>GC需要完成三件事：</p><ul><li>哪些对象需要回收？</li><li>何时进行回收？</li><li>怎么样回收？</li></ul><a id="more"></a><h2 id="哪些对象需要回收"><a href="#哪些对象需要回收" class="headerlink" title="哪些对象需要回收"></a>哪些对象需要回收</h2><p>死掉的对象需要回收。</p><h3 id="如何判断对象已死？"><a href="#如何判断对象已死？" class="headerlink" title="如何判断对象已死？"></a>如何判断对象已死？</h3><p><strong>可达性分析算法+finalize().</strong></p><h4 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h4><p>把一系列称为”GC Roots”的对象作为起点，向下进行搜索，<strong>当GC Roots到某个对象不可达时</strong>，这个对象就是可回收的。</p><p>GC Roots对象包括：</p><ul><li><strong>虚拟机栈中引用的对象。</strong></li><li><strong>方法区中类静态属性引用的对象。</strong></li><li><strong>方法区中常量引用的对象。</strong></li><li><strong>本地方法栈中引用的对象</strong>。</li></ul><p>为什么不使用引用计数法呢？</p><p>引用计数法就是每当加了一个引用，引用计数器加一，一个引用失效，引用计数器减一，引用计数器为零时该对象死亡。</p><p>但是引用计数无法解决的是<strong>循环引用</strong>的问题。</p><p>循环引用：</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/11/1570790645663-1570790645677.png" alt="title"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">MyObject object1 = <span class="keyword">new</span> MyObject();</span><br><span class="line">        MyObject object2 = <span class="keyword">new</span> MyObject();</span><br><span class="line">          </span><br><span class="line">        object1.object = object2;</span><br><span class="line">        object2.object = object1;</span><br><span class="line">          </span><br><span class="line">        object1 = <span class="keyword">null</span>;</span><br><span class="line">        object2 = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h4><p>即使某个对象是不可达的，也并不一定非死不可。宣告一个对象死亡，要经过两次标记过程：<strong>第一个是GC Roots不可达，第二步是此对象是否有必要执行finalize()方法</strong>。</p><p><strong>如果该对象重写了finalize()方法且finalize()方法还没有被虚拟机所调用，</strong>则其对象需要执行该方法。</p><p>那么，该对象会放入一个队列之中，并由一个Finalizer线程去执行finalize()方法。<strong>finalize方法是对象拯救自己的最后一次方法，只需要与任何一个GC Roots建立关联即可</strong>。这样他就还是存活的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscape</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscape SAVE=<span class="keyword">null</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">super</span>.finalize();</span><br><span class="line">System.out.println(<span class="string">"finalize excute...."</span>);</span><br><span class="line">FinalizeEscape.SAVE=<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" i am still alive ....."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">SAVE=<span class="keyword">new</span> FinalizeEscape();</span><br><span class="line">SAVE=<span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br><span class="line">Thread.sleep(<span class="number">500</span>);</span><br><span class="line"><span class="keyword">if</span>(SAVE==<span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">" i am dead ....."</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">SAVE.isAlive();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SAVE=<span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br><span class="line">Thread.sleep(<span class="number">500</span>);</span><br><span class="line"><span class="keyword">if</span>(SAVE==<span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">" i am dead ....."</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">SAVE.isAlive();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出：</span></span><br><span class="line"><span class="comment">    finalize excute....</span></span><br><span class="line"><span class="comment">    i am still alive .....</span></span><br><span class="line"><span class="comment">    i am dead .....</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure><p>由此可见，SAVE对象的finalize()方法确实执行了，并在收集前成功逃脱了。</p><p>代码中有两段完全一样的方法，第一次成功逃脱，第二次因为已经执行过了finalize()方法，所以也就不在执行了，因此第二段代码逃脱失败。</p><p>然而，并不鼓励使用finalize()方法。</p><h2 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h2><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/11/1570790798889-1570790798894.png" alt="title"></p><ul><li><p>强引用：</p><p>强引用是使用最普遍的引用。Object obj =new Object(); <strong>如果一个对象具有强引用，那垃圾回收器绝不会回收它</strong>。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。</p></li><li><p>软引用：</p><p>如果一个对象只具有软引用，则<strong>内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。使用SoftReferrnce类实现软引用。</strong></p></li><li><p>弱引用：</p><p>被弱引用引用的对象只能生存到下一次垃圾回收之前。当GC开始工作时，无论内存是否充足，都会回收弱引用引用的对象。使用WeakReference来实现弱引用类。</p></li><li><p>虚引用：</p><p>顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。</p></li></ul><h2 id="方法区GC"><a href="#方法区GC" class="headerlink" title="方法区GC"></a>方法区GC</h2><p>方法区主要回收废弃常量以及无用的类。</p><p>废弃常量，没有地方引用他。</p><p>废弃类需要满足以下条件：</p><ul><li>该类所有实例已经被回收。</li><li>加载该类classLoader已经被回收。</li><li>该类的class对象没有在任何地方被引用。</li></ul><p>对于jdk8之后方法区变为了元空间，如果Metaspace的空间占用达到了设定的最大值，也会触发GC来收集死亡对象和类的加载器。</p><p><a href="https://www.sczyh30.com/posts/Java/jvm-metaspace/" target="_blank" rel="noopener">MetaSpace GC</a></p><h2 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h2><h3 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h3><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/11/1570790833699-1570790833708.png" alt="title"></p><p>标记出所有需要回收的对象，然后将做了标记的都给清除。缺点是导致内存碎片化。</p><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/11/1570790877299-1570790877304.png" alt="title"></p><p>将内存一般分为A区域，一半分为B区域。图中我们将前两行分为A，后两行分为B。刚开始的时候，我们只使用A区域的内存，而不使用B区域的内存。</p><p>第一次GC，经过一次可达性分析后，我们将A中存活对象直接复制到B区域，然后直接将整块A区域清除。A区域变成未使用的。第二次GC，同理，将B的存活对象复制到A，将B清除，B变为空。</p><p>这样A和B区域交互使用。</p><p>这个算法可以解决内存碎片化的问题，但是会导致内存浪费，一次只能使用一半的内存。</p><p>新生代主要使用的是复制算法。一般来说，Eden：Survior1：Survior2=8：1：1，因为每次GC新生代垃圾都会有75%-90%，这样，直接将Eden幸存的对象复制到Survior1区域中，然后将Eden区域清除，第二次清除时，将Eden区域和S1区域幸村对象复制到S2区域，将Eden和S1区域清除，就这样，S1，S2两个区域交替使用，新生代内存利用空间可以达到90%，而且解决了内存碎片化的问题。注意，当Survior内存区域不够时（多于10%对象存活），可以向老年代进行分配担保。</p><p><strong>适用于存活率比较低的对象，要是存活率过高的话，会造成大量复制，效率变低</strong>。</p><h3 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h3><p>复制算法在对象存活率较高时就会产生一个问题，因为要进行过多的复制操作，效率会降低，而且浪费空间会比较多。对于老年代，存活对象率比较高，而且对象比较大，占用内存大，所以不宜使用复制算法，采用标记整理算法。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/11/1570790910233-1570790910238.png" alt="title"></p><p>将存活的对象移到回收对象留下的空间里，以形成连续的内存。</p><p>适用于存活率较高的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>新生代中，每次GC都有大量对象死去，少量存活，选用复制算法。</p><p>老年代中，对象存活率高，没有额外空间进行内存担保，使用标记-整理。</p><h2 id="HotSpot算法实现"><a href="#HotSpot算法实现" class="headerlink" title="HotSpot算法实现"></a>HotSpot算法实现</h2><p>两个问题</p><ul><li><p>寻找GC Roots效率问题，如果逐个检查引用，太慢。</p><p>使用OopMap来解决，这个数据结构存储了引用以及他的作用范围(从哪个指令开始到哪个指令结束)。</p><p>在类加载完成的时候，就生成了一个OopMap。</p></li><li><p>一致性问题。寻找GC Roots这个阶段需要保证引用情况不再发生变化，因此需要发生GC停顿。</p></li></ul><h3 id="OopMap与Rememebered-Set"><a href="#OopMap与Rememebered-Set" class="headerlink" title="OopMap与Rememebered Set"></a>OopMap与Rememebered Set</h3><h4 id="OopMap"><a href="#OopMap" class="headerlink" title="OopMap"></a>OopMap</h4><p><strong>编译时就有了。</strong></p><p>用于枚举GC Roots。</p><p>当垃圾回收时，收集线程会对栈上的内存进行扫描，看看那些位置上存储了Reference类型。如果发现了某个位置上存储的是Reference类型，就意味着这个引用所指向的对象在这一次垃圾回收过程中不能够回收。</p><p>但是要是逐个检查引用，这一样效率太低了。</p><p>于是采用空间换时间的方法，把栈中是引用类型的变量的位置记录下来，这样他指向的对象肯定是GC Roots。这样，再做GC的时候，就可以直接读取，不用全部扫描了。</p><p>一个线程意味着一个栈，一个栈由多个栈帧组成，一个栈帧对应着一个方法，一个方法里面可能有多个安全点。 gc 发生时，程序首先运行到最近的一个安全点停下来，然后更新自己的 OopMap ，记下栈上哪些位置代表着引用。枚举根节点时，递归遍历每个栈帧的 OopMap ，通过栈中记录的被引用对象的内存地址，即可找到这些对象（ GC Roots ）。</p><p>因为一个方法有多个安全点，每个安全点就有一个OopMap，所以，一个方法里有多个OopMap。</p><p><strong>可以把oopMap简单理解成是调试信息。在源代码里面每个变量都是有类型的，但是编译之后的代码就只有变量在栈上的位置了。oopMap就是一个附加的信息，告诉你栈上哪个位置本来是个什么东西。 这个信息是在JIT编译时跟机器码一起产生的。因为只有编译器知道源代码跟产生的代码的对应关系。 每个方法可能会有好几个oopMap，就是根据safepoint把一个方法的代码分成几段，每一段代码一个oopMap，作用域自然也仅限于这一段代码。 循环中引用多个对象，肯定会有多个变量，编译后占据栈上的多个位置。那这段代码的oopMap就会包含多条记录。</strong></p><h4 id="Rememebered-Set"><a href="#Rememebered-Set" class="headerlink" title="Rememebered Set"></a>Rememebered Set</h4><p>RememberedSet 用于处理这类问题：比如说，新生代 gc （它发生得非常频繁）。一般来说， gc 过程是这样的：首先枚举根节点。根节点有可能在新生代中，也有可能在老年代中。这里由于我们只想收集新生代（换句话说，不想收集老年代），所以没有必要对位于老年代的 GC Roots 做全面的可达性分析。但问题是，确实可能存在位于老年代的某个 GC Root，它引用了新生代的某个对象，这个对象你是不能清除的。那怎么办呢？</p><p>维护一个表，记录别的代对新生代的引用关系，这个表叫Remembered Set。</p><p>在G1收集器中，堆被分成一个个region，难免会存在别的region中的对象会引用某个region的对象，那么，就对每一个region维护一个Remembered Set，记录其他所有region对象对他其中对象的引用。</p><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>在OopMap的帮助下，可以很容易的寻找GC Roots，但是，每一个指令都可能导致OopMap的变化，<strong>如果为每一条指令都生成一个对应的OopMap，那么，将会需要大量的空间。于是，HotSpot只是在特定的点记录了这些信息，这些点叫做安全点</strong>，程序旨在安全点才停下来执行GC。</p><p>如何让让所有的线程跑到安全点中断呢？</p><p>抢先式中断和主动式中断。</p><p>抢先式中断是把所有的线程都中断，然后把不在安全点上的线程恢复，直到他到达安全点上。</p><p>主动式中断：设置一个中断标志，各个线程主动区轮询这个标志，发现中断标志为真时，自己主动挂起。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><strong>所有的收集器都避免不了stop the word，只可能尽可能的缩短。</strong></p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/11/1570791153063-1570791153069.png" alt="title"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p><ul><li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li><li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li></ul><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><ul><li><p>适用于新生代和老年代。</p></li><li><p>单线程收集器，在他进行垃圾收集时，必须暂停所有其他工作的线程。</p></li><li><p>新生代采用复制算法，老年代采用标记-整理算法。</p></li></ul><h3 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h3><ul><li><p>Serial的多线程版本。除了Serial，只有ParNew可以与CMS一起使用。</p></li><li><p>适用于新生代和老年代。</p></li><li><p>新生代采用复制算法，老年代采用标记-整理算法。</p></li></ul><h3 id="Parallel-Scavenge-Parallel-old"><a href="#Parallel-Scavenge-Parallel-old" class="headerlink" title="Parallel Scavenge+Parallel old"></a>Parallel Scavenge+Parallel old</h3><p>Parallel Scavenge一个新生代收集器，特点是吞吐量优先。经常与Parallel Old一起使用 。</p><p>在<strong>注重吞吐量的情况下，使用Parallel Scavenge+Parallel old（科学计算，天文计算等）</strong>。</p><p>Parallel Scavenge新生代采用复制算法，Parallel old老年代采用标记-整理。</p><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p><strong>基于标记-清除算法。并不是标记整理。</strong></p><p>注重于获取最短停顿时间。并发收集，分区处理。停顿时间短，在垃圾收集的时候，JVM还可以运行。</p><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/11/1570791482414-1570791482420.png" alt="title"></p><p>分为以下四个流程：</p><ul><li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li><li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li><li>并发清除：不需要停顿。</li></ul><p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p><p>CMS具有以下缺点：</p><ul><li>在并发标记以及并发清除阶段，GC会占用一部分的CPU资源，会造成吞吐量下降CMS 默认启动的回收线程数=(CPU 数目+3)4 当 CPU 数&gt;4 时, GC线程一般占用不超过 25%的 CPU 资源, 但是当 CPU 数&lt;=4 时, GC线程 可能就会过多的占用用户 CPU 资源, 从而导致应用程序变慢, 总吞吐量降低.。</li><li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是<strong>指并发清除阶段</strong>由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li><li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li></ul><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>用来替代CMS的。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>采用的是标记-整理算法+复制算法，避免产生内存空间碎片。标记整理出需要回收的region，region间使用复制算法。因此，从整体上看，G1是基于标记-整理的，从局部上来看(两个region之间)，是复制算法。</li><li>一般的垃圾收集器将内存分为Eden，Survior以及Old三类，且各个代都是连续的。而G1将整个Java堆分成一个个相等的独立区域，虽然还有分代的概念，但各个代不再是连续的，<strong>新生代和老年代不再物理隔离</strong>。内存的粒度变得更小了。</li><li>可预测的停顿。G1每次回收不是收集整代内存，而是根据优先列表收集几块内存(region)，到底要回收多少需要看用户的垃圾收集时间配置，配置的时间长，收集的就多。</li><li>如果应用的内存非常吃紧，对内存进行部分回收根本不够，始终要进行整个Heap的回收，那么G1要做的工作量就一点也不会比其它垃圾回收器少，而且因为本身算法复杂了一点，可能比其它回收器还要差。因此G1比较适合内存稍大一点的应用(一般来说至少4G以上)。</li></ul><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/10/11/1570791517720-1570791517725.png" alt="title"></p><p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>服务端多核CPU、<strong>JVM内存占用较大</strong>的应用。</li><li>运行过程中会产生大量内存碎片。</li><li>想要可控的，可预期的GC停顿时间。</li></ul><h3 id="收集过程"><a href="#收集过程" class="headerlink" title="收集过程"></a>收集过程</h3><ul><li>初始标记，标记GC Roots直接关联对象，需要暂停，时间短</li><li>并发标记，对GC Roots进行可达性分析，并发执行，时间比较长。</li><li>最终标记，修正并发标记阶段而产生的变动，这一段是暂停的。</li><li>筛选回收，将各个region根据回收价值和回收成本进行排序，然后进行收集。这个阶段需要暂停用户线程。 </li></ul><h2 id="Minor-GC-and-Full-GC"><a href="#Minor-GC-and-Full-GC" class="headerlink" title="Minor GC and Full GC"></a>Minor GC and Full GC</h2><h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p>回收新生代，因为新生代对象存活时间很短，因此Minor GC会频繁进行，执行速度也比较快。<br>当Eden区域满了的话，会触发Minor GC。</p><h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p>回收新生代和老年代，老年代因为存活时间比较长，因此Full GC很少执行，速度也比较慢。</p><p>触发Full GC：</p><ul><li><p>老年代空间不足。</p></li><li><p>空间分配担保失败。</p><p>新生代采用复制收集算法，需要将存活的对象复制到survivor中，然后直接清理Eden区，但是会有一种情况，就是存活的对象大于survivor内存空间，这样，就需要老年代分配担保，将survivor中无法分配的对象放入老年代。但是，万一老年代也不够用呢？</p><p>加入老年代剩余最大连续可用空间大于Eden区，那么肯定可以直接放。</p><p>否则的话，看老年代是否允许担保失败，可以的话，检查老年代剩余最大连续可用空间是否大于历次晋升到老年代对象的平均大小，如果大于，尝试进行Minor GC，小于的话，直接Full GC。</p></li><li><p>CMS垃圾收集器浮动垃圾的问题。因为在CMS并发清理阶段用户线程也在运行，所以需要留出一定的空间做缓冲。这样，老年代没有满的时候就需要触发Full GC,默认是92%。但要是预留的空间无法满足程序需要，就会报 Concurrent Mode Failure 错误，并触发 Full GC。</p></li></ul><h2 id="对象分配策略"><a href="#对象分配策略" class="headerlink" title="对象分配策略"></a>对象分配策略</h2><ul><li><p>对象优先在Eden区分配。当Eden区没有足够的空间进行分配时，会触发Minor GC。如果启动了TLAB，那么优先在TLAB上分配，G1默认就是启动TLAB的。</p></li><li><p>大对象直接进入老年代。</p></li><li><p>长期存活对象将进入老年代，对象每熬过一次Minor GC，年龄增加一岁，当年龄达到阈值(默认是15),那么这个对象晋升到老年代。</p></li><li><p>动态对象年龄判定。虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/youyou1543724847/article/details/52728154" target="_blank" rel="noopener">OopMap详解</a></p><p><a href="https://www.iteye.com/blog/dsxwjhf-2201685" target="_blank" rel="noopener">OopMap与Remembered Set</a></p><p><a href="https://www.cnblogs.com/aspirant/p/8663872.html" target="_blank" rel="noopener">G1垃圾收集器</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GC需要完成三件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哪些对象需要回收？&lt;/li&gt;
&lt;li&gt;何时进行回收？&lt;/li&gt;
&lt;li&gt;怎么样回收？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM类加载机制</title>
    <link href="http://yoursite.com/2019/09/20/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/09/20/JVM类加载机制/</id>
    <published>2019-09-20T13:37:24.000Z</published>
    <updated>2019-09-30T06:06:41.242Z</updated>
    
    <content type="html"><![CDATA[<p>Java程序运行时，有两个阶段，编译和运行。编译阶段将Java文件编译成class字节码文件，然后在运行阶段将class文件加载到内存，并对class文件解释执行。</p><a id="more"></a><h2 id="Java跨平台原因"><a href="#Java跨平台原因" class="headerlink" title="Java跨平台原因"></a>Java跨平台原因</h2><p><strong>Java语言跨平台的主要原因就是JVM以及字节码文件。</strong></p><p>C语言是将高级语言直接解释成机器码，通过CPU指令集执行机器码，但是，不同架构的CPU，他的指令集可能是不一样的，这样就造成C语言难以跨平台。可是Java就不一样了，Java在机器和程序之间加了一次抽象的虚拟机。直接将Java程序编译成字节码，由Java虚拟机来解释字节码文件，对于不同的平台，解释器是不同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwNTI5MTQxNTU4NDg3?x-oss-process=image/format,png" alt="这里写图片描述"></p><h2 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h2><p><img src="http://file.elecfans.com/web1/M00/4F/B0/pIYBAFrhQ-WAN_-bAAA9GHdpZic508.jpg" alt></p><p>将Java文件转换成字节码文件。字节码文件存储了所有信息。</p><p>class文件中有一个class常量池，里面存放了字符串。</p><p>所以，类似于String s = “a”+”b”;在<strong>编译阶段会</strong>直接被优化为”ab”。</p><p><img src="https://img-blog.csdn.net/20170329213804490?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU3VnYXJfUmFpbmJvdw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><h2 id="类加载阶段"><a href="#类加载阶段" class="headerlink" title="类加载阶段"></a>类加载阶段</h2><p>类加载就是将class文件加载到内存，并对数据进行校验，转换解析和初始化，最终转化成可被虚拟机使用的Java类型。<strong>类加载阶段是在运行期间完成的。</strong></p><p>类加载阶段主要包括五个阶段：加载，验证，准备，解析，初始化。。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvODc5ODk2LzIwMTYwNC84Nzk4OTYtMjAxNjA0MTQyMjQ1NDk3NzAtNjAwMDY2NTUucG5n?x-oss-process=image/format,png" alt="img"></p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ul><li>通过一个类的全限定名获取字节码文件。</li><li>将字节码文件静态存储结构转化为运行时内存区域。</li><li>生成这个类的java.lang.class对象。存在于方法区（元空间）。</li></ul><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>确保字节码文件信息是否合法。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为类变量(static 修饰<strong>)分配内存并设置初始值</strong>的阶段。</p><p>注意，这个阶段只是类变量设置初始值，而不包括实例变量。</p><p>设置初始值通常情况下指的是数据类型的零值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">23</span>;</span><br></pre></td></tr></table></figure><p>这里只会将a设置为0，将a设置为23需要等到初始化阶段。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>将class常量池内的符号引用替换为直接引用的过程。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>执行clinit()方法的过程，初始化类变量以及执行静态语句块。</p><p>clinit是类初始化的方法，init是对象初始化的方法，static静态语句块在clinit阶段执行，所以静态语句块肯定是先于构造函数执行的。</p><h3 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h3><p><strong>这几个阶段类必须要初始化</strong>，<strong>而不是类加载</strong>。</p><ul><li>遇到new实例化对象，读取或者设置static字段。</li><li>反射调用。</li><li>初始化一个类，若父类还没有初始化，需要先初始化父类。</li><li>初始化主类(执行main方法的)。</li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>对于任何一个类，都需要由加载他的类加载器以及这个类本身来确立他在JVM中的唯一性。比较两个类是否相等，首先应该是建立在同一个类加载器上的。两个类即使来自于同一个class文件，由不同的类加载器加载，这两个加载的类也是不相等的。</p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p><img src="https://raw.githubusercontent.com/gallonskj/gitnote-images/master/gitnote/2019/09/30/1569822785993-1569822786000.png" alt="title"></p><p>   双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务(搜索范围内没有这个类)，子加载器才会尝试自己去加载，这就是双亲委派模式。</p><p>避免了类加载的混乱。比如说，在classpath下定义了一个java.lang.Object，要是没有双亲委派模型，那么应用程序类加载器会加载这个类，那么就会与启动类加载器加载的Object类冲突。但是要是有类加载机制，那么将会交给启动类加载器，这样加载的还是java自带的Object类，就不会产生冲突。</p><h3 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h3><p>如何破坏双亲委派模型？</p><p>继承ClassLoader，自己重写loadClass方法，然后加入自己逻辑，特定某些class可以按照你的方式处理。。</p><p>重写loadClass：</p><ul><li><p>findLoadedClass</p></li><li><p>委托parent加载器加载（这里注意bootstrap加载器的parent为null)</p></li><li><p>自行加载</p></li></ul><p>打破委派机制要做的就是打乱2和3的顺序，通过类名筛选自己要加载的类，其他的委托给parent加载器</p><h4 id="JDBC破坏"><a href="#JDBC破坏" class="headerlink" title="JDBC破坏"></a>JDBC破坏</h4><p>因为类加载器受到加载范围的限制，在某些情况下父类加载器无法加载到需要的文件，这时候就需要委托子类加载器去加载class文件。</p><p>JDBC的Driver接口定义在JDK中，其实现由各个数据库的服务商来提供，比如MySQL驱动包。DriverManager 类中要加载各个实现了Driver接口的类，然后进行管理，但是DriverManager位于 $JAVA_HOME中jre/lib/rt.jar 包，由BootStrap类加载器加载，而其Driver接口的实现类是位于服务商提供的 Jar 包，<strong>根据类加载机制，当被装载的类引用了另外一个类的时候，虚拟机就会使用装载第一个类的类装载器装载被引用的类。</strong>也就是说BootStrap类加载器还要去加载jar包中的Driver接口的实现类。我们知道，BootStrap类加载器默认只负责加载 $JAVA_HOME中jre/lib/rt.jar 里所有的class，所以需要由子类加载器去加载Driver实现，这就破坏了双亲委派模型。<br>通过线程上下文类加载器，默认是应用程序类加载器，可以通过Thread的方法进行设置。</p><h3 id="Tomcat破坏"><a href="#Tomcat破坏" class="headerlink" title="Tomcat破坏"></a>Tomcat破坏</h3><p><a href="https://www.jianshu.com/p/abf6fd4531e7" target="_blank" rel="noopener">tomcat破坏双亲委派模型</a></p><h4 id="OSGI"><a href="#OSGI" class="headerlink" title="OSGI"></a>OSGI</h4><p>类加载器不再是双亲委派模型的树状结构，而是网状结构。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java程序运行时，有两个阶段，编译和运行。编译阶段将Java文件编译成class字节码文件，然后在运行阶段将class文件加载到内存，并对class文件解释执行。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
</feed>
