<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[I/O]]></title>
    <url>%2F2019%2F09%2F29%2FIO%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"></content>
      <tags>
        <tag>IO</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程]]></title>
    <url>%2F2019%2F09%2F29%2FJava%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[字节码执行引擎]]></title>
    <url>%2F2019%2F09%2F25%2F%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[分派重载和重写在JVM中是如何实现的？ 静态分派重载的实现。 重载时是通过参数的静态类型而不是实际类型决定使用哪个重载函数。 12//Father是静态类型 ， Son是实际类型。Father father = new Son(); 发生在编译阶段。 12345678910111213141516 void test() &#123; Father father = new Son(); //静态分派 print(father); &#125; void print(Father father) &#123; System.out.println("this is father"); &#125; void print(Son son) &#123; System.out.println("this is son"); &#125;/*输出：this is father**/ 动态分派重写的实现。 发生在运行阶段。 1234567891011121314151617181920212223242526public class DynamicDispatch &#123; static abstract class Human&#123; protected abstract void sayHello(); &#125; static class Man extends Human&#123; @Override protected void sayHello() &#123; System.out.println("man say hello!"); &#125; &#125; static class Woman extends Human&#123; @Override protected void sayHello() &#123; System.out.println("woman say hello!"); &#125; &#125; public static void main(String[] args) &#123; Human man=new Man(); Human woman=new Woman(); man.sayHello(); woman.sayHello(); man=new Woman(); man.sayHello(); &#125;&#125; 我们从invokevirtual指令的多态查找过程开始说起，invokevirtual指令的运行时解析过程大致分为以下几个步骤： 1、找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。2、如果在类型C中找到与常量中的描述符和简单名称相符合的方法，然后进行访问权限验证，如果验证通过则返回这个方法的直接引用，查找过程结束；如果验证不通过，则抛出java.lang.IllegalAccessError异常。3、否则未找到，就按照继承关系从下往上依次对类型C的各个父类进行第2步的搜索和验证过程。4、如果始终没有找到合适的方法，则跑出java.lang.AbstractMethodError异常。 由于invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是Java语言方法重写的本质。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM垃圾收集机制]]></title>
    <url>%2F2019%2F09%2F21%2FJVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[GC需要完成三件事： 哪些对象需要回收？ 何时进行回收？ 怎么样回收？ 哪些对象需要回收死掉的对象需要回收。 如何判断对象已死？可达性分析算法+finalize(). 可达性分析把一系列称为”GC Roots”的对象作为起点，向下进行搜索，当GC Roots到某个对象不可达时，这个对象就是可回收的。 GC Roots对象包括： 虚拟机栈中引用的对象。 方法区中类静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中引用的对象。 为什么不使用引用计数法呢？ 引用计数法就是每当加了一个引用，引用计数器加一，一个引用失效，引用计数器减一，引用计数器为零时该对象死亡。 但是引用计数无法解决的是循环引用的问题。 循环引用： 1234567891011121314public class Test &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub MyObject object1 = new MyObject(); MyObject object2 = new MyObject(); object1.object = object2; object2.object = object1; object1 = null; object2 = null; System.gc(); &#125; finalize()即使某个对象是不可达的，也并不一定非死不可。宣告一个对象死亡，要经过两次标记过程：第一个是GC Roots不可达，第二步是此对象是否有必要执行finalize()方法。 如果该对象重写了finalize()方法且finalize()方法还没有被虚拟机所调用，则其对象需要执行该方法。 那么，该对象会放入一个队列之中，并由一个Finalizer线程去执行finalize()方法。finalize方法是对象拯救自己的最后一次方法，只需要与任何一个GC Roots建立关联即可。这样他就还是存活的。 12345678910111213141516171819202122232425262728293031323334353637383940public class FinalizeEscape &#123; public static FinalizeEscape SAVE=null; @Override protected void finalize() throws Throwable &#123; // TODO Auto-generated method stub super.finalize(); System.out.println("finalize excute...."); FinalizeEscape.SAVE=this; &#125; public void isAlive() &#123; System.out.println(" i am still alive ....."); &#125; public static void main(String[] args) throws Exception&#123; // TODO Auto-generated method stub SAVE=new FinalizeEscape(); SAVE=null; System.gc(); Thread.sleep(500); if(SAVE==null) &#123; System.out.println(" i am dead ....."); &#125;else &#123; SAVE.isAlive(); &#125; SAVE=null; System.gc(); Thread.sleep(500); if(SAVE==null) &#123; System.out.println(" i am dead ....."); &#125;else &#123; SAVE.isAlive(); &#125; &#125; /* 输出： finalize excute.... i am still alive ..... i am dead ..... */ 由此可见，SAVE对象的finalize()方法确实执行了，并在收集前成功逃脱了。 代码中有两段完全一样的方法，第一次成功逃脱，第二次因为已经执行过了finalize()方法，所以也就不在执行了，因此第二段代码逃脱失败。 然而，并不鼓励使用finalize()方法。 四种引用类型 强引用： 强引用是使用最普遍的引用。Object obj =new Object(); 如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。 软引用： 如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。使用SoftReferrnce类实现软引用。 弱引用： 被弱引用引用的对象只能生存到下一次垃圾回收之前。当GC开始工作时，无论内存是否充足，都会回收弱引用引用的对象。使用WeakReference来实现弱引用类。 虚引用： 顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。 方法区GC方法区主要回收废弃常量以及无用的类。 废弃常量，没有地方引用他。 废弃类需要满足以下条件： 该类所有实例已经被回收。 加载该类classLoader已经被回收。 该类的class对象没有在任何地方被引用。 对于jdk8之后方法区变为了元空间，如果Metaspace的空间占用达到了设定的最大值，也会触发GC来收集死亡对象和类的加载器。 MetaSpace GC GC算法标记-清除 标记出所有需要回收的对象，然后将做了标记的都给清除。缺点是导致内存碎片化。 复制 将内存一般分为A区域，一半分为B区域。图中我们将前两行分为A，后两行分为B。刚开始的时候，我们只使用A区域的内存，而不使用B区域的内存。 第一次GC，经过一次可达性分析后，我们将A中存活对象直接复制到B区域，然后直接将整块A区域清除。A区域变成未使用的。第二次GC，同理，将B的存活对象复制到A，将B清除，B变为空。 这样A和B区域交互使用。 这个算法可以解决内存碎片化的问题，但是会导致内存浪费，一次只能使用一半的内存。 新生代主要使用的是复制算法。一般来说，Eden：Survior1：Survior2=8：1：1，因为每次GC新生代垃圾都会有75%-90%，这样，直接将Eden幸存的对象复制到Survior1区域中，然后将Eden区域清除，第二次清除时，将Eden区域和S1区域幸村对象复制到S2区域，将Eden和S1区域清除，就这样，S1，S2两个区域交替使用，新生代内存利用空间可以达到90%，而且解决了内存碎片化的问题。注意，当Survior内存区域不够时（多于10%对象存活），可以向老年代进行分配担保。 适用于存活率比较低的对象，要是存活率过高的话，会造成大量复制，效率变低。 标记-整理复制算法在对象存活率较高时就会产生一个问题，因为要进行过多的复制操作，效率会降低，而且浪费空间会比较多。对于老年代，存活对象率比较高，而且对象比较大，占用内存大，所以不宜使用复制算法，采用标记整理算法。 将存活的对象移到回收对象留下的空间里，以形成连续的内存。 适用于存活率较高的。 总结新生代中，每次GC都有大量对象死去，少量存活，选用复制算法。 老年代中，对象存活率高，没有额外空间进行内存担保，使用标记-整理。 HotSpot算法实现两个问题 寻找GC Roots效率问题，如果逐个检查引用，太慢。 使用OopMap来解决，这个数据结构存储了引用以及他的作用范围(从哪个指令开始到哪个指令结束)。 在类加载完成的时候，就生成了一个OopMap。 一致性问题。寻找GC Roots这个阶段需要保证引用情况不再发生变化，因此需要发生GC停顿。 OopMap与Rememebered SetOopMap编译时就有了。 用于枚举GC Roots。 当垃圾回收时，收集线程会对栈上的内存进行扫描，看看那些位置上存储了Reference类型。如果发现了某个位置上存储的是Reference类型，就意味着这个引用所指向的对象在这一次垃圾回收过程中不能够回收。 但是要是逐个检查引用，这一样效率太低了。 于是采用空间换时间的方法，把栈中是引用类型的变量的位置记录下来，这样他指向的对象肯定是GC Roots。这样，再做GC的时候，就可以直接读取，不用全部扫描了。 一个线程意味着一个栈，一个栈由多个栈帧组成，一个栈帧对应着一个方法，一个方法里面可能有多个安全点。 gc 发生时，程序首先运行到最近的一个安全点停下来，然后更新自己的 OopMap ，记下栈上哪些位置代表着引用。枚举根节点时，递归遍历每个栈帧的 OopMap ，通过栈中记录的被引用对象的内存地址，即可找到这些对象（ GC Roots ）。 因为一个方法有多个安全点，每个安全点就有一个OopMap，所以，一个方法里有多个OopMap。 可以把oopMap简单理解成是调试信息。在源代码里面每个变量都是有类型的，但是编译之后的代码就只有变量在栈上的位置了。oopMap就是一个附加的信息，告诉你栈上哪个位置本来是个什么东西。 这个信息是在JIT编译时跟机器码一起产生的。因为只有编译器知道源代码跟产生的代码的对应关系。 每个方法可能会有好几个oopMap，就是根据safepoint把一个方法的代码分成几段，每一段代码一个oopMap，作用域自然也仅限于这一段代码。 循环中引用多个对象，肯定会有多个变量，编译后占据栈上的多个位置。那这段代码的oopMap就会包含多条记录。 Rememebered SetRememberedSet 用于处理这类问题：比如说，新生代 gc （它发生得非常频繁）。一般来说， gc 过程是这样的：首先枚举根节点。根节点有可能在新生代中，也有可能在老年代中。这里由于我们只想收集新生代（换句话说，不想收集老年代），所以没有必要对位于老年代的 GC Roots 做全面的可达性分析。但问题是，确实可能存在位于老年代的某个 GC Root，它引用了新生代的某个对象，这个对象你是不能清除的。那怎么办呢？ 维护一个表，记录别的代对新生代的引用关系，这个表叫Remembered Set。 在G1收集器中，堆被分成一个个region，难免会存在别的region中的对象会引用某个region的对象，那么，就对每一个region维护一个Remembered Set，记录其他所有region对象对他其中对象的引用。 安全点在OopMap的帮助下，可以很容易的寻找GC Roots，但是，每一个指令都可能导致OopMap的变化，如果为每一条指令都生成一个对应的OopMap，那么，将会需要大量的空间。于是，HotSpot只是在特定的点记录了这些信息，这些点叫做安全点，程序旨在安全点才停下来执行GC。 如何让让所有的线程跑到安全点中断呢？ 抢先式中断和主动式中断。 抢先式中断是把所有的线程都中断，然后把不在安全点上的线程恢复，直到他到达安全点上。 主动式中断：设置一个中断标志，各个线程主动区轮询这个标志，发现中断标志为真时，自己主动挂起。 垃圾收集器所有的收集器都避免不了stop the word，只可能尽可能的缩短。 以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程； 串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。 Serial 适用于新生代和老年代。 单线程收集器，在他进行垃圾收集时，必须暂停所有其他工作的线程。 新生代采用复制算法，老年代采用标记-整理算法。 ParNew Serial的多线程版本。除了Serial，只有ParNew可以与CMS一起使用。 适用于新生代和老年代。 新生代采用复制算法，老年代采用标记-整理算法。 Parallel Scavenge+Parallel oldParallel Scavenge一个新生代收集器，特点是吞吐量优先。经常与Parallel Old一起使用 。 在注重吞吐量的情况下，使用Parallel Scavenge+Parallel old（科学计算，天文计算等）。 Parallel Scavenge新生代采用复制算法，Parallel old老年代采用标记-整理。 CMS基于标记-清除算法。并不是标记整理。 注重于获取最短停顿时间。并发收集，分区处理。停顿时间短，在垃圾收集的时候，JVM还可以运行。 分为以下四个流程： 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。 并发清除：不需要停顿。 在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。 CMS具有以下缺点： 在并发标记以及并发清除阶段，GC会占用一部分的CPU资源，会造成吞吐量下降CMS 默认启动的回收线程数=(CPU 数目+3)4 当 CPU 数&gt;4 时, GC线程一般占用不超过 25%的 CPU 资源, 但是当 CPU 数&lt;=4 时, GC线程 可能就会过多的占用用户 CPU 资源, 从而导致应用程序变慢, 总吞吐量降低.。 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。 G1用来替代CMS的。 特点 采用的是标记-整理算法+复制算法，避免产生内存空间碎片。。标记整理出需要回收的region，region间使用复制算法。 将整个Java堆分成一个个相等的独立区域，虽然还有分代的概念，但各个代不再是连续的，新生代和老年代不再物理隔离。。 可预测的停顿。 通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。 适用场景 服务端多核CPU、JVM内存占用较大的应用。 运行过程中会产生大量内存碎片。 想要可控的，可预期的GC停顿时间。 收集过程 初始标记，标记GC Roots直接关联对象，需要暂停，时间短 并发标记，对GC Roots进行可达性分析，并发执行，时间比较长。 最终标记，修正并发标记阶段而产生的变动，这一段是暂停的。 筛选回收，将各个region根据回收价值和回收成本进行排序，然后进行收集。这个阶段需要暂停用户线程。Minor GC and Full GCMinor GC回收新生代，因为新生代对象存活时间很短，因此Minor GC会频繁进行，执行速度也比较快。当Eden区域满了的话，会触发Minor GC。Full GC回收新生代和老年代，老年代因为存活时间比较长，因此Full GC很少执行，速度也比较慢。 触发Full GC： 老年代空间不足。 空间分配担保失败。 新生代采用复制收集算法，需要将存活的对象复制到survivor中，然后直接清理Eden区，但是会有一种情况，就是存活的对象大于survivor内存空间，这样，就需要老年代分配担保，将survivor中无法分配的对象放入老年代。但是，万一老年代也不够用呢？ 加入老年代剩余最大连续可用空间大于Eden区，那么肯定可以直接放。 否则的话，看老年代是否允许担保失败，可以的话，检查老年代剩余最大连续可用空间是否大于历次晋升到老年代对象的平均大小，如果大于，尝试进行Minor GC，小于的话，直接Full GC。 CMS垃圾收集器浮动垃圾的问题。因为在CMS并发清理阶段用户线程也在运行，所以需要留出一定的空间做缓冲。这样，老年代没有满的时候就需要触发Full GC,默认是92%。但要是预留的空间无法满足程序需要，就会报 Concurrent Mode Failure 错误，并触发 Full GC。 对象分配策略 对象优先在Eden区分配。当Eden区没有足够的空间进行分配时，会触发Minor GC。如果启动了TLAB，那么优先在TLAB上分配，G1默认就是启动TLAB的。 大对象直接进入老年代。 长期存活对象将进入老年代，对象每熬过一次Minor GC，年龄增加一岁，当年龄达到阈值(默认是15),那么这个对象晋升到老年代。 动态对象年龄判定。虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。 参考OopMap详解 OopMap与Remembered Set]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM类加载机制]]></title>
    <url>%2F2019%2F09%2F20%2FJVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Java程序运行时，有两个阶段，编译和运行。编译阶段将Java文件编译成class字节码文件，然后在运行阶段将class文件加载到内存，并对class文件解释执行。 Java跨平台原因Java语言跨平台的主要原因就是JVM以及字节码文件。 C语言是将高级语言直接解释成机器码，通过CPU指令集执行机器码，但是，不同架构的CPU，他的指令集可能是不一样的，这样就造成C语言难以跨平台。可是Java就不一样了，Java在机器和程序之间加了一次抽象的虚拟机。直接将Java程序编译成字节码，由Java虚拟机来解释字节码文件，对于不同的平台，解释器是不同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。 编译阶段 将Java文件转换成字节码文件。字节码文件存储了所有信息。 class文件中有一个class常量池，里面存放了字符串。 所以，类似于String s = “a”+”b”;在编译阶段会直接被优化为”ab”。 类加载阶段类加载就是将class文件加载到内存，并对数据进行校验，转换解析和初始化，最终转化成可被虚拟机使用的Java类型。类加载阶段是在运行期间完成的。 类加载阶段主要包括五个阶段：加载，验证，准备，解析，初始化。。 加载 通过一个类的全限定名获取字节码文件。 将字节码文件静态存储结构转化为运行时内存区域。 生成这个类的java.lang.class对象。存在于方法区（元空间）。 验证确保字节码文件信息是否合法。 准备为类变量(static 修饰)分配内存并设置初始值的阶段。 注意，这个阶段只是类变量设置初始值，而不包括实例变量。 设置初始值通常情况下指的是数据类型的零值。 1public static int a = 23; 这里只会将a设置为0，将a设置为23需要等到初始化阶段。 解析将class常量池内的符号引用替换为直接引用的过程。 初始化执行clinit()方法的过程，初始化类变量以及执行静态语句块。 clinit是类初始化的方法，init是对象初始化的方法，static静态语句块在clinit阶段执行，所以静态语句块肯定是先于构造函数执行的。 类初始化时机这几个阶段类必须要初始化，而不是类加载。 遇到new实例化对象，读取或者设置static字段。 反射调用。 初始化一个类，若父类还没有初始化，需要先初始化父类。 初始化主类(执行main方法的)。 类加载器对于任何一个类，都需要由加载他的类加载器以及这个类本身来确立他在JVM中的唯一性。比较两个类是否相等，首先应该是建立在同一个类加载器上的。两个类即使来自于同一个class文件，由不同的类加载器加载，这两个加载的类也是不相等的。 双亲委派模型 双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务(搜索范围内没有这个类)，子加载器才会尝试自己去加载，这就是双亲委派模式。 避免了类加载的混乱。比如说，在classpath下定义了一个java.lang.Object，要是没有双亲委派模型，那么应用程序类加载器会加载这个类，那么就会与启动类加载器加载的Object类冲突。但是要是有类加载机制，那么将会交给启动类加载器，这样加载的还是java自带的Object类，就不会产生冲突。 破坏双亲委派模型如何破坏双亲委派模型？ 继承ClassLoader，自己重写loadClass方法，然后加入自己逻辑，特定某些class可以按照你的方式处理。。 重写loadClass： findLoadedClass 委托parent加载器加载（这里注意bootstrap加载器的parent为null) 自行加载 打破委派机制要做的就是打乱2和3的顺序，通过类名筛选自己要加载的类，其他的委托给parent加载器 JDBC破坏因为类加载器受到加载范围的限制，在某些情况下父类加载器无法加载到需要的文件，这时候就需要委托子类加载器去加载class文件。 JDBC的Driver接口定义在JDK中，其实现由各个数据库的服务商来提供，比如MySQL驱动包。DriverManager 类中要加载各个实现了Driver接口的类，然后进行管理，但是DriverManager位于 $JAVA_HOME中jre/lib/rt.jar 包，由BootStrap类加载器加载，而其Driver接口的实现类是位于服务商提供的 Jar 包，根据类加载机制，当被装载的类引用了另外一个类的时候，虚拟机就会使用装载第一个类的类装载器装载被引用的类。也就是说BootStrap类加载器还要去加载jar包中的Driver接口的实现类。我们知道，BootStrap类加载器默认只负责加载 $JAVA_HOME中jre/lib/rt.jar 里所有的class，所以需要由子类加载器去加载Driver实现，这就破坏了双亲委派模型。通过线程上下文类加载器，默认是应用程序类加载器，可以通过Thread的方法进行设置。 Tomcat破坏tomcat破坏双亲委派模型 OSGI类加载器不再是双亲委派模型的树状结构，而是网状结构。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存管理]]></title>
    <url>%2F2019%2F09%2F20%2FJava%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[运行时数据区域包括程序计数器，java虚拟机栈，本地方法栈，方法区和堆。其中，java虚拟机栈，本地方法栈，程序计数器是每个线程私有的。 字节码文件经过类加载子系统从静态存储结构转化为方法区的运行时内存结构。运行时数据区域包括程序计数器，java虚拟机栈，本地方法栈，方法区和堆。其中，java虚拟机栈，本地方法栈，程序计数器是每个线程私有的，方法区以及堆是所有线程共享的。 堆所有线程共享。 主要存放对象以及数组对象的。 但是，由于现在逃逸技术的存在，对象并不一定都是存在于堆，还有可能存放在栈上。 java堆分为新生代和老年代，新生代又分为Eden区以及Survivor区。 当内存不足时，会产生OOM异常。 Java虚拟机栈线程私有，每一个线程都有一个自己的栈。 线程每执行一个方法，都会创建一个栈帧，用于存储局部变量表（对象引用，基本数据类型）等。方法调用直至完成的过程中，就是一个栈帧入栈和出栈的过程。两种异常情况： 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常； 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小： 1java -Xss512M HackTheJava 本地方法栈与Java虚拟机栈类似，只不过一个是为Java方法服务，一个是为Native方法服务，其他都一样。Native方法就是Java调用非Java代码的接口。例如调用C语言实现的接口。 程序计数器可以看作是当前线程执行到的字节码的行号指示器。对于Java的多线程，为了使程序每次切换后能够恢复到正确的执行位置，因此每一个线程必须要有自己独立的程序计数器。如果线程执行的是Java方法，记录的是正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。 方法区各个线程共享的区域。存放的是虚拟机加载的类信息，常量，静态变量。 在HotSpot中，永久代是方法区的实现。因为GC分代收集拓展到方法区。方法区主要是废弃类和常量的收集，对于方法区，也可以选择不进行垃圾回收。 一般来说，方法区不进行垃圾收集。 在jdk1.8之后，HotSpot中，删去了永久代，永久代的相关信息存放在了元空间。 元空间与永久代最大的不同就是，元空间并不在JVM中，而是在本地内存。主要原因还是因为永久代的大小难以确定，容易发生OOM，而移到元空间，只会受到本地内存大小的限制。 运行时常量池运行时常量池是方法区的一部分。 class常量池：我们写的每一个Java类被编译后，就会形成一份class文件；class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)。 class常量池在类加载完成后就会放入运行时常量池存放。 字符串常量池：存放字符串，位于堆内。常量池中同时存在字符串常量和字符串引用。直接赋值和用字符串调用String构造函数都可能导致常量池中生成字符串常量;而intern()方法会尝试将堆中对象的引用放入常量池。 类加载子系统类加载子系统负责从文件系统或者网络中加载 Class 信息，加载的类信息存放于一块称 为方法区的内存空间。 局部变量表所需要的内存空间在编译阶段就分配完毕。 对象的创建过程 虚拟机遇到一个new指令，首先从常量池中获取这个类的符号引用，检查这个符号引用代表的类是否被加载。 要是没有被加载，必须执行相应的类加载的过程。 为对象分配内存，主要有指针碰撞和空闲列表两种办法。指针碰撞是所有使用过的内存放一边，未使用过的内存放一边，中间一个指针作为分界线，当为一个对象分配内存的时候，直接移动指针即可。空闲列表适用于空闲内存和使用过的内存互相交错，内存的使用情况都存在一个表上，根据这个表再去分配内存。指针碰撞适用于标记-整理算法，空闲列表适用于标记-清除算法。 但是，如何解决分配内存过程中的并发问题呢？ 一个就是同步加锁。 另一个就是TLAB的使用，预先个每个线程在Java堆中都分配了一小块内存，哪个线程要给对象分配内存，直接在自己的TLAB中分配，当TLAB用完了，再分配新的，这一步才需要加锁。 设置对象头 执行init方法，初始化成员变量。 对象的内存布局对象在内存中主要分为三个部分：对象头，实例数据以及对齐填充。 对象头主要结构是由Mark Word 和 Class Metadata Address 组成 。Class Metadata Address存储的是该对象属于类的地址，即可以判断这个对象属于哪一个类。 MarkWord有五种类型：]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象概述]]></title>
    <url>%2F2019%2F09%2F19%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[面向对象有三大特性： 封装。只对外提供接口由外界访问。 继承。 多态。多态的三个条件：继承，重写，以及向上转型（父类引用指向子类对象）。 访问权限修饰符private:除了自己没有其他任何类可以访问。protected:同一包下的，以及自己的自类可以访问。default：同一包下面的。public：任何类都可以访问。 重写与重载重写：override，重新实现父类的方法。发生在运行期，动态分派。重载：方法名称相同，参数不同。返回值类型不同，参数类型相同不算是重载。发生在编译器，静态分派。 抽象类和接口抽象类使用abstract关键字声明，且抽象类至少应该包含一个抽象方法(只有声明没有实现)。 抽象类不可以被实例化。 抽象方法不能是private，这样方法就不能继承了。抽象类不能是final的。 接口在JDK8之前，没有任何方法的实现。从JDK8之后，接口也可以有默认方法的实现。 接口的成员都只能是public的。 接口的字段是public static final的，因此，接口字段一旦定义就不可以改了。 但是，在JDK1.8之后，interface加了一些新的特性。 可以添加静态方法。 1234567public interface TestInterface &#123; public static String sayHello() &#123; return "Hello world!"; &#125;&#125; 可以为接口方法提供一个默认实现。使用default标记。 12345678interface MyInterface&#123; String myNewName(String newName); default String myOldName()&#123; return "chao"; &#125;&#125; 区别 类只可以继承一个抽象类，却可以实现多个接口。 接口字段是static final的，不可以再去修改的，而抽象类却没有这种要求。 接口成员是public的，抽象类却没有这种要求。 super关于构造方法当new一个子类的时候，一定会先调用父类的构造方法，然后再去调用子类的构造方法。 123456789101112131415161718public class Parent &#123; public Parent()&#123; System.out.println("parent"); &#125;&#125;public class Son extends Parent &#123; public Son()&#123; System.out.println("son"); &#125;&#125;Son son = new Son();/*输出：parent son也就是说。当构造一个子类的时候，一定会先调用父类的构造方法。默认是调用父类无参的构造函数，若是想调用其它构造函数，可以通过super关键字实现。*/ 既然创建子类对象的时候，一定会先调用父类的构造方法，那么是否创建了父类呢？ 答案是没有。 只是创建了一个子类对象，this完全引用这个子类对象，super引用子类可以继承的成员变量以及方法。 super作用 访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super 函数。 访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。 内部类在一个类中再定义一个类。 内部类的好处 内部类可以访问外部类的所有成员，包括private。 为什么内部类可以随意访问外部类的成员？ 持有引用。当外部类的对象创建了一个内部类的对象时，内部类对象必定会秘密捕获一个指向外部类对象的引用，然后访问外部类的成员时，就是用那个引用来选择外围类的成员的。当然这些编辑器已经帮我们处理了。 内部类可以对外隐藏。 可以实现多重继承。 12345678910111213141516171819202122232425262728293031323334353637383940//类一public class ClassA &#123; public String name()&#123; return "liutao"; &#125; public String doSomeThing()&#123; // doSomeThing &#125;&#125;//类二public class ClassB &#123; public int age()&#123; return 25; &#125;&#125;//类三public class MainExample&#123; private class Test1 extends ClassA&#123; public String name()&#123; return super.name(); &#125; &#125; private class Test2 extends ClassB&#123; public int age()&#123; return super.age(); &#125; &#125; public String name()&#123; return new Test1().name(); &#125; public int age()&#123; return new Test2().age(); &#125; public static void main(String args[])&#123; MainExample mi=new MainExample(); System.out.println("姓名:"+mi.name()); System.out.println("年龄:"+mi.age()); &#125;&#125; 内部类与外部类的关系 对于非静态内部类，内部类的创建依赖外部类的实例对象，在没有外部类实例之前是无法创建内部类的。先有外部类对象，再有内部类对象。 对于静态内部类，内部类并不依赖于外部类对象的创建，static依赖于类本身，并不依赖类实例对象。 普通内部类不可以有静态成员，因为普通内部类需要依赖于外部对象而存在，需要outer.new InnerClass();，他是与对象相关的。 静态可以访问静态的，不可以访问非静态的；非静态静态和非静态都可以访问。所以，静态内部类不可以访问外部类非静态成员。 内部类创建12ClassOuter outer = new ClassOuter();ClassOuter.InnerClass inner = outer.new InnerClass(); 普通内部类123456public class InnerClassTest &#123; public class InnerClassA &#123; &#125;&#125; 内部类对象可以访问外部类对象中所有访问权限的字段，同时，外部类对象也可以通过内部类的对象引用来访问内部类中定义的所有访问权限的字段。 静态内部类静态内部类就像外部类的一个静态成员一样，创建其对象无需依赖外部类对象（访问一个类的静态成员也无需依赖这个类的对象，因为它是独立于所有类的对象的）。但是于此同时，静态内部类中也无法访问外部类的非静态成员，因为外部类的非静态成员是属于每一个外部类对象的，而本身静态内部类就是独立外部类对象存在的，所以静态内部类不能访问外部类的非静态成员，而外部类依然可以访问静态内部类对象的所有访问权限的成员，这一点和普通内部类无异。 匿名内部类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class InnerClassTest &#123; public int field1 = 1; protected int field2 = 2; int field3 = 3; private int field4 = 4; public InnerClassTest() &#123; System.out.println("创建 " + this.getClass().getSimpleName() + " 对象"); &#125; // 自定义接口 interface OnClickListener &#123; void onClick(Object obj); &#125; private void anonymousClassTest() &#123; // 在这个过程中会新建一个匿名内部类对象， // 这个匿名内部类实现了 OnClickListener 接口并重写 onClick 方法 OnClickListener clickListener = new OnClickListener() &#123; // 可以在内部类中定义属性，但是只能在当前内部类中使用， // 无法在外部类中使用，因为外部类无法获取当前匿名内部类的类名， // 也就无法创建匿名内部类的对象 int field = 1; @Override public void onClick(Object obj) &#123; System.out.println("对象 " + obj + " 被点击"); System.out.println("其外部类的 field1 字段的值为: " + field1); System.out.println("其外部类的 field2 字段的值为: " + field2); System.out.println("其外部类的 field3 字段的值为: " + field3); System.out.println("其外部类的 field4 字段的值为: " + field4); &#125; &#125;; // new Object() 过程会新建一个匿名内部类，继承于 Object 类， // 并重写了 toString() 方法 clickListener.onClick(new Object() &#123; @Override public String toString() &#123; return "obj1"; &#125; &#125;); &#125; public static void main(String[] args) &#123; InnerClassTest outObj = new InnerClassTest(); outObj.anonymousClassTest(); &#125;&#125; 匿名内部类中可以使用外部类的属性，但是外部类却不能使用匿名内部类中定义的属性，因为是匿名内部类，因此在外部类中无法获取这个类的类名，也就无法得到属性信息。 当匿名内部类访问局部变量的时候，局部变量必须是final的。 12345678910111213141516171819public class Button &#123; public void click(final int params)&#123; //匿名内部类，实现的是ActionListener接口 new ActionListener()&#123; public void onAction()&#123; System.out.println("click action..." + params); &#125; &#125;.onAction(); &#125; //匿名内部类必须继承或实现一个已有的接口 public interface ActionListener&#123; public void onAction(); &#125; public static void main(String[] args) &#123; Button button=new Button(); button.click(); &#125;&#125; 原因是：因为局部变量和匿名内部类的生命周期不同。 匿名内部类是创建后是存储在堆中的，而方法中的局部变量是存储在Java栈中，当方法执行完毕后，就进行退栈，同时局部变量也会消失。那么此时匿名内部类还有可能在堆中存储着，那么匿名内部类要到哪里去找这个局部变量呢？ 为了解决这个问题编译器为自动地帮我们在匿名内部类中创建了一个局部变量的备份，也就是说即使方法执结束，匿名内部类中还有一个备份，自然就不怕找不到了。 但是问题又来了。如果局部变量中的a不停的在变化。那么岂不是也要让备份的a变量无时无刻的变化。为了保持局部变量与匿名内部类中备份域保持一致。编译器不得不规定死这些局部域必须是常量，一旦赋值不能再发生变化了。所以为什么匿名内部类应用外部方法的域必须是常量域的原因所在了。 特别注意：在Java8中已经去掉要对final的修饰限制，但其实只要在匿名内部类使用了，该变量还是会自动变为final类型（只能使用，不能赋值）。 内部类导致内存泄漏 如果一个匿名内部类没有被任何引用持有，那么匿名内部类对象用完就有机会被回收。 如果内部类仅仅只是在外部类中被引用，当外部类的不再被引用时，外部类和内部类就可以都被GC回收。 如果当内部类的引用被外部类以外的其他类引用时，就会造成内部类和外部类无法被GC回收的情况，即使外部类没有被引用，因为内部类持有指向外部类的引用）。 所以，内部类内存泄露的原因就是有外部类以外的其他引用，这样内部类和外部类都无法被回收。 可以通过使用静态内部类来解决。 分析内部类]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 基础]]></title>
    <url>%2F2019%2F09%2F18%2Fjava-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[包装类型装箱12// 装箱 调用了 Integer.valueOf(2)，将int变成了一个Integer对象Integer x = 2; 装箱转换是指将一个值类型隐式地转换成一个object 类型，也就是创建一个object 实例并将这个值复制给这个object。 拆箱拆箱转换是指将一个对象类型显式地转换成一个值类型。 12Integer x = 2; //装箱int y = x; // 拆箱 调用了 X.intValue() 装箱和拆箱会造成相当大的性能损耗，因此尽量应该避免大量的装箱拆箱操作。 缓存池new Integer()与Integer.Valueof()区别： new Integer每次都会新建一个对象 Integer.Valueof()会复用缓存池中的对象 123456Integer x = new Integer(123);Integer y = new Integer(123);System.out.println(x == y); // falseInteger z = Integer.valueOf(123);Integer k = Integer.valueOf(123);System.out.println(z == k); // true 编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。 123//a = bInteger a = 123;Integer b = 123; String基本类型的变量数据都是存在栈中的，String常量放在常量池里面，String对象放在堆里面。 String常量String常量存放在常量池里面，常量池中相同的值只有一个。 123String s1="hello";String s2="hello";System.out.println(s1==s2);//true 第一句代码执行后就在常量池中创建了一个值为hello的String对象； 第二句执行时，因为常量池中存在hello所以就不再创建新的String对象了。 此时该字符串的引用在虚拟机栈里面。 因为s1和s2指向的是同一个对象，所以s1==s2 String对象String对象的本质是一个不可变的char数组。 123String a = new String("skj");String b = new String("skj");System.out.println(a==b);//false new String(“skj”)这一步到底做了什么？ 在字符串常量池里面创建一个对象，就是”skj”,首先会检查常量池里面有没有这个对象”skj”，没有的话在创建并返回对象的引用，有的话就直接返回这个对象的引用。 在堆上创建一个对象， new String，String对象的本质就是一个char数组，所以String对象中的char数组指向之前返回对象的引用 所以，new String(“skj”)这一句实际上是创建了两个对象，一个在字符串常量池，一个在堆上。 String特性 Strings are constant; their values cannot be changed after they are created. String buffers support mutable strings. Because String objects are immutable they can be shared. String是不可变的，因为String的本质是一个final char[]，所以String同时又是线程安全的。 String由final修饰，是不可以继承的。 字符串拼接问题12String str0 = "a";String str1 = str0 + "b"; 编译成字节码： 123456789101112131415 public static void main(java.lang.String[]); Code: 0: ldc #2 // String a 2: astore_1 3: new #3 // class java/lang/StringBuilder 6: dup 7: invokespecial #4 // Method java/lang/StringBuilder."&lt;init&gt;":()V 10: aload_1 11: invokevirtual #5 // Method java/lang/StringBuilder.append(Ljava/lang/String;)Ljava/lang/StringBuilder; 14: ldc #6 // String b 16: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 19: invokevirtual #7 // Method java/lang/StringBuilder.toString()Ljava/lang/String; 22: astore_2 23: return&#125; 转换成java就是： 12345String str0 = "a";StringBuilder sb = new StringBuilder();sb.append(str0).append("b");String str1 = sb.toString();return str1; 所以，字符串的拼接主要是通过StringBuilder来实现的。 要注意的是最后还有toString，返回的是一个String对象。 为什么返回的是一个新的String对象呢？ 因为String类的char数组是final的，他的指针一旦指向了常量池的某个String，就不可以再改变了. 1234String str0 = "a";for (int i = 0; i &lt; 10000; i++) &#123; str0 += "a";&#125; 当我们在循环体中进行字符串拼接，在循环体里面，每次拼接都会生成一个StringBuilder的临时对象，那么这个程序片段执行下去就会产生10000个StringBuilder的临时对象，这10000个临时对象都是必要的吗？显然不是，我们可以在循环体外直接创建一个StringBuilder对象，然后在循环体中通过append方法拼接字符串，这样就省下了创建并回收10000个临时对象的消耗。 因此，当我们大量使用字符串拼接的时候，还是使用StringBuilder比较好。 拼接示例 使用字符串连接符拼接 ： String s2=”se”+”cond”; 使用字符串加引用拼接 ： String s12=”first”+s2; 使用new String(“”)创建 ： String s3 = new String(“three”); 使用new String(“”)拼接 ： String s4 = new String(“fo”)+”ur”; 使用new String(“”)拼接 ： String s5 = new String(“fo”)+new String(“ur”); s2 ：这个在编译期间就自动进行了优化的，在常量池中存储一个”second”，并且s2指向它。 s12 ： JVM对于字符串引用，由于在字符串的”+”连接中，有字符串引用存在，而引用的值在程序编译期是无法确定的，即(&quot;first&quot;+s2)无法被编译器优化，只有在程序运行期来动态分配使用StringBuilder连接后的新String对象赋给s12。(编译器创建一个StringBuilder对象，并调用append()方法，最后调用toString()创建新String对象，以包含修改后的字符串内容)，常量池中并没有产生新的字符串常量。 s3 ： 用new String() 创建的字符串不是常量，不能在编译期就确定，所以new String() 创建的字符串不放入常量池中，它们有自己的地址空间。但是”three”字符串常量在编译期也会被加入到字符串常量池（如果不存在的话） s4 ： 同样不能在编译期确定，但是”fo”和”ur”这两个字符串常量也会添加到字符串常量池中，并且在堆中创建String对象。（字符串常量池并不会存放”four”这个字符串） s5 ： 原理同s4。 StringBuilderString的内部实现是一个用final的数组，因此String对象是不可变的，我们每次修改String时，实际上都是new出来了一个新的对象。因此，对于经常进行字符串的修改操作时，String类就需要不断创建新对象，性能极低。StringBuilder内部也是封装的一个字符数组，只不过该数组非final修饰，可以不断修改。所以对于一些经常需要修改字符串的情况，我们应首选StringBuilder。 123456789/** * The value is used for character storage. */ char[] value; /** * The count is the number of characters used. */ int count; append()1234567891011121314151617public AbstractStringBuilder append(String str) &#123; if (str == null) return appendNull(); int len = str.length(); ensureCapacityInternal(count + len); str.getChars(0, len, value, count); count += len; return this;&#125;private void ensureCapacityInternal(int minimumCapacity) &#123; // overflow-conscious code if (minimumCapacity - value.length &gt; 0) &#123; value = Arrays.copyOf(value, newCapacity(minimumCapacity)); &#125; &#125; 我们可以看到，当StringBuilder添加元素的时候，首先判断char[]是否满了，要是满了，Arrays.copyOf对数组进行扩容（返回的是一个新数组）。最后append的方法返回的this，也就是说，与String不同，他并没有创建一个新的对象，主要原因还是char[]不是final的，是可变的，他就可以转换新的指向。 StringBuilder，StringBuffer，String区别StringBuffer和StringBuilder都继承了抽象类AbstractStringBuilder，这个抽象类和String一样也定义了char[] value和int count，但是与String类不同的是，它们没有final修饰符。因此得出结论：String、StringBuffer和StringBuilder在本质上都是字符数组，不同的是，在进行连接操作时，String每次返回一个新的String实例，而StringBuffer和StringBuilder的append方法直接返回this，所以这就是为什么在进行大量字符串连接运算时，不推荐使用String，而推荐StringBuffer和StringBuilder。那么，哪种情况使用StringBuffe？哪种情况使用StringBuilder呢？ 12345678910public StringBuilder append(String str) &#123; super.append(str); return this; &#125;public synchronized StringBuffer append(String str) &#123; toStringCache = null; super.append(str); return this; &#125; 区别很明显，StringBuffer加了synchronized关键字，是线程安全的。 为何String要设计成不可变的？ 线程安全 字符串常量池的需要。字符串常量池的诞生是为了提升效率和减少内存分配。可以说我们编程有百分之八十的时间在处理字符串，而处理的字符串中有很大概率会出现重复的情况。正因为String的不可变性，常量池很容易被管理和优化。 字符串不变，HashCode也不变，便于缓存Hash Code，不需要重复计算HashCode。 intern()字符串常量池是在编译期间产生的，通过String的intern()也可以在运行时向字符串常量池放入字符串。 When the intern method is invoked, if the pool already contains a string equal to this String object as determined by the equals(Object) method, then the string from the pool is returned. Otherwise, this String object is added to the pool and a reference to this String object is returned. 简单来说就是intern用来返回常量池中的某字符串，如果常量池中已经存在该字符串，则直接返回常量池中该对象的引用。否则，在常量池中加入该对象，然后 返回引用。 123456789101112131415public static void main(String[] args) &#123; String s = new String("1"); s.intern(); String s2 = "1"; System.out.println(s == s2); String s3 = new String("1") + new String("1"); s3.intern(); String s4 = "11"; System.out.println(s3 == s4);&#125;/**输出：false true**/ 分析一下： 先看s3和s4.String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);，这样，在字符串常量池创建了一个”1”，并且在堆里也创建了一个对象”11”，但在11中是没有对象的。s3.intern()，先去常量池看看有没有”11”，没有，需要在常量池中存储一份”11”，但是在jdk8中常量池已经转移到堆中了，所以可以直接存储堆中的引用(在jdk6之前，常量池还在perm区，就需要再在常量池中存储一份)。所以，s4实际上是指向堆上对象的引用。 再看s1和s2.String s = new String(&quot;1&quot;);在常量池内已经存储了1，所以s3.intern()啥也没做，s还是指向堆上的对象，s1指向的是常量池的对象。 所以，String#intern 方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象。 String#intern的使用 位运算符&amp;:按位与 |:按位或 ~:异或 ^:取反 &lt;&lt;:左移位运算，同理还有右移位运算。 关键字final数据：声明数据为常量，一旦初始化之后及不可以改变。 方法：声明方法不可以被重写。 类：声明类不可以被继承。 static静态变量：类变量，这个变量是属于这个类的，类的所有实例共享，在内存中只存在一份。 静态方法：他在类加载的时候就存在了，它不依赖于任何实例，所以static方法必须实现。 static代码块：在类初始化的时候执行一次。 静态成员不可以访问非静态成员，非静态成员可以访问静态成员和非静态成员。 Object方法equals() and hashCode()hashcode()返回的是散列值，equals()用来判断两个对象是否等价，所以在重写equals()方法时一定要先重写hashcode()。等价的对象散列值一定相同，但是散列值相同对象不一定等价。 clone()需要实现Clonable接口并重写clone()方法，才可以实现拷贝。 123456789public class CloneExample implements Cloneable &#123; private int a; private int b; @Override public Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; 浅拷贝拷贝这个对象的时候，只对基本数据类型进行拷贝，而引用数据类型只是进行了引用的传递，这两个对象还是共享的引用数据类型。 1234567891011121314151617181920212223242526272829303132333435public class ShallowCloneExample implements Cloneable &#123; private int[] arr; public ShallowCloneExample() &#123; arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = i; &#125; &#125; public void set(int index, int value) &#123; arr[index] = value; &#125; public int get(int index) &#123; return arr[index]; &#125; @Override protected ShallowCloneExample clone() throws CloneNotSupportedException &#123; return (ShallowCloneExample) super.clone(); &#125;&#125;ShallowCloneExample e1 = new ShallowCloneExample();ShallowCloneExample e2 = null;try &#123; e2 = e1.clone();&#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace();&#125;e1.set(2, 222);System.out.println(e2.get(2)); // 222,e1修改了，e2也变了，说明两人引用的是同一个对象 深拷贝在对引用数据类型拷贝的时候，创建了一个新的对象。 123456789101112131415161718192021222324252627282930313233343536373839public class DeepCloneExample implements Cloneable &#123; private int[] arr; public DeepCloneExample() &#123; arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = i; &#125; &#125; public void set(int index, int value) &#123; arr[index] = value; &#125; public int get(int index) &#123; return arr[index]; &#125; @Override protected DeepCloneExample clone() throws CloneNotSupportedException &#123; DeepCloneExample result = (DeepCloneExample) super.clone(); result.arr = new int[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; result.arr[i] = arr[i]; &#125; return result; &#125;&#125;DeepCloneExample e1 = new DeepCloneExample();DeepCloneExample e2 = null;try &#123; e2 = e1.clone();&#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace();&#125;e1.set(2, 222);System.out.println(e2.get(2)); // 2 但是，一般来说，不推荐使用clone，可以使用拷贝构造函数来做。 12345678910111213141516171819202122232425262728293031public class CloneConstructorExample &#123; private int[] arr; public CloneConstructorExample() &#123; arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = i; &#125; &#125; public CloneConstructorExample(CloneConstructorExample original) &#123; arr = new int[original.arr.length]; for (int i = 0; i &lt; original.arr.length; i++) &#123; arr[i] = original.arr[i]; &#125; &#125; public void set(int index, int value) &#123; arr[index] = value; &#125; public int get(int index) &#123; return arr[index]; &#125;&#125;CloneConstructorExample e1 = new CloneConstructorExample();CloneConstructorExample e2 = new CloneConstructorExample(e1);e1.set(2, 222);System.out.println(e2.get(2)); // 2 反射反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。 当我们的程序在运行时，需要动态的加载一些类这些类可能之前用不到所以不用加载到jvm，而是在运行时根据需要才加载，这样的好处对于服务器来说不言而喻。 举个例子我们的项目底层有时是用mysql，有时用oracle，需要动态地根据实际情况加载驱动类，这个时候反射就有用了，假设 com.java.dbtest.myqlConnection，com.java.dbtest.oracleConnection这两个类我们要用，这时候我们的程序就写得比较动态化，通过Class tc = Class.forName(“com.java.dbtest.TestConnection”);通过类的全类名让jvm在服务器中找到并加载这个类，而如果是oracle则传入的参数就变成另一个了。 反射使用获取class对象1Class s = Class.forName("java.lang.String"); 创建实例1s.newInstance(); 获取方法123456//获取类或接口生命的方法，但不包括继承的方法public Method[] getDeclaredMethods() throws SecurityException//获取公有方法public Method[] getMethods() throws SecurityException//获取特定的方法，根据参数方法名以及参数类型public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 获取变量信息 getFiled：访问公有的成员变量 getDeclaredField：所有已声明的成员变量，但不能得到其父类的成员变量 调用方法通过invoke 123456789101112public class test1 &#123; public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123; Class&lt;?&gt; klass = methodClass.class; //创建methodClass的实例 Object obj = klass.newInstance(); //获取methodClass类的add方法 Method method = klass.getMethod("add",int.class,int.class); //调用method对应的方法 =&gt; add(1,4) Object result = method.invoke(obj,1,4); System.out.println(result); &#125;&#125; 访问私有方法和私有变量甚至可以通过反射访问私有成员。 只需要setAccessible(true)即可。 123456789101112131415161718192021222324private static void modifyPrivateFiled() throws Exception &#123; //1. 获取 Class 类实例 TestClass testClass = new TestClass(); Class mClass = testClass.getClass(); //2. 获取私有变量 Field privateField = mClass.getDeclaredField("MSG"); //3. 操作私有变量 if (privateField != null) &#123; //获取私有变量的访问权 privateField.setAccessible(true); //修改私有变量，并输出以测试 System.out.println("Before Modify：MSG = " + testClass.getMsg()); //调用 set(object , value) 修改变量的值 //privateField 是获取到的私有变量 //testClass 要操作的对象 //"Modified" 为要修改成的值 privateField.set(testClass, "Modified"); System.out.println("After Modify：MSG = " + testClass.getMsg()); &#125;&#125; 反射机制 深入解析Java反射 异常Exception可以通过try catch处理并且使程序恢复。 Error是程序运行时错误，程序会崩溃并且无法恢复。 泛型泛型就是参数化类型，在泛型使用过程中，操作类型的数据类型被定义为一个参数。 泛型最常见的使用是在容器中，我们给容器添加泛型，这样我们可以把所需要的类型作为参数传递给容器，这样，容器就可以接受所有类型的数据，而且同时只能是一个数据，保证了程序的健壮性。 泛型主要有泛型类，泛型接口，泛型方法。 在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。 泛型类1234567891011121314//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public class Generic&lt;T&gt;&#123; //key这个成员变量的类型为T,T的类型由外部指定 private T key; public Generic(T key) &#123; //泛型构造方法形参key的类型也为T，T的类型由外部指定 this.key = key; &#125; public T getKey()&#123; //泛型方法getKey的返回值类型为T，T的类型由外部指定 return key; &#125;&#125; 泛型接口123public interface Generator&lt;T&gt; &#123; public T next();&#125; 泛型方法12345678910111213141516171819class DataHolder&lt;T&gt;&#123; T item; public void setData(T t) &#123; this.item=t; &#125; public T getData() &#123; return this.item; &#125; /** * 泛型方法 * @param e */ public &lt;E&gt; void PrinterInfo(E e) &#123; System.out.println(e); &#125;&#125; public 与返回值中间的E声明这是一个泛型方法，只有声明了才可以使用泛型 没有声明，只是传参的时候使用了泛型，并不是一个泛型方法。 与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。 123456789101112131415161718192021222324252627/** * 这是一个泛型类 */class GenericClassDemo&lt;T&gt; &#123; /** * 这个不是泛型方法，只是使用了泛型类中已声明的T */ public void show1(T t)&#123; System.out.println(t.toString()); &#125; /** * 泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。 * 由于下面的泛型方法在声明的时候声明了泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型， * 编译器也能够正确识别泛型方法中识别的泛型。 */ public &lt;E&gt; void show2(E e)&#123; System.out.println(e.toString()); &#125; /** * 在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型; * 可以与泛型类中声明的T不是同一种类型。 * show3和show2的E和T只是简单的代指泛型,与泛型类中的T并不是一个 */ public &lt;T&gt; void show3(T t)&#123; System.out.println(t.toString()); &#125;&#125; 泛型擦除1234567891011List&lt;String&gt; stringArrayList = new ArrayList&lt;String&gt;();List&lt;Integer&gt; integerArrayList = new ArrayList&lt;Integer&gt;();Class classStringArrayList = stringArrayList.getClass();Class classIntegerArrayList = integerArrayList.getClass();if(classStringArrayList.equals(classIntegerArrayList))&#123; System.out.println("----equals----");&#125;//输出：----equals---- 通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段 通配符上界通配符&lt;? extends T&gt;,只能放置T以及T的子类。下界通配符&lt;? superT&gt;,只能防止T以及T的父类。无界通配符&lt;?&gt; ,没有要求。深入理解泛型 泛型详解]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DirectIO和PageCache]]></title>
    <url>%2F2019%2F09%2F11%2FDirectIO%E5%92%8CPageCache%2F</url>
    <content type="text"><![CDATA[PageCachePageCache一页有4KB左右。 当需要写入磁盘的时候，若每写入一个字节数据就调用IO，这样效率就太低了，所以在操作系统的底层会有一个缓冲区，叫做PageCache，当PageCache中存满了，再写入磁盘，这样大大减少了磁盘IO的次数。 上图是写入磁盘的过程，我们使用MMap或者是FileChannel都会经过PageCache层。例如，我们使用FileChannel的时候，先写进DirectByteBuffer中，当buffer中数据满的时候，先写入PageCache，再写入磁盘。 同样的，读取数据也是一样的，将数据以及其邻近的一些数据读取到PageCache。 例如，当用户发起一个 fileChannel.read(4kb) 之后，实际发生了两件事 操作系统从磁盘加载了 16kb 进入 PageCache，这被称为预读 操作通从 PageCache 拷贝 4kb 进入用户内存 最终我们在用户内存访问到了 4kb，为什么顺序读快？很容量想到，当用户继续访问接下来的[4kb,16kb]的磁盘内容时，便是直接从 PageCache 去访问了。试想一下，当需要访问 16kb 的磁盘内容时，是发生4次磁盘 IO 快，还是发生1次磁盘 IO+4 次内存 IO 快呢？答案是显而易见的，这一切都是 PageCache 带来的优化。 DirectIO虽然PageCache很好，但是我们有时候并不希望使用PageCache。 当我们有时候进行随即读的时候，其实有时候并不需要PageCache的预读。 PageCache是操作系统层面上的概念，用很难干预，User BufferCache显然比PageCache要可控的多。 当操作系统回收 PageCache 内存的速度低于应用写缓存的速度时，会影响磁盘写入的速率，直接表现为写入 RT 增大，这被称之为“毛刺现象”。 而DirectIO可以绕过PageCache。]]></content>
      <tags>
        <tag>IO</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零拷贝的问题]]></title>
    <url>%2F2019%2F09%2F11%2F%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[传统的IO的操作读操作缓冲技术是IO的基础，一次读取大量数据放在缓冲区，需要的时候从缓冲区取得数据。 详细可见：内核缓冲区问题 一个完整的read操作：当应用程序发起read请求后，会检查内核空间内是否有需要读取的数据（pageCache）,如果有，直接copy到用户空间；如果没有，那么需要从磁盘读取，磁盘控制器通过DMA操作将数据从磁盘读取到内核空间，然后才从内核空间拷贝到用户空间。 DMA：不需要通过CPU调度，由DMA控制器来处理，不需要麻烦CPU。 读写操作使用传统的I/O程序读取文件内容, 并写入到另一个文件(或Socket)。性能开销比较大： 上下文切换(context switch), 此处有4次用户态和内核态的切换 Buffer内存开销, 一个是应用程序buffer, 另一个是系统读取buffer以及socket buffer。 需要进行四次拷贝，2次DMA copy和两次CPU copy。传统IO四次内容拷贝： 先将文件内容从磁盘中拷贝到操作系统buffer 再从操作系统buffer拷贝到程序应用buffer 从程序buffer拷贝到socket buffer 从socket buffer拷贝到协议引擎.零拷贝 MMap将物理内存映射到虚拟内存中。 在mmap之后，并没有在将文件内容加载到物理页上，只上在虚拟内存中分配了地址空间。当进程在访问这段地址时，若虚拟内存对应的page没有在物理内存中缓存，则产生”缺页”，将相应的页面载入物理内存。 mmap()会返回一个指针ptr，它指向进程逻辑地址空间中的一个地址，这样以后，进程无需再调用read或write对文件进行读写，而只需要通过ptr就能够操作文件。但是ptr所指向的是一个逻辑地址，要操作其中的数据，必须通过MMU将逻辑地址转换成物理地址，若MMU没有相应的映射，产生缺页中断，将页面重新置入内存。 省去了从内核缓冲区复制到用户空间的过程，只有从磁盘调入到物理内存的过程。它的最终目的是将磁盘中的文件映射到用户进程的虚拟地址空间，实现用户进程对文件的直接读写，减少了文件复制的开销，提高了用户的访问效率。 mmap+write如何映射，见更多细节。 sendFile拷贝过程： 首先通过DMA copy将数据从磁盘读取到kernel buffer中 然后通过CPU copy将数据从kernel buffer copy到sokcet buffer中 最终通过DMA copy将socket buffer中数据copy到网卡buffer中发送sendfile与read/write方式相比，少了一次复制，少了两次上下文切换。改进后的sendFilesendFile中间copy到socket buffer这一步仍是多余的。改进后的：拷贝过程： DMA copy将磁盘数据copy到kernel buffer中 向socket buffer中追加当前要发送的数据在kernel buffer中的位置和偏移量 DMA gather copy根据socket buffer中的位置和偏移量直接将kernel buffer中的数据copy到网卡上。 改进后的只有两次复制了。]]></content>
      <tags>
        <tag>IO</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java nio操作实践]]></title>
    <url>%2F2019%2F07%2F26%2Fjava-nio%E6%93%8D%E4%BD%9C%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[java文件中文件IO主要包括普通IO，FileChannel以及MMap。本文主要介绍FileChannel以及MMap的一些原理以及使用，理解他们最好需要了解有关pageCache，内存零拷贝，堆外缓存的一些知识。 有关pageCache可见 PageCache和DirectIO ， 有关零拷贝可见 零拷贝问题 。 获取方式1234//获取FileChannelFileChannel fileChannel = new RandomAccessFile(new File("db.data"), "rw").getChannel();//获取MMapMappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0, filechannel.size()); FileChannel 写`` 123456789101112131415// 写byte[] data = new byte[4096];long position = 1024L;//指定 position 写入 data中 的数据fileChannel.write(ByteBuffer.wrap(data), position);//从当前文件指针的位置写入 4kb 的数据fileChannel.write(ByteBuffer.wrap(data));// 读ByteBuffer buffer = ByteBuffer.allocate(4096);long position = 1024L;//指定 position 读取 4kb 的数据到bufferfileChannel.read(buffer,position)；//从当前文件指针的位置读取 4kb 的数据fileChannel.read(buffer); FileChannel+ByteBuffer可以达到写入速度比较快，要是没有缓冲区的存在，FileChannel写入速度并不比普通IO，一般来说缓冲区的大小是由磁盘决定的。 那么，FileChannel是直接把ByteBuffer写到磁盘的吗？ 不是，中间还隔着一个PageCache。当ByteBUffer是堆内内存时，数据需要经历ByteBuffer-&gt;内核空间-&gt;PageCache。当ByteBufefr是直接内存，则省略到了从用户空间到内核空间的复制，直接ByteBuffer-&gt;PageCache，然后再从PageCache写回磁盘。 我们都知道磁盘 IO 和内存 IO 的速度可是相差了好几个数量级。我们可以认为 filechannel.write 写入 PageCache 便是完成了落盘操作，但实际上，操作系统最终帮我们完成了 PageCache 到磁盘的最终写入（这是异步的），理解了这个概念，你就应该能够理解 FileChannel 为什么提供了一个 force() 方法，用于通知操作系统进行及时的刷盘。 例如，RocketMQ刷盘方式： 异步刷盘方式：在返回写成功状态时，消息可能只是被写入了内存的PAGECACHE，写操作的返回快，吞吐量大；当内存里的消息量积累到一定程度时，统一触发写磁盘操作，快速写入 同步刷盘方式：在返回写成功状态时，消息已经被写入磁盘。具体流程是，消息写入内存的PAGECACHE后，立刻通知刷盘线程刷盘，然后等待刷盘完成，刷盘线程执行完成后唤醒等待的线程，返回消息写成功的状态。 MMap读写`` 12345678910111213141516171819// 写byte[] data = new byte[4];int position = 8;//从当前 mmap 指针的位置写入 4b 的数据mappedByteBuffer.put(data);//指定 position 写入 4b 的数据MappedByteBuffer subBuffer = mappedByteBuffer.slice();subBuffer.position(position);subBuffer.put(data);// 读byte[] data = new byte[4];int position = 8;//从当前 mmap 指针的位置读取 4b 的数据mappedByteBuffer.get(data)；//指定 position 读取 4b 的数据MappedByteBuffer subBuffer = mappedByteBuffer.slice();subBuffer.position(position);subBuffer.get(data); mmap是把文件映射到用户空间里的虚拟内存，这样就省去了从用户空间到内核空间的拷贝，这样，当我们需要向文件中写入数据时，先看虚拟内存中有没有对应的地址，即有没有将物理地址映射到虚拟内存，要是有的话，可以像操作内存一样操作这个文件，没有的话，产生缺页，加载相对应的页。 mmap 把文件映射到用户空间里的虚拟内存，省去了从内核缓冲区复制到用户空间的过程，文件中的位置在虚拟内存中有了对应的地址，可以像操作内存一样操作这个文件，相当于已经把整个文件放入内存，但在真正使用到这些数据前却不会消耗物理内存，也不会有读写磁盘的操作，只有真正使用这些数据时，也就是图像准备渲染在屏幕上时，虚拟内存管理系统 VMS 才根据缺页加载的机制从磁盘加载对应的数据块到物理内存进行渲染。这样的文件读写文件方式少了数据从内核缓存到用户空间的拷贝，效率很高。 但是，MMap是不适用于大量数据的。 因为一次map的大小在1.5G左右，要是大量数据的话必然要进行多次MMap，重复的map会带来虚拟内存回收，重新分配的问题。 MMAP 使用的是虚拟内存，和 PageCache 一样是由操作系统来控制刷盘的，虽然可以通过 force() 来手动控制，但这个时间把握不好，在小内存场景下会很令人头疼。 MMAP 的回收问题，当 MappedByteBuffer 不再需要时，可以手动释放占用的虚拟内存，但非常麻烦。 所以，对于小数据量刷盘的情况下，可以使用MMap，例如索引，但是其他场景，FileChannel+DirectByteBuffer完全可以替代，并且性能跟MMap差不多。 堆内内存与堆外内存 堆内内存 堆外内存 底层实现 数组，JVM 内存 unsafe.allocateMemory(size)返回直接内存 分配大小限制 -Xms-Xmx 配置的 JVM 内存相关，并且数组的大小有限制，在做测试时发现，当 JVM free memory 大于 1.5G 时，ByteBuffer.allocate(900M) 时会报错 可以通过 -XX:MaxDirectMemorySize 参数从 JVM 层面去限制，同时受到机器虚拟内存（说物理内存不太准确）的限制 垃圾回收 不必多说，gc自动回收 当 DirectByteBuffer 不再被使用时，会出发内部 cleaner 的钩子，保险起见，可以考虑手动回收：((DirectBuffer) buffer).cleaner().clean(); 内存复制 堆内内存 -&gt; 堆外内存 -&gt; pageCache 堆外内存 -&gt; pageCache 对于堆外内存，可使用池+堆外内存组合。例如：ThreadLocal&lt;ByteBuffer&gt; 和 ThreadLocal&lt;byte[]&gt;。 UnsafeReferrenceIO操作读写测试]]></content>
      <tags>
        <tag>java nio</tag>
      </tags>
  </entry>
</search>
