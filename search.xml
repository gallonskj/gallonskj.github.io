<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[操作系统同步互斥]]></title>
    <url>%2F2019%2F10%2F08%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%2F</url>
    <content type="text"></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统进程]]></title>
    <url>%2F2019%2F10%2F07%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程进程是资源分配的基本单位，他是程序运行时的一个实例。程序运行时，系统会创建一个进程，并分配相关的资源。 程序是静态的，进程是动态的。一个程序可以对应多个进程，一个进程可以包括多个程序。 进程=程序+数据+状态信息。 PCB(进程控制块)每个进程都有一个进程控制块，他是进程的唯一标识。进程块描述进程的基本信息和运行状态。所谓的进程的创建与销毁，就是对PCB的创建与销毁。 各个进程块在内存中应该是以链表的形式存储的，因为进程块需要频繁的进行插入与删除。 进程的生命周期最主要的就是就绪，运行，阻塞三个状态。操作系统创建一个进程完成后，并为其分配了除了cpu之外的所有的资源，那么进程进入就绪(ready)状态，当CPU处于空闲的时候，就绪状态的进程占用CPU，进入运行（running）状态。正在执行的进程，由于等待某个事件发生而无法执行时，便放弃CPU而处于阻塞（waiting）状态。 ready-&gt;running当没有其他进程占用CPU，所有的ready进程就可以去竞争CPU，获得CPU的进程进入running状态。 running-&gt;waiting正在执行的进程，因为等待某个事件发生而放弃CPU时，进入waiting状态。比如I/O阻塞，申请缓冲区不能满足、等待信件等。 running-&gt;ready处于执行状态的进程在其执行过程中，因分配给它的一个时间片已用完或更高优先级的进程抢占而不得不让出处理机，于是进程从执行状态转变成就绪状态。 waiting-&gt;ready当等待事件完成的时候，从阻塞进入就绪态。需要正在运行的进程对他唤醒。 进程切换因为所有的进程都有自己独立的地址空间。 页表以及地址空间的切换。 寄存器，程序计数器，堆栈的切换。 进程上下文切换过程： 保存现场。暂停当前进程，从运行态变为其他状态，保存当前进程的上下文，包括CPU寄存器状态，程序计数器状态等。保存在PCB中。 选取进程。调度另一个进程从就绪转为运行。 恢复现场。从内存中恢复下一个要执行的进程的上下文，恢复该进程原来的状态到寄存器，恢复程序执行上一次暂停的地方。从PCB中取。 在进程切换的过程中，页表会改变，地址空间会改变，高速缓存中的存储的数据过期，也需要进行切换。 进程挂起将进程从内存转移到磁盘上。进程挂起状态包括阻塞挂起（在外存，处于阻塞）和就绪挂起（在外存，就绪状态）。 进程挂起状态转换： 阻塞到阻塞挂起。内存不够时，将阻塞状态的进程移到外存，变为阻塞挂起状态。 就绪到就绪挂起。有高优先级阻塞和低优先级就绪，那么将低优先级挂起。 运行到就绪挂起。 挂起是将进程从内存转移到磁盘，而阻塞是由于资源得不到满足暂时无法获取CPU，还是在内存的。 状态队列操作系统中维护了多个队列，不同的队列来表示不同的状态。就绪队列，阻塞队列，运行队列等。方便操作系统管理进程。 线程当我们并发的需求时，如果采用多进程的话，因为进程每个进程都有自己的独立空间，进程间通信麻烦，还有进程切换的时候需要进行保护现场恢复现场，十分耗费资源，效率低下。于是，引入了线程。 线程是轻量级的进程。所有的线程共享进程的地址空间，进程间开销小，通信方便。进程中的所有线程共享代码，文件等资源。但是，他们都有自己的堆栈，寄存器等。 进程是资源分配的角色，线程是执行功能的角色。一个线程崩溃，整个进程崩溃。因此，在对于安全性过高的场合，我们一般使用进程来解决并发问题。比如说，我们的浏览器，每开一个界面，就创建一个进程。 OS中两种线程根据操作系统能够感知到线程，分为用户线程以及内核线程。 内核线程内核完成线程的创建以及管理。内核分配CPU是以线程为单位的。 优点： 一个线程阻塞不会导致整个进程阻塞。 内核会为每一个线程分配CPU，对于多线程的进程，时间片时间大大增加。 缺点： 线程切换要从用户态转移到内核态，耗费大，速度慢。 用户线程用户级的线程库完成线程的创建以及管理。内核资源的分配仍然是按照进程（用户进程）进行分配的。不依赖于操作系统的内核，操作系统感受不到用户线程的存在。 缺点： 因此，对于操作系统来说，这个用户线程所属的进程是没有线程的，因此，一个线程的阻塞将导致整个进程的阻塞，因为，对于操作系统来说，他看到的只是这个进程，这个用户线程阻塞，对操作系统来说就是整个进程阻塞，所以这个进程将会阻塞。 因为没有操作系统的管制，一个用户线程拿到了分配给这个进程的时间片，他会一直霸占着，除非她主动放弃，或者到这个时间片结束，可能会导致别的用户线程没有机会执行。 优点： 但是，用户线程切换不需要从用户态转到内核态，消耗小，速度快。 总的来说，对于用户线程，操作系统是感受不到，还是会把它看作一个进程来进行处理。 内核线程与用户线程 多线程模型将用户线程与内核线程绑定。主要有一对一，多对一，以及多对多。操作系统中主要使用多对多。 多对一多个用户线程与一个内核线程绑定。 缺点是一个线程阻塞，这多个用户线程都会被阻塞。 一对一一个用户线程绑定一个内核线程。 缺点是每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大，会影响到应用程序的性能。 多对多将 n 个用户级线程映射到 m 个内核级线程上，要求 m &lt;= n。 不会出现一个用户线程阻塞，所有线程都阻塞的情况。 详解多线程模型 与进程区别 进程是资源分配的最小单位，线程是程序执行的最小单位。 进程有自己的独立空间，每创建一个进程，都要为他分配独立的地址空间，花费很大。而线程是共享进程地址空间的，花费要小很多。 进程之间的通信需要以通信的方式（IPC)进行，需要通过内核来通信。而线程可以通过共享变量等方式进行。 进程之间切换时间比线程之间切换时间要大得多。因为进程之间页表是不同的，需要切换页表，开销比较大。因为各个进程页表不同，TLB，缓存信息可能都需要重新加载。而线程是共享的。 一个进程死掉，对其他进程没有影响；一个线程死掉，整个进程就会崩溃。当一个线程向非法地址读取或者写入，无法确认这个操作是否会影响同一进程中的其它线程，所以只能是整个进程一起崩溃。 线程切换与进程上下文切换不同的是，线程上下文切换没有页表以及地址空间的切换，因为同一个进程的线程共享同一个地址空间。只需要进行程序计数器，寄存器，以及线程的堆栈的切换。 fork and execlinux的fork 和exec 函数。 fork() 复制出一个子进程，这个进程几乎是当前进程的一个拷贝：子进程和父进程使用相同的代码段；子进程复制父进程的堆栈段和数据段。这样，父进程的所有数据都可以留给子进程，但是，子进程一旦开始运行，虽然它继承了父进程的一切数据，但实际上数据却已经分开，相互之间不再有影响了，也就是说，它们之间不再共享任何数据了。它们再要交互信息时，只有通过进程间通信来实现，这将是我们下面的内容。既然它们如此相象，系统如何来区分它们呢？这由函数的返回值来决定的。对于父进程， fork函数返回了子程序的进程号，而对于子程序，fork函数则返回零。在操作系统中，我们用ps函数就可以看到不同的进程号，对父进程而言，它的进程号是由比它更低 层的系统调用赋予的，而对于子进程而言，它的进程号即是fork函数对父进程的返回值。在程序设计中，父进程和子进程都要调用函数fork（）下面的代码，而我们就是利用fork（）函数对父子进程的不同返回值用if…else…语句来实现让父子进程完成不同的功能。 exec将替换现有进程，执行exec的程序。 一个进程一旦调用exec类函数，它本身就”死亡”了，系统把代码段替换成新的程序的代码，废弃原有的数据段和堆栈段，并为新程序分配新的数据段与堆栈段，唯一留下的，就是进程号，也就是说，对系统而言，还是同一个进程，不过已经是另一个程序了。 僵尸进程和孤儿进程正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 一个子进exit()之后，内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。直到父进程通过wait / waitpid来取时才释放。这样，一个进程才算是完全终止掉。 当一个父进程迟迟没有调用wait()，这个子进程内存中保存的信息就迟迟不会释放，包括进程号也不会释放，操作系统的进程号是有限的，因此僵尸进程的危害很大。 当一个父进程退出，子进程还在运行，那么子进程将会称为孤儿进程。孤儿进程会被init进程处理，使用wait()完成进程的终止等，因此，孤儿进程是没有坏处的。 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。 僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统概述]]></title>
    <url>%2F2019%2F10%2F07%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[什么是操作系统操作系统主要进行应用程序管理，资源管理，外设管理等工作。 在操作系统中，将CPU抽象为进程，将内存抽象为地址空间，将磁盘抽象为文件。 OS=shell+kernel.shell就是GUI或者是命令行。Kernel是操作系统的核心。kernel主要完成的工作包括CPU调度，物理内存虚拟内存的管理，文件系统的管理，中断处理，外设管理等。 kernel的特征： 并发（应用并发执行）。 共享。某一个公共资源是可以共享访问的还是互斥访问的。 虚拟化。将物理实体虚拟化为逻辑实体。主要包括时分复用(时间片)和空分复用(虚拟内存)。 异步。 OS启动过程Disk：存储bootloader以及OS.BIOS:基本IO处理系统。 最先放入内存的是BIOS启动固件。BIOS的第一步是检测外设，完成后，将bootloader加载进内存，并且CPU控制权转交给bootloader，bootloader再将磁盘上的OS加载进内存，这是OS掌控CPU。 BIOS—&gt;加载bootloader—&gt;加载OS。（所以说我们安装系统的时候要先进入BIOS设置启动项，这个启动项就是bootloader）。 系统调用，中断，异常都需要从用户态转移到内核态。 中断机制来源于外设。 为了支持CPU 和设备之间 的 并行操作。当IO事件完成之后，设备中断通知CPU，CPU在进行相应事件的处理。可以看作是一种异步操作啊。 当CPU 启动设备进行输入/输出后 ，设备便可以独立工作，CPU 转去处理与此次输入/输出不相关的 事情；当设备完成输入/输出后，通过向CPU 发中断报告此次 输入/输出的结果，让CPU 决定如何处理以后的事情。 中断过程 设备（硬件）将中断事件的ID传递给中断寄存器。不同的中断ID范围代表不同的中断类型。 CPU在执行完一条指令后，会查看中断寄存器，假如有中断的话，进行中断处理。 CPU保存现场。保存各种寄存器等。 CPU 根据中断码查中断向量表，获得与该中断相关的处理程序的入口地址。 进行相应中断处理。 恢复之前保存的处理状态。 异常来源于应用程序。CPU执行指令非法。 异常过程与中断过程差不多，也是保存现场，处理，恢复现场这几个过程。 但是不同的是，异常一般是交给进程自己来处理，而中断是由内核的中断函数来处理，根据不同的中断类型执行不同的中断函数。 系统调用当应用程序需要调用系统级别的函数请求。 系统调用过程 每一个系统调用对应一个系统调用号。 根据系统调用号选取相应的系统调用例程进行系统调用。 返回系统调用结果。 系统调用需要从用户态切换到内核态。 总结系统调用，中断，异常机制其实都是大同小异。在操作系统中都维持着一个表，中断是中断号和中断函数对应，系统调用是系统调用号和系统调用函数，根据ID去调用相应的函数，返回结果。 而且OS都需要从用户态转到内核态。]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO线程模型]]></title>
    <url>%2F2019%2F09%2F30%2FIO%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[阻塞I/O 每一条连接都需要建立一个独立的线程来处理，机器耗费线程资源。 当没有数据读写时，线程还会阻塞。Reactor模式 IO多路复用+线程池来实现。I/O多路复用来解决会有多个线程阻塞的问题，IO多路复用只会造成一个线程阻塞。线程池不必为每个连接都建立一个新的线程。 Reactor模型，是指通过一个或多个输入同时传递给服务处理器的服务请求的事件驱动处理模式。 服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor模式也叫Dispatcher模式，即I/O多路复用统一监听事件，收到事件后分发(Dispatch给某进程)。 Reactor两个关键组成： Reactor负责监听和分发事件，分发给适当的处理程序来对IO事件做出反应。 Handler处理程序执行I/O事件要完成的实际事件.单Reactor Reactor对象通过select不断轮询监控客户端请求事件，收到事件后通过dispatch进行分发 如果是建立连接请求事件，则由Acceptor通过accept处理连接请求，然后创建一个Handler对象处理连接完成后的后续业务处理 如果不是建立连接事件，则Reactor会分发调用连接对应的Handler来响应 Handler会完成read-&gt;业务处理-&gt;send的完整业务流程单Reactor多线程主要通过建立一个线程池。Worker线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给Handler进行处理。 主从Reactor多线程 Reactor主线程MainReactor对象通过select监控建立连接事件，收到事件后通过Acceptor接收，处理建立连接事件。 Accepto处理建立连接事件后，MainReactor将Socket分配Reactor子线程给SubReactor进行处理。 SubReactor将Socket加入连接队列进行监听，并创建一个Handler用于处理各种连接事件，例如读写操作。 当有新的事件发生时，SubReactor会调用连接对应的Handler进行响应 Handler通过read读取数据后，会分发给后面的Worker线程池进行业务处理 Worker线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给Handler进行处理 Handler收到响应结果后通过send将响应结果返回给clientNIO代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142package nioDemo; import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.CharBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.nio.charset.Charset;import java.util.Iterator;import java.util.Random;import java.util.Set; /*服务器端，:接收客户端发送过来的数据并显示， *服务器把上接收到的数据加上"echo from service:"再发送回去*/public class ServiceSocketChannelDemo &#123; public static class TCPEchoServer implements Runnable&#123; /*服务器地址*/ private InetSocketAddress localAddress; public TCPEchoServer(int port) throws IOException&#123; this.localAddress = new InetSocketAddress(port); &#125; @Override public void run()&#123; ServerSocketChannel ssc = null; Selector selector = null; Random rnd = new Random(); try &#123; /*创建选择器*/ selector = Selector.open(); /*创建服务器通道*/ ssc = ServerSocketChannel.open(); ssc.configureBlocking(false); /*设置监听服务器的端口，设置最大连接缓冲数为100*/ ssc.bind(localAddress, 100); /*服务器通道只能对tcp链接事件感兴趣*/ ssc.register(selector, SelectionKey.OP_ACCEPT); &#125; catch (IOException e1) &#123; System.out.println("server start failed"); return; &#125; System.out.println("server start with address : " + localAddress); /*服务器线程被中断后会退出*/ try&#123; while(!Thread.currentThread().isInterrupted())&#123; int n = selector.select(); if(n == 0)&#123; continue; &#125; Set&lt;SelectionKey&gt; keySet = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; it = keySet.iterator(); SelectionKey key = null; while(it.hasNext())&#123; key = it.next(); /*防止下次select方法返回已处理过的通道*/ it.remove(); /*若发现异常，说明客户端连接出现问题,但服务器要保持正常*/ try&#123; /*ssc通道只能对链接事件感兴趣*/ if(key.isAcceptable())&#123; /*accept方法会返回一个普通通道， 每个通道在内核中都对应一个socket缓冲区*/ SocketChannel sc = ssc.accept(); sc.configureBlocking(false); /*向选择器注册这个通道和普通通道感兴趣的事件，同时提供这个新通道相关的缓冲区*/ int interestSet = SelectionKey.OP_READ; sc.register(selector, interestSet, new Buffers(256,256)); System.out.println("accept from"+ sc.getRemoteAddress()); &#125; /*（普通）通道感兴趣读事件且有数据可读*/ if(key.isReadable())&#123; /*通过SelectionKey获取通道对应的缓冲区*/ Buffers buffers = (Buffers)key.attachment(); ByteBuffer readBuffer = buffers.getReadBuffer(); ByteBuffer writeBuffer = buffers.gerWriteBuffer(); /*通过SelectionKey获取对应的通道*/ SocketChannel sc = (SocketChannel) key.channel(); /*从底层socket读缓冲区中读入数据*/ sc.read(readBuffer); readBuffer.flip(); /*解码显示，客户端发送来的信息*/ CharBuffer cb = utf8.decode(readBuffer); System.out.println(cb.array()); readBuffer.rewind(); /*准备好向客户端发送的信息*/ /*先写入"echo:"，再写入收到的信息*/ writeBuffer.put("echo from service:".getBytes("UTF-8")); writeBuffer.put(readBuffer); readBuffer.clear(); /*设置通道写事件*/ key.interestOps(key.interestOps() | SelectionKey.OP_WRITE); &#125; /*通道感兴趣写事件且底层缓冲区有空闲*/ if(key.isWritable())&#123; doSomething(); &#125; &#125;catch(IOException e)&#123; System.out.println("service encounter client error"); /*若客户端连接出现异常，从Seletcor中移除这个key*/ key.cancel(); key.channel().close(); &#125; &#125; Thread.sleep(rnd.nextInt(500)); &#125; &#125;catch(InterruptedException e)&#123; System.out.println("serverThread is interrupted"); &#125; catch (IOException e1) &#123; System.out.println("serverThread selecotr error"); &#125;finally&#123; try&#123; selector.close(); &#125;catch(IOException e)&#123; System.out.println("selector close failed"); &#125;finally&#123; System.out.println("server close"); &#125; &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException, IOException&#123; Thread thread = new Thread(new TCPEchoServer(8080)); thread.start(); Thread.sleep(100000); /*结束服务器线程*/ thread.interrupt(); &#125; &#125; Proactor模型（异步）主要的核心在于回调机制。Reactor在接收事件后需要交给Reactor处理。而Proactor直接由操作系统来处理相关事件，然后返回结果。 理解高性能网络模型]]></content>
      <categories>
        <category>IO</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I/O模型]]></title>
    <url>%2F2019%2F09%2F29%2FIO%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Socket与ServerSocket网络通信需要一对socket，即通信的两端各有一个socket，两个socket之间形成一个管道，进行数据流的通信。ServerSocketServerSocket监听服务器端的一个端口，当一个客户端发送来连接时，ServerSocket来处理连接，成功后返回一个常规的Socket对象，用来与客户端socket进行数据传输。 同步 异步 阻塞 非阻塞同步与异步主要是从消息通知机制角度来说的。当一个同步调用发出后，调用者要一直等待返回消息（结果）后，才能进行后续的执行；当一个异步过程调用发出后，调用者不能立刻得到返回消息（结果），实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。异步是调用完成后由别人来通知他。 阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的。阻塞调用是指调用结果返回之前，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务。非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。如果在这个等待的过程中，等待者除了等待消息通知之外不能做其它的事情，那么该机制就是阻塞的。 阻塞与同步是不同的。如果这个线程在等待函数返回时，仍在执行其他消息处理，那么这就是同步非阻塞。如果这个线程在等待函数返回时，没有执行其他消息处理，而是挂起等待，那么就是同步阻塞 概念说明操作系统将内存空间分为了内核空间和用户空间。进程切换非常的耗资源，所以能不挂起进程就不挂起进程。将进程阻塞是让出CPU资源。 对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：1. 等待数据准备 (Waiting for the data to be ready)2. 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process) Linux IO的五种模型阻塞IO 当应用进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在进程这边，整个应用进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，应用进程才解除block的状态，重新运行起来。在内核执行I/O的两个阶段，都是阻塞的。每个连接都需要配套一个线程，不适合高并发的情况。 在阻塞的过程中，这个线程被挂起了，但是他让出了CPU，其他应用进程可以继续占用CPU执行。 非阻塞IO基于轮询的方式。当所请求的I/O操作不能满足要求时候，不把本进程投入睡眠，而是返回一个错误。也就是说当数据没有到达时并不等待，而是以一个错误返回。并且进程会多次轮询的请求I/O操作。应用程序的线程需要不断的进行 I/O 系统调用，轮询数据是否已经准备好，如果没有准备好，继续轮询，直到完成系统调用为止 。这样，好处是线程不需要一直阻塞，但是需要不断地进行I/O系统调用，不断轮询，浪费CPU。不断发起I/O操作及其浪费CPU资源。同步非阻塞就是 “每隔一会儿瞄一眼进度条” 的轮询（polling）方式。需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。 I/O多路复用基于操作系统的poll，select，epoll。非阻塞IO问题：由于同步非阻塞方式需要不断主动轮询，轮询占据了很大一部分过程，轮询会消耗大量的CPU时间，但是服务器端可能会有多个连接，这样他对每一个连接都这样做，要是连接数量太多时，是不适合的。 IO多路复用有两个特别的系统调用select、poll、epoll函数。select调用是内核级别的，select轮询相对非阻塞的轮询的区别在于—前者可以等待多个socket，能实现同时对多个IO端口进行监听，当其中任何一个socket的数据准好了，就能返回进行可读，然后进程再进行recvform系统调用，将数据由内核拷贝到用户进程，当然这个过程是阻塞的。 select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。 这几个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这两个函数可以同时阻塞多个I/O操作（只需要阻塞一个select函数）。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时（注意不是全部数据可读或可写），才真正调用I/O操作函数。 上面的图和blocking IO的图其实并没有太大的不同，在两个阶段都需要阻塞。当连接数量很少的时候，I/O多路复用可能比BIO效率还要低，因为I/O多路复用需要多执行一个select内核操作。但是I/O多路复用的优势在于他可以处理更多的连接，而不是处理单个连接速度更快。与传统的多线程/多进程模型比，I/O多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降底了系统的维护工作量，节省了系统资源。 信号驱动IO在信号驱动式I/O模型中，应用程序使用套接口进行信号驱动I/O，并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。 基本不怎么用。 异步IO用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知（回调函数）。IO两个阶段，进程都是非阻塞的。 异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。 总结注意：同步非阻塞I/O和I/O多路复用，在返回可读条件后，都需要再调用一次I/O操作，进行复制数据。首先一个IO操作其实分成了两个步骤：发起IO请求和实际的IO操作，同步IO和异步IO的区别就在于第二个步骤是否阻塞，如果实际的IO读写阻塞请求进程，那么就是同步IO，因此阻塞IO、非阻塞IO、IO复用、信号驱动IO都是同步IO，如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，那么就是异步IO。阻塞IO和非阻塞IO的区别在于第一步，发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。 select poll epoll目前支持I/O多路复用的系统调用有 select，poll，epoll，I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。select，pselect，poll，epoll本质上都是同步I/O。 文件描述符用于表述指向文件的引用的抽象化概念。。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。 Linux的socket事件wakeup callback机制linux wakeup callback机制是IO多路复用的本质。 Linux通过socket睡眠队列来管理所有等待socket的某个事件的进程（Process），同时通过wakeup机制来异步唤醒整个睡眠队列上等待事件的Process，通知Process相关事件发生。 每个socket维护了一个队列，比如socket可读的时候，内核就会唤醒队列里的各个Process，并且执行每个Process的callback函数。 每一个socket都有sleep_list,当某个进程所关心的事件在socket中并没有发生，那么将进程插入到sleep_list，当socket的时间发生了，那么就去遍历他sleep_list中的每个进程的callback函数。 select我们以read事件为例子。当socket上所监听的事件发生了，那么相应的进程就去处理。那么怎么获取监听的事件发生呢？我们应该block在等待事件的发生上，这个事件简单点就是关心的N个socket中一个或多个socket有数据可读了，当block解除的时候，就意味着，我们一定可以找到一个或多个socket上有可读的数据。 根据wakeup callback。所以，进程需要同时插入到我们管理的这好多个socket的sleep_list上等待任意一个socket可读事件发生而被唤醒，当Process被唤醒的时候，其callback里面应该有个逻辑去检查具体哪些socket可读了。 举个例子：假设c1，c2，c3连接到了服务器端，我们想监听他们的读事件，因此我们将进程p1插入到他们与服务器各自的socket中sleep_list中去，此时没有事件发生，因此进程处于睡眠状态，当c1客户端发送来了数据，有数据读取的时候，p1进程被唤醒。伪代码： 123456789private int sk_event;void poll() &#123; //其他逻辑... when (receive queue is not empty) &#123; sk_event |= POLL_IN； &#125; //其他逻辑...&#125; 当receive queue不为空的时候（即收到了消息），我们就给这个socket的sk_event添加一个POLL_IN事件，用来表示当前这个socket可读。将来Process遍历到这个socket，发现其sk_event包含POLL_IN的时候，就可以对这个socket进行读取数据操作了。 接下来，p1执行select，select会将需要监控的readfds集合拷贝到内核空间（因为内核才能通知说某个socket可读），然后遍历自己监控的socket，挨个调用socket的poll逻辑以便检查该socket是否有可读事件。遍历完所有的socket后，如果没有任何一个sk可读，那么select会调用schedule，使得Process进入睡眠（或者睡眠timeout这么长时间）。如果在timeout时间内某个socket上有数据可读了，或者等待timeout了，则调用select的Process会被唤醒。伪代码如下： 12345for (socket in readfds) &#123; sk_event.evt = socket.poll(); sk_event.sk = socket; return_event_for_process;&#125; 1int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。select缺点：1.文件描述符的数量存在最大限制，在Linux上一般为1024。 2.对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。每次select()都需要扫描所有的fd_set。而epoll是通过注册回调函数来实现的，所以epoll效率大大高于select. 3.需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。 poll解决了文件描述符数量限制的情况。 1int poll (struct pollfd *fds, unsigned int nfds, int timeout); poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。与select两点区别：1.文件描述符大小不限制。2.不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。 12345struct pollfd &#123; int fd; /* file descriptor */ short events; /* requested events to watch */ short revents; /* returned events witnessed */&#125;; pollfd结构包含了要监视的event和发生的event。 epoll解决了需要循环遍历文件描述符的缺点，解决了需要将大量的fds从内核拷贝到用户空间的问题。 将大量的fds从内核拷贝到用户空间的解决：共享内存。epoll通过内核与用户空间mmap同一块内存来解决。mmap将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址（不管是用户空间还是内核空间都是虚拟地址，最终要通过地址映射映射到物理地址），使得这块物理内存对内核和对用户均可见，减少用户态和内核态之间的数据交换。 需要循环遍历文件描述符的解决：epoll引入了一个中间层，一个双向链表ready_list，一个单独的睡眠队列single_epoll_wait_list。1.调用epoll之前，我们希望我们的MyProcess可以管理四个socket。2.四个socket都没有事件，这时候MyProcess进入single_epoll_wait_list并且sleep。3.有一个socket（大红色）收到了数据，触发其wait_entry_sk，把这个socket加入到ready_list里。4.MyProcess被唤醒（从single_epoll_wait_list出来了表示被唤醒），来处理ready_list中的所有socket：遍历epoll的ready_list，挨个调用每个socket的poll逻辑收集发生的事件，对于监控可读事件而已，ready_list上的每个socket都是有数据可读的，这里的遍历必要的。 epoll有两种工作模式，LT和ET。LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。 ServerSocket与SocketLinux 五种IO模型select、poll、epoll详解Linux IO模式及 select、poll、epoll详解深入理解select，poll，epoll]]></content>
      <categories>
        <category>IO</category>
      </categories>
      <tags>
        <tag>IO</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程]]></title>
    <url>%2F2019%2F09%2F29%2FJava%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[并发作用将多核CPU的计算能力发挥到极致，性能得到提升。 面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分。 并发缺点 线程安全问题。 频繁的上下文切换。 概念并发与并行Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once。并发指的是多个任务交替进行，而并行则是指真正意义上的“同时进行”。实际上，如果系统内只有一个CPU，而使用多线程时，那么真实系统环境下不能并行，只能通过切换时间片的方式交替进行，而成为并发执行任务。真正的并行也只能出现在拥有多个CPU的系统中。 同步与异步阻塞与非阻塞临界区资源]]></content>
      <tags>
        <tag>Java并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字节码执行引擎]]></title>
    <url>%2F2019%2F09%2F25%2F%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[分派重载和重写在JVM中是如何实现的？ 静态分派重载的实现。 重载时是通过参数的静态类型而不是实际类型决定使用哪个重载函数。 12//Father是静态类型 ， Son是实际类型。Father father = new Son(); 发生在编译阶段。 12345678910111213141516 void test() &#123; Father father = new Son(); //静态分派 print(father); &#125; void print(Father father) &#123; System.out.println("this is father"); &#125; void print(Son son) &#123; System.out.println("this is son"); &#125;/*输出：this is father**/ 动态分派重写的实现。 发生在运行阶段。 1234567891011121314151617181920212223242526public class DynamicDispatch &#123; static abstract class Human&#123; protected abstract void sayHello(); &#125; static class Man extends Human&#123; @Override protected void sayHello() &#123; System.out.println("man say hello!"); &#125; &#125; static class Woman extends Human&#123; @Override protected void sayHello() &#123; System.out.println("woman say hello!"); &#125; &#125; public static void main(String[] args) &#123; Human man=new Man(); Human woman=new Woman(); man.sayHello(); woman.sayHello(); man=new Woman(); man.sayHello(); &#125;&#125; 我们从invokevirtual指令的多态查找过程开始说起，invokevirtual指令的运行时解析过程大致分为以下几个步骤： 1、找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。2、如果在类型C中找到与常量中的描述符和简单名称相符合的方法，然后进行访问权限验证，如果验证通过则返回这个方法的直接引用，查找过程结束；如果验证不通过，则抛出java.lang.IllegalAccessError异常。3、否则未找到，就按照继承关系从下往上依次对类型C的各个父类进行第2步的搜索和验证过程。4、如果始终没有找到合适的方法，则跑出java.lang.AbstractMethodError异常。 由于invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是Java语言方法重写的本质。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM垃圾收集机制]]></title>
    <url>%2F2019%2F09%2F21%2FJVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[GC需要完成三件事： 哪些对象需要回收？ 何时进行回收？ 怎么样回收？ 哪些对象需要回收死掉的对象需要回收。 如何判断对象已死？可达性分析算法+finalize(). 可达性分析把一系列称为”GC Roots”的对象作为起点，向下进行搜索，当GC Roots到某个对象不可达时，这个对象就是可回收的。 GC Roots对象包括： 虚拟机栈中引用的对象。 方法区中类静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中引用的对象。 为什么不使用引用计数法呢？ 引用计数法就是每当加了一个引用，引用计数器加一，一个引用失效，引用计数器减一，引用计数器为零时该对象死亡。 但是引用计数无法解决的是循环引用的问题。 循环引用： 1234567891011121314public class Test &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub MyObject object1 = new MyObject(); MyObject object2 = new MyObject(); object1.object = object2; object2.object = object1; object1 = null; object2 = null; System.gc(); &#125; finalize()即使某个对象是不可达的，也并不一定非死不可。宣告一个对象死亡，要经过两次标记过程：第一个是GC Roots不可达，第二步是此对象是否有必要执行finalize()方法。 如果该对象重写了finalize()方法且finalize()方法还没有被虚拟机所调用，则其对象需要执行该方法。 那么，该对象会放入一个队列之中，并由一个Finalizer线程去执行finalize()方法。finalize方法是对象拯救自己的最后一次方法，只需要与任何一个GC Roots建立关联即可。这样他就还是存活的。 12345678910111213141516171819202122232425262728293031323334353637383940public class FinalizeEscape &#123; public static FinalizeEscape SAVE=null; @Override protected void finalize() throws Throwable &#123; // TODO Auto-generated method stub super.finalize(); System.out.println("finalize excute...."); FinalizeEscape.SAVE=this; &#125; public void isAlive() &#123; System.out.println(" i am still alive ....."); &#125; public static void main(String[] args) throws Exception&#123; // TODO Auto-generated method stub SAVE=new FinalizeEscape(); SAVE=null; System.gc(); Thread.sleep(500); if(SAVE==null) &#123; System.out.println(" i am dead ....."); &#125;else &#123; SAVE.isAlive(); &#125; SAVE=null; System.gc(); Thread.sleep(500); if(SAVE==null) &#123; System.out.println(" i am dead ....."); &#125;else &#123; SAVE.isAlive(); &#125; &#125; /* 输出： finalize excute.... i am still alive ..... i am dead ..... */ 由此可见，SAVE对象的finalize()方法确实执行了，并在收集前成功逃脱了。 代码中有两段完全一样的方法，第一次成功逃脱，第二次因为已经执行过了finalize()方法，所以也就不在执行了，因此第二段代码逃脱失败。 然而，并不鼓励使用finalize()方法。 四种引用类型 强引用： 强引用是使用最普遍的引用。Object obj =new Object(); 如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。 软引用： 如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。使用SoftReferrnce类实现软引用。 弱引用： 被弱引用引用的对象只能生存到下一次垃圾回收之前。当GC开始工作时，无论内存是否充足，都会回收弱引用引用的对象。使用WeakReference来实现弱引用类。 虚引用： 顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。 方法区GC方法区主要回收废弃常量以及无用的类。 废弃常量，没有地方引用他。 废弃类需要满足以下条件： 该类所有实例已经被回收。 加载该类classLoader已经被回收。 该类的class对象没有在任何地方被引用。 对于jdk8之后方法区变为了元空间，如果Metaspace的空间占用达到了设定的最大值，也会触发GC来收集死亡对象和类的加载器。 MetaSpace GC GC算法标记-清除 标记出所有需要回收的对象，然后将做了标记的都给清除。缺点是导致内存碎片化。 复制 将内存一般分为A区域，一半分为B区域。图中我们将前两行分为A，后两行分为B。刚开始的时候，我们只使用A区域的内存，而不使用B区域的内存。 第一次GC，经过一次可达性分析后，我们将A中存活对象直接复制到B区域，然后直接将整块A区域清除。A区域变成未使用的。第二次GC，同理，将B的存活对象复制到A，将B清除，B变为空。 这样A和B区域交互使用。 这个算法可以解决内存碎片化的问题，但是会导致内存浪费，一次只能使用一半的内存。 新生代主要使用的是复制算法。一般来说，Eden：Survior1：Survior2=8：1：1，因为每次GC新生代垃圾都会有75%-90%，这样，直接将Eden幸存的对象复制到Survior1区域中，然后将Eden区域清除，第二次清除时，将Eden区域和S1区域幸村对象复制到S2区域，将Eden和S1区域清除，就这样，S1，S2两个区域交替使用，新生代内存利用空间可以达到90%，而且解决了内存碎片化的问题。注意，当Survior内存区域不够时（多于10%对象存活），可以向老年代进行分配担保。 适用于存活率比较低的对象，要是存活率过高的话，会造成大量复制，效率变低。 标记-整理复制算法在对象存活率较高时就会产生一个问题，因为要进行过多的复制操作，效率会降低，而且浪费空间会比较多。对于老年代，存活对象率比较高，而且对象比较大，占用内存大，所以不宜使用复制算法，采用标记整理算法。 将存活的对象移到回收对象留下的空间里，以形成连续的内存。 适用于存活率较高的。 总结新生代中，每次GC都有大量对象死去，少量存活，选用复制算法。 老年代中，对象存活率高，没有额外空间进行内存担保，使用标记-整理。 HotSpot算法实现两个问题 寻找GC Roots效率问题，如果逐个检查引用，太慢。 使用OopMap来解决，这个数据结构存储了引用以及他的作用范围(从哪个指令开始到哪个指令结束)。 在类加载完成的时候，就生成了一个OopMap。 一致性问题。寻找GC Roots这个阶段需要保证引用情况不再发生变化，因此需要发生GC停顿。 OopMap与Rememebered SetOopMap编译时就有了。 用于枚举GC Roots。 当垃圾回收时，收集线程会对栈上的内存进行扫描，看看那些位置上存储了Reference类型。如果发现了某个位置上存储的是Reference类型，就意味着这个引用所指向的对象在这一次垃圾回收过程中不能够回收。 但是要是逐个检查引用，这一样效率太低了。 于是采用空间换时间的方法，把栈中是引用类型的变量的位置记录下来，这样他指向的对象肯定是GC Roots。这样，再做GC的时候，就可以直接读取，不用全部扫描了。 一个线程意味着一个栈，一个栈由多个栈帧组成，一个栈帧对应着一个方法，一个方法里面可能有多个安全点。 gc 发生时，程序首先运行到最近的一个安全点停下来，然后更新自己的 OopMap ，记下栈上哪些位置代表着引用。枚举根节点时，递归遍历每个栈帧的 OopMap ，通过栈中记录的被引用对象的内存地址，即可找到这些对象（ GC Roots ）。 因为一个方法有多个安全点，每个安全点就有一个OopMap，所以，一个方法里有多个OopMap。 可以把oopMap简单理解成是调试信息。在源代码里面每个变量都是有类型的，但是编译之后的代码就只有变量在栈上的位置了。oopMap就是一个附加的信息，告诉你栈上哪个位置本来是个什么东西。 这个信息是在JIT编译时跟机器码一起产生的。因为只有编译器知道源代码跟产生的代码的对应关系。 每个方法可能会有好几个oopMap，就是根据safepoint把一个方法的代码分成几段，每一段代码一个oopMap，作用域自然也仅限于这一段代码。 循环中引用多个对象，肯定会有多个变量，编译后占据栈上的多个位置。那这段代码的oopMap就会包含多条记录。 Rememebered SetRememberedSet 用于处理这类问题：比如说，新生代 gc （它发生得非常频繁）。一般来说， gc 过程是这样的：首先枚举根节点。根节点有可能在新生代中，也有可能在老年代中。这里由于我们只想收集新生代（换句话说，不想收集老年代），所以没有必要对位于老年代的 GC Roots 做全面的可达性分析。但问题是，确实可能存在位于老年代的某个 GC Root，它引用了新生代的某个对象，这个对象你是不能清除的。那怎么办呢？ 维护一个表，记录别的代对新生代的引用关系，这个表叫Remembered Set。 在G1收集器中，堆被分成一个个region，难免会存在别的region中的对象会引用某个region的对象，那么，就对每一个region维护一个Remembered Set，记录其他所有region对象对他其中对象的引用。 安全点在OopMap的帮助下，可以很容易的寻找GC Roots，但是，每一个指令都可能导致OopMap的变化，如果为每一条指令都生成一个对应的OopMap，那么，将会需要大量的空间。于是，HotSpot只是在特定的点记录了这些信息，这些点叫做安全点，程序旨在安全点才停下来执行GC。 如何让让所有的线程跑到安全点中断呢？ 抢先式中断和主动式中断。 抢先式中断是把所有的线程都中断，然后把不在安全点上的线程恢复，直到他到达安全点上。 主动式中断：设置一个中断标志，各个线程主动区轮询这个标志，发现中断标志为真时，自己主动挂起。 垃圾收集器所有的收集器都避免不了stop the word，只可能尽可能的缩短。 以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程； 串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。 Serial 适用于新生代和老年代。 单线程收集器，在他进行垃圾收集时，必须暂停所有其他工作的线程。 新生代采用复制算法，老年代采用标记-整理算法。 ParNew Serial的多线程版本。除了Serial，只有ParNew可以与CMS一起使用。 适用于新生代和老年代。 新生代采用复制算法，老年代采用标记-整理算法。 Parallel Scavenge+Parallel oldParallel Scavenge一个新生代收集器，特点是吞吐量优先。经常与Parallel Old一起使用 。 在注重吞吐量的情况下，使用Parallel Scavenge+Parallel old（科学计算，天文计算等）。 Parallel Scavenge新生代采用复制算法，Parallel old老年代采用标记-整理。 CMS基于标记-清除算法。并不是标记整理。 注重于获取最短停顿时间。并发收集，分区处理。停顿时间短，在垃圾收集的时候，JVM还可以运行。 分为以下四个流程： 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。 并发清除：不需要停顿。 在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。 CMS具有以下缺点： 在并发标记以及并发清除阶段，GC会占用一部分的CPU资源，会造成吞吐量下降CMS 默认启动的回收线程数=(CPU 数目+3)4 当 CPU 数&gt;4 时, GC线程一般占用不超过 25%的 CPU 资源, 但是当 CPU 数&lt;=4 时, GC线程 可能就会过多的占用用户 CPU 资源, 从而导致应用程序变慢, 总吞吐量降低.。 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。 G1用来替代CMS的。 特点 采用的是标记-整理算法+复制算法，避免产生内存空间碎片。。标记整理出需要回收的region，region间使用复制算法。 将整个Java堆分成一个个相等的独立区域，虽然还有分代的概念，但各个代不再是连续的，新生代和老年代不再物理隔离。。 可预测的停顿。 通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。 适用场景 服务端多核CPU、JVM内存占用较大的应用。 运行过程中会产生大量内存碎片。 想要可控的，可预期的GC停顿时间。 收集过程 初始标记，标记GC Roots直接关联对象，需要暂停，时间短 并发标记，对GC Roots进行可达性分析，并发执行，时间比较长。 最终标记，修正并发标记阶段而产生的变动，这一段是暂停的。 筛选回收，将各个region根据回收价值和回收成本进行排序，然后进行收集。这个阶段需要暂停用户线程。Minor GC and Full GCMinor GC回收新生代，因为新生代对象存活时间很短，因此Minor GC会频繁进行，执行速度也比较快。当Eden区域满了的话，会触发Minor GC。Full GC回收新生代和老年代，老年代因为存活时间比较长，因此Full GC很少执行，速度也比较慢。 触发Full GC： 老年代空间不足。 空间分配担保失败。 新生代采用复制收集算法，需要将存活的对象复制到survivor中，然后直接清理Eden区，但是会有一种情况，就是存活的对象大于survivor内存空间，这样，就需要老年代分配担保，将survivor中无法分配的对象放入老年代。但是，万一老年代也不够用呢？ 加入老年代剩余最大连续可用空间大于Eden区，那么肯定可以直接放。 否则的话，看老年代是否允许担保失败，可以的话，检查老年代剩余最大连续可用空间是否大于历次晋升到老年代对象的平均大小，如果大于，尝试进行Minor GC，小于的话，直接Full GC。 CMS垃圾收集器浮动垃圾的问题。因为在CMS并发清理阶段用户线程也在运行，所以需要留出一定的空间做缓冲。这样，老年代没有满的时候就需要触发Full GC,默认是92%。但要是预留的空间无法满足程序需要，就会报 Concurrent Mode Failure 错误，并触发 Full GC。 对象分配策略 对象优先在Eden区分配。当Eden区没有足够的空间进行分配时，会触发Minor GC。如果启动了TLAB，那么优先在TLAB上分配，G1默认就是启动TLAB的。 大对象直接进入老年代。 长期存活对象将进入老年代，对象每熬过一次Minor GC，年龄增加一岁，当年龄达到阈值(默认是15),那么这个对象晋升到老年代。 动态对象年龄判定。虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。 参考OopMap详解 OopMap与Remembered Set]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM类加载机制]]></title>
    <url>%2F2019%2F09%2F20%2FJVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Java程序运行时，有两个阶段，编译和运行。编译阶段将Java文件编译成class字节码文件，然后在运行阶段将class文件加载到内存，并对class文件解释执行。 Java跨平台原因Java语言跨平台的主要原因就是JVM以及字节码文件。 C语言是将高级语言直接解释成机器码，通过CPU指令集执行机器码，但是，不同架构的CPU，他的指令集可能是不一样的，这样就造成C语言难以跨平台。可是Java就不一样了，Java在机器和程序之间加了一次抽象的虚拟机。直接将Java程序编译成字节码，由Java虚拟机来解释字节码文件，对于不同的平台，解释器是不同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。 编译阶段 将Java文件转换成字节码文件。字节码文件存储了所有信息。 class文件中有一个class常量池，里面存放了字符串。 所以，类似于String s = “a”+”b”;在编译阶段会直接被优化为”ab”。 类加载阶段类加载就是将class文件加载到内存，并对数据进行校验，转换解析和初始化，最终转化成可被虚拟机使用的Java类型。类加载阶段是在运行期间完成的。 类加载阶段主要包括五个阶段：加载，验证，准备，解析，初始化。。 加载 通过一个类的全限定名获取字节码文件。 将字节码文件静态存储结构转化为运行时内存区域。 生成这个类的java.lang.class对象。存在于方法区（元空间）。 验证确保字节码文件信息是否合法。 准备为类变量(static 修饰)分配内存并设置初始值的阶段。 注意，这个阶段只是类变量设置初始值，而不包括实例变量。 设置初始值通常情况下指的是数据类型的零值。 1public static int a = 23; 这里只会将a设置为0，将a设置为23需要等到初始化阶段。 解析将class常量池内的符号引用替换为直接引用的过程。 初始化执行clinit()方法的过程，初始化类变量以及执行静态语句块。 clinit是类初始化的方法，init是对象初始化的方法，static静态语句块在clinit阶段执行，所以静态语句块肯定是先于构造函数执行的。 类初始化时机这几个阶段类必须要初始化，而不是类加载。 遇到new实例化对象，读取或者设置static字段。 反射调用。 初始化一个类，若父类还没有初始化，需要先初始化父类。 初始化主类(执行main方法的)。 类加载器对于任何一个类，都需要由加载他的类加载器以及这个类本身来确立他在JVM中的唯一性。比较两个类是否相等，首先应该是建立在同一个类加载器上的。两个类即使来自于同一个class文件，由不同的类加载器加载，这两个加载的类也是不相等的。 双亲委派模型 双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务(搜索范围内没有这个类)，子加载器才会尝试自己去加载，这就是双亲委派模式。 避免了类加载的混乱。比如说，在classpath下定义了一个java.lang.Object，要是没有双亲委派模型，那么应用程序类加载器会加载这个类，那么就会与启动类加载器加载的Object类冲突。但是要是有类加载机制，那么将会交给启动类加载器，这样加载的还是java自带的Object类，就不会产生冲突。 破坏双亲委派模型如何破坏双亲委派模型？ 继承ClassLoader，自己重写loadClass方法，然后加入自己逻辑，特定某些class可以按照你的方式处理。。 重写loadClass： findLoadedClass 委托parent加载器加载（这里注意bootstrap加载器的parent为null) 自行加载 打破委派机制要做的就是打乱2和3的顺序，通过类名筛选自己要加载的类，其他的委托给parent加载器 JDBC破坏因为类加载器受到加载范围的限制，在某些情况下父类加载器无法加载到需要的文件，这时候就需要委托子类加载器去加载class文件。 JDBC的Driver接口定义在JDK中，其实现由各个数据库的服务商来提供，比如MySQL驱动包。DriverManager 类中要加载各个实现了Driver接口的类，然后进行管理，但是DriverManager位于 $JAVA_HOME中jre/lib/rt.jar 包，由BootStrap类加载器加载，而其Driver接口的实现类是位于服务商提供的 Jar 包，根据类加载机制，当被装载的类引用了另外一个类的时候，虚拟机就会使用装载第一个类的类装载器装载被引用的类。也就是说BootStrap类加载器还要去加载jar包中的Driver接口的实现类。我们知道，BootStrap类加载器默认只负责加载 $JAVA_HOME中jre/lib/rt.jar 里所有的class，所以需要由子类加载器去加载Driver实现，这就破坏了双亲委派模型。通过线程上下文类加载器，默认是应用程序类加载器，可以通过Thread的方法进行设置。 Tomcat破坏tomcat破坏双亲委派模型 OSGI类加载器不再是双亲委派模型的树状结构，而是网状结构。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存管理]]></title>
    <url>%2F2019%2F09%2F20%2FJava%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[运行时数据区域包括程序计数器，java虚拟机栈，本地方法栈，方法区和堆。其中，java虚拟机栈，本地方法栈，程序计数器是每个线程私有的。 字节码文件经过类加载子系统从静态存储结构转化为方法区的运行时内存结构。运行时数据区域包括程序计数器，java虚拟机栈，本地方法栈，方法区和堆。其中，java虚拟机栈，本地方法栈，程序计数器是每个线程私有的，方法区以及堆是所有线程共享的。 堆所有线程共享。 主要存放对象以及数组对象的。 但是，由于现在逃逸技术的存在，对象并不一定都是存在于堆，还有可能存放在栈上。 java堆分为新生代和老年代，新生代又分为Eden区以及Survivor区。 当内存不足时，会产生OOM异常。 Java虚拟机栈线程私有，每一个线程都有一个自己的栈。 线程每执行一个方法，都会创建一个栈帧，用于存储局部变量表（对象引用，基本数据类型）等。方法调用直至完成的过程中，就是一个栈帧入栈和出栈的过程。两种异常情况： 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常； 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小： 1java -Xss512M HackTheJava 本地方法栈与Java虚拟机栈类似，只不过一个是为Java方法服务，一个是为Native方法服务，其他都一样。Native方法就是Java调用非Java代码的接口。例如调用C语言实现的接口。 程序计数器可以看作是当前线程执行到的字节码的行号指示器。对于Java的多线程，为了使程序每次切换后能够恢复到正确的执行位置，因此每一个线程必须要有自己独立的程序计数器。如果线程执行的是Java方法，记录的是正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。 方法区各个线程共享的区域。存放的是虚拟机加载的类信息，常量，静态变量。 在HotSpot中，永久代是方法区的实现。因为GC分代收集拓展到方法区。方法区主要是废弃类和常量的收集，对于方法区，也可以选择不进行垃圾回收。 一般来说，方法区不进行垃圾收集。 在jdk1.8之后，HotSpot中，删去了永久代，永久代的相关信息存放在了元空间。 元空间与永久代最大的不同就是，元空间并不在JVM中，而是在本地内存。主要原因还是因为永久代的大小难以确定，容易发生OOM，而移到元空间，只会受到本地内存大小的限制。 运行时常量池运行时常量池是方法区的一部分。 class常量池：我们写的每一个Java类被编译后，就会形成一份class文件；class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)。 class常量池在类加载完成后就会放入运行时常量池存放。 字符串常量池：存放字符串，位于堆内。常量池中同时存在字符串常量和字符串引用。直接赋值和用字符串调用String构造函数都可能导致常量池中生成字符串常量;而intern()方法会尝试将堆中对象的引用放入常量池。 类加载子系统类加载子系统负责从文件系统或者网络中加载 Class 信息，加载的类信息存放于一块称 为方法区的内存空间。 局部变量表所需要的内存空间在编译阶段就分配完毕。 对象的创建过程 虚拟机遇到一个new指令，首先从常量池中获取这个类的符号引用，检查这个符号引用代表的类是否被加载。 要是没有被加载，必须执行相应的类加载的过程。 为对象分配内存，主要有指针碰撞和空闲列表两种办法。指针碰撞是所有使用过的内存放一边，未使用过的内存放一边，中间一个指针作为分界线，当为一个对象分配内存的时候，直接移动指针即可。空闲列表适用于空闲内存和使用过的内存互相交错，内存的使用情况都存在一个表上，根据这个表再去分配内存。指针碰撞适用于标记-整理算法，空闲列表适用于标记-清除算法。 但是，如何解决分配内存过程中的并发问题呢？ 一个就是同步加锁。 另一个就是TLAB的使用，预先个每个线程在Java堆中都分配了一小块内存，哪个线程要给对象分配内存，直接在自己的TLAB中分配，当TLAB用完了，再分配新的，这一步才需要加锁。 设置对象头 执行init方法，初始化成员变量。 对象的内存布局对象在内存中主要分为三个部分：对象头，实例数据以及对齐填充。 对象头主要结构是由Mark Word 和 Class Metadata Address 组成 。Class Metadata Address存储的是该对象属于类的地址，即可以判断这个对象属于哪一个类。 MarkWord有五种类型：]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象概述]]></title>
    <url>%2F2019%2F09%2F19%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[面向对象有三大特性： 封装。只对外提供接口由外界访问。 继承。 多态。多态的三个条件：继承，重写，以及向上转型（父类引用指向子类对象）。 访问权限修饰符private:除了自己没有其他任何类可以访问。protected:同一包下的，以及自己的自类可以访问。default：同一包下面的。public：任何类都可以访问。 重写与重载重写：override，重新实现父类的方法。发生在运行期，动态分派。重载：方法名称相同，参数不同。返回值类型不同，参数类型相同不算是重载。发生在编译器，静态分派。 抽象类和接口抽象类使用abstract关键字声明，且抽象类至少应该包含一个抽象方法(只有声明没有实现)。 抽象类不可以被实例化。 抽象方法不能是private，这样方法就不能继承了。抽象类不能是final的。 接口在JDK8之前，没有任何方法的实现。从JDK8之后，接口也可以有默认方法的实现。 接口的成员都只能是public的。 接口的字段是public static final的，因此，接口字段一旦定义就不可以改了。 但是，在JDK1.8之后，interface加了一些新的特性。 可以添加静态方法。 1234567public interface TestInterface &#123; public static String sayHello() &#123; return "Hello world!"; &#125;&#125; 可以为接口方法提供一个默认实现。使用default标记。 12345678interface MyInterface&#123; String myNewName(String newName); default String myOldName()&#123; return "chao"; &#125;&#125; 区别 类只可以继承一个抽象类，却可以实现多个接口。 接口字段是static final的，不可以再去修改的，而抽象类却没有这种要求。 接口成员是public的，抽象类却没有这种要求。 super关于构造方法当new一个子类的时候，一定会先调用父类的构造方法，然后再去调用子类的构造方法。 123456789101112131415161718public class Parent &#123; public Parent()&#123; System.out.println("parent"); &#125;&#125;public class Son extends Parent &#123; public Son()&#123; System.out.println("son"); &#125;&#125;Son son = new Son();/*输出：parent son也就是说。当构造一个子类的时候，一定会先调用父类的构造方法。默认是调用父类无参的构造函数，若是想调用其它构造函数，可以通过super关键字实现。*/ 既然创建子类对象的时候，一定会先调用父类的构造方法，那么是否创建了父类呢？ 答案是没有。 只是创建了一个子类对象，this完全引用这个子类对象，super引用子类可以继承的成员变量以及方法。 super作用 访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super 函数。 访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。 内部类在一个类中再定义一个类。 内部类的好处 内部类可以访问外部类的所有成员，包括private。 为什么内部类可以随意访问外部类的成员？ 持有引用。当外部类的对象创建了一个内部类的对象时，内部类对象必定会秘密捕获一个指向外部类对象的引用，然后访问外部类的成员时，就是用那个引用来选择外围类的成员的。当然这些编辑器已经帮我们处理了。 内部类可以对外隐藏。 可以实现多重继承。 12345678910111213141516171819202122232425262728293031323334353637383940//类一public class ClassA &#123; public String name()&#123; return "liutao"; &#125; public String doSomeThing()&#123; // doSomeThing &#125;&#125;//类二public class ClassB &#123; public int age()&#123; return 25; &#125;&#125;//类三public class MainExample&#123; private class Test1 extends ClassA&#123; public String name()&#123; return super.name(); &#125; &#125; private class Test2 extends ClassB&#123; public int age()&#123; return super.age(); &#125; &#125; public String name()&#123; return new Test1().name(); &#125; public int age()&#123; return new Test2().age(); &#125; public static void main(String args[])&#123; MainExample mi=new MainExample(); System.out.println("姓名:"+mi.name()); System.out.println("年龄:"+mi.age()); &#125;&#125; 内部类与外部类的关系 对于非静态内部类，内部类的创建依赖外部类的实例对象，在没有外部类实例之前是无法创建内部类的。先有外部类对象，再有内部类对象。 对于静态内部类，内部类并不依赖于外部类对象的创建，static依赖于类本身，并不依赖类实例对象。 普通内部类不可以有静态成员，因为普通内部类需要依赖于外部对象而存在，需要outer.new InnerClass();，他是与对象相关的。 静态可以访问静态的，不可以访问非静态的；非静态静态和非静态都可以访问。所以，静态内部类不可以访问外部类非静态成员。 内部类创建12ClassOuter outer = new ClassOuter();ClassOuter.InnerClass inner = outer.new InnerClass(); 普通内部类123456public class InnerClassTest &#123; public class InnerClassA &#123; &#125;&#125; 内部类对象可以访问外部类对象中所有访问权限的字段，同时，外部类对象也可以通过内部类的对象引用来访问内部类中定义的所有访问权限的字段。 静态内部类静态内部类就像外部类的一个静态成员一样，创建其对象无需依赖外部类对象（访问一个类的静态成员也无需依赖这个类的对象，因为它是独立于所有类的对象的）。但是于此同时，静态内部类中也无法访问外部类的非静态成员，因为外部类的非静态成员是属于每一个外部类对象的，而本身静态内部类就是独立外部类对象存在的，所以静态内部类不能访问外部类的非静态成员，而外部类依然可以访问静态内部类对象的所有访问权限的成员，这一点和普通内部类无异。 匿名内部类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class InnerClassTest &#123; public int field1 = 1; protected int field2 = 2; int field3 = 3; private int field4 = 4; public InnerClassTest() &#123; System.out.println("创建 " + this.getClass().getSimpleName() + " 对象"); &#125; // 自定义接口 interface OnClickListener &#123; void onClick(Object obj); &#125; private void anonymousClassTest() &#123; // 在这个过程中会新建一个匿名内部类对象， // 这个匿名内部类实现了 OnClickListener 接口并重写 onClick 方法 OnClickListener clickListener = new OnClickListener() &#123; // 可以在内部类中定义属性，但是只能在当前内部类中使用， // 无法在外部类中使用，因为外部类无法获取当前匿名内部类的类名， // 也就无法创建匿名内部类的对象 int field = 1; @Override public void onClick(Object obj) &#123; System.out.println("对象 " + obj + " 被点击"); System.out.println("其外部类的 field1 字段的值为: " + field1); System.out.println("其外部类的 field2 字段的值为: " + field2); System.out.println("其外部类的 field3 字段的值为: " + field3); System.out.println("其外部类的 field4 字段的值为: " + field4); &#125; &#125;; // new Object() 过程会新建一个匿名内部类，继承于 Object 类， // 并重写了 toString() 方法 clickListener.onClick(new Object() &#123; @Override public String toString() &#123; return "obj1"; &#125; &#125;); &#125; public static void main(String[] args) &#123; InnerClassTest outObj = new InnerClassTest(); outObj.anonymousClassTest(); &#125;&#125; 匿名内部类中可以使用外部类的属性，但是外部类却不能使用匿名内部类中定义的属性，因为是匿名内部类，因此在外部类中无法获取这个类的类名，也就无法得到属性信息。 当匿名内部类访问局部变量的时候，局部变量必须是final的。 12345678910111213141516171819public class Button &#123; public void click(final int params)&#123; //匿名内部类，实现的是ActionListener接口 new ActionListener()&#123; public void onAction()&#123; System.out.println("click action..." + params); &#125; &#125;.onAction(); &#125; //匿名内部类必须继承或实现一个已有的接口 public interface ActionListener&#123; public void onAction(); &#125; public static void main(String[] args) &#123; Button button=new Button(); button.click(); &#125;&#125; 原因是：因为局部变量和匿名内部类的生命周期不同。 匿名内部类是创建后是存储在堆中的，而方法中的局部变量是存储在Java栈中，当方法执行完毕后，就进行退栈，同时局部变量也会消失。那么此时匿名内部类还有可能在堆中存储着，那么匿名内部类要到哪里去找这个局部变量呢？ 为了解决这个问题编译器为自动地帮我们在匿名内部类中创建了一个局部变量的备份，也就是说即使方法执结束，匿名内部类中还有一个备份，自然就不怕找不到了。 但是问题又来了。如果局部变量中的a不停的在变化。那么岂不是也要让备份的a变量无时无刻的变化。为了保持局部变量与匿名内部类中备份域保持一致。编译器不得不规定死这些局部域必须是常量，一旦赋值不能再发生变化了。所以为什么匿名内部类应用外部方法的域必须是常量域的原因所在了。 特别注意：在Java8中已经去掉要对final的修饰限制，但其实只要在匿名内部类使用了，该变量还是会自动变为final类型（只能使用，不能赋值）。 内部类导致内存泄漏 如果一个匿名内部类没有被任何引用持有，那么匿名内部类对象用完就有机会被回收。 如果内部类仅仅只是在外部类中被引用，当外部类的不再被引用时，外部类和内部类就可以都被GC回收。 如果当内部类的引用被外部类以外的其他类引用时，就会造成内部类和外部类无法被GC回收的情况，即使外部类没有被引用，因为内部类持有指向外部类的引用）。 所以，内部类内存泄露的原因就是有外部类以外的其他引用，这样内部类和外部类都无法被回收。 可以通过使用静态内部类来解决。 分析内部类]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 基础]]></title>
    <url>%2F2019%2F09%2F18%2Fjava-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[包装类型装箱12// 装箱 调用了 Integer.valueOf(2)，将int变成了一个Integer对象Integer x = 2; 装箱转换是指将一个值类型隐式地转换成一个object 类型，也就是创建一个object 实例并将这个值复制给这个object。 拆箱拆箱转换是指将一个对象类型显式地转换成一个值类型。 12Integer x = 2; //装箱int y = x; // 拆箱 调用了 X.intValue() 装箱和拆箱会造成相当大的性能损耗，因此尽量应该避免大量的装箱拆箱操作。 缓存池new Integer()与Integer.Valueof()区别： new Integer每次都会新建一个对象 Integer.Valueof()会复用缓存池中的对象 123456Integer x = new Integer(123);Integer y = new Integer(123);System.out.println(x == y); // falseInteger z = Integer.valueOf(123);Integer k = Integer.valueOf(123);System.out.println(z == k); // true 编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。 123//a = bInteger a = 123;Integer b = 123; String基本类型的变量数据都是存在栈中的，String常量放在常量池里面，String对象放在堆里面。 String常量String常量存放在常量池里面，常量池中相同的值只有一个。 123String s1="hello";String s2="hello";System.out.println(s1==s2);//true 第一句代码执行后就在常量池中创建了一个值为hello的String对象； 第二句执行时，因为常量池中存在hello所以就不再创建新的String对象了。 此时该字符串的引用在虚拟机栈里面。 因为s1和s2指向的是同一个对象，所以s1==s2 String对象String对象的本质是一个不可变的char数组。 123String a = new String("skj");String b = new String("skj");System.out.println(a==b);//false new String(“skj”)这一步到底做了什么？ 在字符串常量池里面创建一个对象，就是”skj”,首先会检查常量池里面有没有这个对象”skj”，没有的话在创建并返回对象的引用，有的话就直接返回这个对象的引用。 在堆上创建一个对象， new String，String对象的本质就是一个char数组，所以String对象中的char数组指向之前返回对象的引用 所以，new String(“skj”)这一句实际上是创建了两个对象，一个在字符串常量池，一个在堆上。 String特性 Strings are constant; their values cannot be changed after they are created. String buffers support mutable strings. Because String objects are immutable they can be shared. String是不可变的，因为String的本质是一个final char[]，所以String同时又是线程安全的。 String由final修饰，是不可以继承的。 字符串拼接问题12String str0 = "a";String str1 = str0 + "b"; 编译成字节码： 123456789101112131415 public static void main(java.lang.String[]); Code: 0: ldc #2 // String a 2: astore_1 3: new #3 // class java/lang/StringBuilder 6: dup 7: invokespecial #4 // Method java/lang/StringBuilder."&lt;init&gt;":()V 10: aload_1 11: invokevirtual #5 // Method java/lang/StringBuilder.append(Ljava/lang/String;)Ljava/lang/StringBuilder; 14: ldc #6 // String b 16: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 19: invokevirtual #7 // Method java/lang/StringBuilder.toString()Ljava/lang/String; 22: astore_2 23: return&#125; 转换成java就是： 12345String str0 = "a";StringBuilder sb = new StringBuilder();sb.append(str0).append("b");String str1 = sb.toString();return str1; 所以，字符串的拼接主要是通过StringBuilder来实现的。 要注意的是最后还有toString，返回的是一个String对象。 为什么返回的是一个新的String对象呢？ 因为String类的char数组是final的，他的指针一旦指向了常量池的某个String，就不可以再改变了. 1234String str0 = "a";for (int i = 0; i &lt; 10000; i++) &#123; str0 += "a";&#125; 当我们在循环体中进行字符串拼接，在循环体里面，每次拼接都会生成一个StringBuilder的临时对象，那么这个程序片段执行下去就会产生10000个StringBuilder的临时对象，这10000个临时对象都是必要的吗？显然不是，我们可以在循环体外直接创建一个StringBuilder对象，然后在循环体中通过append方法拼接字符串，这样就省下了创建并回收10000个临时对象的消耗。 因此，当我们大量使用字符串拼接的时候，还是使用StringBuilder比较好。 拼接示例 使用字符串连接符拼接 ： String s2=”se”+”cond”; 使用字符串加引用拼接 ： String s12=”first”+s2; 使用new String(“”)创建 ： String s3 = new String(“three”); 使用new String(“”)拼接 ： String s4 = new String(“fo”)+”ur”; 使用new String(“”)拼接 ： String s5 = new String(“fo”)+new String(“ur”); s2 ：这个在编译期间就自动进行了优化的，在常量池中存储一个”second”，并且s2指向它。 s12 ： JVM对于字符串引用，由于在字符串的”+”连接中，有字符串引用存在，而引用的值在程序编译期是无法确定的，即(&quot;first&quot;+s2)无法被编译器优化，只有在程序运行期来动态分配使用StringBuilder连接后的新String对象赋给s12。(编译器创建一个StringBuilder对象，并调用append()方法，最后调用toString()创建新String对象，以包含修改后的字符串内容)，常量池中并没有产生新的字符串常量。 s3 ： 用new String() 创建的字符串不是常量，不能在编译期就确定，所以new String() 创建的字符串不放入常量池中，它们有自己的地址空间。但是”three”字符串常量在编译期也会被加入到字符串常量池（如果不存在的话） s4 ： 同样不能在编译期确定，但是”fo”和”ur”这两个字符串常量也会添加到字符串常量池中，并且在堆中创建String对象。（字符串常量池并不会存放”four”这个字符串） s5 ： 原理同s4。 StringBuilderString的内部实现是一个用final的数组，因此String对象是不可变的，我们每次修改String时，实际上都是new出来了一个新的对象。因此，对于经常进行字符串的修改操作时，String类就需要不断创建新对象，性能极低。StringBuilder内部也是封装的一个字符数组，只不过该数组非final修饰，可以不断修改。所以对于一些经常需要修改字符串的情况，我们应首选StringBuilder。 123456789/** * The value is used for character storage. */ char[] value; /** * The count is the number of characters used. */ int count; append()1234567891011121314151617public AbstractStringBuilder append(String str) &#123; if (str == null) return appendNull(); int len = str.length(); ensureCapacityInternal(count + len); str.getChars(0, len, value, count); count += len; return this;&#125;private void ensureCapacityInternal(int minimumCapacity) &#123; // overflow-conscious code if (minimumCapacity - value.length &gt; 0) &#123; value = Arrays.copyOf(value, newCapacity(minimumCapacity)); &#125; &#125; 我们可以看到，当StringBuilder添加元素的时候，首先判断char[]是否满了，要是满了，Arrays.copyOf对数组进行扩容（返回的是一个新数组）。最后append的方法返回的this，也就是说，与String不同，他并没有创建一个新的对象，主要原因还是char[]不是final的，是可变的，他就可以转换新的指向。 StringBuilder，StringBuffer，String区别StringBuffer和StringBuilder都继承了抽象类AbstractStringBuilder，这个抽象类和String一样也定义了char[] value和int count，但是与String类不同的是，它们没有final修饰符。因此得出结论：String、StringBuffer和StringBuilder在本质上都是字符数组，不同的是，在进行连接操作时，String每次返回一个新的String实例，而StringBuffer和StringBuilder的append方法直接返回this，所以这就是为什么在进行大量字符串连接运算时，不推荐使用String，而推荐StringBuffer和StringBuilder。那么，哪种情况使用StringBuffe？哪种情况使用StringBuilder呢？ 12345678910public StringBuilder append(String str) &#123; super.append(str); return this; &#125;public synchronized StringBuffer append(String str) &#123; toStringCache = null; super.append(str); return this; &#125; 区别很明显，StringBuffer加了synchronized关键字，是线程安全的。 为何String要设计成不可变的？ 线程安全 字符串常量池的需要。字符串常量池的诞生是为了提升效率和减少内存分配。可以说我们编程有百分之八十的时间在处理字符串，而处理的字符串中有很大概率会出现重复的情况。正因为String的不可变性，常量池很容易被管理和优化。 字符串不变，HashCode也不变，便于缓存Hash Code，不需要重复计算HashCode。 intern()字符串常量池是在编译期间产生的，通过String的intern()也可以在运行时向字符串常量池放入字符串。 When the intern method is invoked, if the pool already contains a string equal to this String object as determined by the equals(Object) method, then the string from the pool is returned. Otherwise, this String object is added to the pool and a reference to this String object is returned. 简单来说就是intern用来返回常量池中的某字符串，如果常量池中已经存在该字符串，则直接返回常量池中该对象的引用。否则，在常量池中加入该对象，然后 返回引用。 123456789101112131415public static void main(String[] args) &#123; String s = new String("1"); s.intern(); String s2 = "1"; System.out.println(s == s2); String s3 = new String("1") + new String("1"); s3.intern(); String s4 = "11"; System.out.println(s3 == s4);&#125;/**输出：false true**/ 分析一下： 先看s3和s4.String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);，这样，在字符串常量池创建了一个”1”，并且在堆里也创建了一个对象”11”，但在11中是没有对象的。s3.intern()，先去常量池看看有没有”11”，没有，需要在常量池中存储一份”11”，但是在jdk8中常量池已经转移到堆中了，所以可以直接存储堆中的引用(在jdk6之前，常量池还在perm区，就需要再在常量池中存储一份)。所以，s4实际上是指向堆上对象的引用。 再看s1和s2.String s = new String(&quot;1&quot;);在常量池内已经存储了1，所以s3.intern()啥也没做，s还是指向堆上的对象，s1指向的是常量池的对象。 所以，String#intern 方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象。 String#intern的使用 位运算符&amp;:按位与 |:按位或 ~:异或 ^:取反 &lt;&lt;:左移位运算，同理还有右移位运算。 关键字final数据：声明数据为常量，一旦初始化之后及不可以改变。 方法：声明方法不可以被重写。 类：声明类不可以被继承。 static静态变量：类变量，这个变量是属于这个类的，类的所有实例共享，在内存中只存在一份。 静态方法：他在类加载的时候就存在了，它不依赖于任何实例，所以static方法必须实现。 static代码块：在类初始化的时候执行一次。 静态成员不可以访问非静态成员，非静态成员可以访问静态成员和非静态成员。 Object方法equals() and hashCode()hashcode()返回的是散列值，equals()用来判断两个对象是否等价，所以在重写equals()方法时一定要先重写hashcode()。等价的对象散列值一定相同，但是散列值相同对象不一定等价。 clone()需要实现Clonable接口并重写clone()方法，才可以实现拷贝。 123456789public class CloneExample implements Cloneable &#123; private int a; private int b; @Override public Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; 浅拷贝拷贝这个对象的时候，只对基本数据类型进行拷贝，而引用数据类型只是进行了引用的传递，这两个对象还是共享的引用数据类型。 1234567891011121314151617181920212223242526272829303132333435public class ShallowCloneExample implements Cloneable &#123; private int[] arr; public ShallowCloneExample() &#123; arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = i; &#125; &#125; public void set(int index, int value) &#123; arr[index] = value; &#125; public int get(int index) &#123; return arr[index]; &#125; @Override protected ShallowCloneExample clone() throws CloneNotSupportedException &#123; return (ShallowCloneExample) super.clone(); &#125;&#125;ShallowCloneExample e1 = new ShallowCloneExample();ShallowCloneExample e2 = null;try &#123; e2 = e1.clone();&#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace();&#125;e1.set(2, 222);System.out.println(e2.get(2)); // 222,e1修改了，e2也变了，说明两人引用的是同一个对象 深拷贝在对引用数据类型拷贝的时候，创建了一个新的对象。 123456789101112131415161718192021222324252627282930313233343536373839public class DeepCloneExample implements Cloneable &#123; private int[] arr; public DeepCloneExample() &#123; arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = i; &#125; &#125; public void set(int index, int value) &#123; arr[index] = value; &#125; public int get(int index) &#123; return arr[index]; &#125; @Override protected DeepCloneExample clone() throws CloneNotSupportedException &#123; DeepCloneExample result = (DeepCloneExample) super.clone(); result.arr = new int[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; result.arr[i] = arr[i]; &#125; return result; &#125;&#125;DeepCloneExample e1 = new DeepCloneExample();DeepCloneExample e2 = null;try &#123; e2 = e1.clone();&#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace();&#125;e1.set(2, 222);System.out.println(e2.get(2)); // 2 但是，一般来说，不推荐使用clone，可以使用拷贝构造函数来做。 12345678910111213141516171819202122232425262728293031public class CloneConstructorExample &#123; private int[] arr; public CloneConstructorExample() &#123; arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = i; &#125; &#125; public CloneConstructorExample(CloneConstructorExample original) &#123; arr = new int[original.arr.length]; for (int i = 0; i &lt; original.arr.length; i++) &#123; arr[i] = original.arr[i]; &#125; &#125; public void set(int index, int value) &#123; arr[index] = value; &#125; public int get(int index) &#123; return arr[index]; &#125;&#125;CloneConstructorExample e1 = new CloneConstructorExample();CloneConstructorExample e2 = new CloneConstructorExample(e1);e1.set(2, 222);System.out.println(e2.get(2)); // 2 反射反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。 当我们的程序在运行时，需要动态的加载一些类这些类可能之前用不到所以不用加载到jvm，而是在运行时根据需要才加载，这样的好处对于服务器来说不言而喻。 举个例子我们的项目底层有时是用mysql，有时用oracle，需要动态地根据实际情况加载驱动类，这个时候反射就有用了，假设 com.java.dbtest.myqlConnection，com.java.dbtest.oracleConnection这两个类我们要用，这时候我们的程序就写得比较动态化，通过Class tc = Class.forName(“com.java.dbtest.TestConnection”);通过类的全类名让jvm在服务器中找到并加载这个类，而如果是oracle则传入的参数就变成另一个了。 反射使用获取class对象1Class s = Class.forName("java.lang.String"); 创建实例1s.newInstance(); 获取方法123456//获取类或接口生命的方法，但不包括继承的方法public Method[] getDeclaredMethods() throws SecurityException//获取公有方法public Method[] getMethods() throws SecurityException//获取特定的方法，根据参数方法名以及参数类型public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 获取变量信息 getFiled：访问公有的成员变量 getDeclaredField：所有已声明的成员变量，但不能得到其父类的成员变量 调用方法通过invoke 123456789101112public class test1 &#123; public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123; Class&lt;?&gt; klass = methodClass.class; //创建methodClass的实例 Object obj = klass.newInstance(); //获取methodClass类的add方法 Method method = klass.getMethod("add",int.class,int.class); //调用method对应的方法 =&gt; add(1,4) Object result = method.invoke(obj,1,4); System.out.println(result); &#125;&#125; 访问私有方法和私有变量甚至可以通过反射访问私有成员。 只需要setAccessible(true)即可。 123456789101112131415161718192021222324private static void modifyPrivateFiled() throws Exception &#123; //1. 获取 Class 类实例 TestClass testClass = new TestClass(); Class mClass = testClass.getClass(); //2. 获取私有变量 Field privateField = mClass.getDeclaredField("MSG"); //3. 操作私有变量 if (privateField != null) &#123; //获取私有变量的访问权 privateField.setAccessible(true); //修改私有变量，并输出以测试 System.out.println("Before Modify：MSG = " + testClass.getMsg()); //调用 set(object , value) 修改变量的值 //privateField 是获取到的私有变量 //testClass 要操作的对象 //"Modified" 为要修改成的值 privateField.set(testClass, "Modified"); System.out.println("After Modify：MSG = " + testClass.getMsg()); &#125;&#125; 反射机制 深入解析Java反射 异常Exception可以通过try catch处理并且使程序恢复。 Error是程序运行时错误，程序会崩溃并且无法恢复。 泛型泛型就是参数化类型，在泛型使用过程中，操作类型的数据类型被定义为一个参数。 泛型最常见的使用是在容器中，我们给容器添加泛型，这样我们可以把所需要的类型作为参数传递给容器，这样，容器就可以接受所有类型的数据，而且同时只能是一个数据，保证了程序的健壮性。 泛型主要有泛型类，泛型接口，泛型方法。 在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。 泛型类1234567891011121314//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public class Generic&lt;T&gt;&#123; //key这个成员变量的类型为T,T的类型由外部指定 private T key; public Generic(T key) &#123; //泛型构造方法形参key的类型也为T，T的类型由外部指定 this.key = key; &#125; public T getKey()&#123; //泛型方法getKey的返回值类型为T，T的类型由外部指定 return key; &#125;&#125; 泛型接口123public interface Generator&lt;T&gt; &#123; public T next();&#125; 泛型方法12345678910111213141516171819class DataHolder&lt;T&gt;&#123; T item; public void setData(T t) &#123; this.item=t; &#125; public T getData() &#123; return this.item; &#125; /** * 泛型方法 * @param e */ public &lt;E&gt; void PrinterInfo(E e) &#123; System.out.println(e); &#125;&#125; public 与返回值中间的E声明这是一个泛型方法，只有声明了才可以使用泛型 没有声明，只是传参的时候使用了泛型，并不是一个泛型方法。 与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。 123456789101112131415161718192021222324252627/** * 这是一个泛型类 */class GenericClassDemo&lt;T&gt; &#123; /** * 这个不是泛型方法，只是使用了泛型类中已声明的T */ public void show1(T t)&#123; System.out.println(t.toString()); &#125; /** * 泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。 * 由于下面的泛型方法在声明的时候声明了泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型， * 编译器也能够正确识别泛型方法中识别的泛型。 */ public &lt;E&gt; void show2(E e)&#123; System.out.println(e.toString()); &#125; /** * 在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型; * 可以与泛型类中声明的T不是同一种类型。 * show3和show2的E和T只是简单的代指泛型,与泛型类中的T并不是一个 */ public &lt;T&gt; void show3(T t)&#123; System.out.println(t.toString()); &#125;&#125; 泛型擦除1234567891011List&lt;String&gt; stringArrayList = new ArrayList&lt;String&gt;();List&lt;Integer&gt; integerArrayList = new ArrayList&lt;Integer&gt;();Class classStringArrayList = stringArrayList.getClass();Class classIntegerArrayList = integerArrayList.getClass();if(classStringArrayList.equals(classIntegerArrayList))&#123; System.out.println("----equals----");&#125;//输出：----equals---- 通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段 通配符上界通配符&lt;? extends T&gt;,只能放置T以及T的子类。下界通配符&lt;? superT&gt;,只能防止T以及T的父类。无界通配符&lt;?&gt; ,没有要求。深入理解泛型 泛型详解]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DirectIO和PageCache]]></title>
    <url>%2F2019%2F09%2F11%2FDirectIO%E5%92%8CPageCache%2F</url>
    <content type="text"><![CDATA[PageCachePageCache一页有4KB左右。 当需要写入磁盘的时候，若每写入一个字节数据就调用IO，这样效率就太低了，所以在操作系统的底层会有一个缓冲区，叫做PageCache，当PageCache中存满了，再写入磁盘，这样大大减少了磁盘IO的次数。 上图是写入磁盘的过程，我们使用MMap或者是FileChannel都会经过PageCache层。例如，我们使用FileChannel的时候，先写进DirectByteBuffer中，当buffer中数据满的时候，先写入PageCache，再写入磁盘。 同样的，读取数据也是一样的，将数据以及其邻近的一些数据读取到PageCache。 例如，当用户发起一个 fileChannel.read(4kb) 之后，实际发生了两件事 操作系统从磁盘加载了 16kb 进入 PageCache，这被称为预读 操作通从 PageCache 拷贝 4kb 进入用户内存 最终我们在用户内存访问到了 4kb，为什么顺序读快？很容量想到，当用户继续访问接下来的[4kb,16kb]的磁盘内容时，便是直接从 PageCache 去访问了。试想一下，当需要访问 16kb 的磁盘内容时，是发生4次磁盘 IO 快，还是发生1次磁盘 IO+4 次内存 IO 快呢？答案是显而易见的，这一切都是 PageCache 带来的优化。 DirectIO虽然PageCache很好，但是我们有时候并不希望使用PageCache。 当我们有时候进行随即读的时候，其实有时候并不需要PageCache的预读。 PageCache是操作系统层面上的概念，用很难干预，User BufferCache显然比PageCache要可控的多。 当操作系统回收 PageCache 内存的速度低于应用写缓存的速度时，会影响磁盘写入的速率，直接表现为写入 RT 增大，这被称之为“毛刺现象”。 而DirectIO可以绕过PageCache。]]></content>
      <tags>
        <tag>IO</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零拷贝的问题]]></title>
    <url>%2F2019%2F09%2F11%2F%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[传统的IO的操作读操作缓冲技术是IO的基础，一次读取大量数据放在缓冲区，需要的时候从缓冲区取得数据。 详细可见：内核缓冲区问题 一个完整的read操作：当应用程序发起read请求后，会检查内核空间内是否有需要读取的数据（pageCache）,如果有，直接copy到用户空间；如果没有，那么需要从磁盘读取，磁盘控制器通过DMA操作将数据从磁盘读取到内核空间，然后才从内核空间拷贝到用户空间。 DMA：不需要通过CPU调度，由DMA控制器来处理，不需要麻烦CPU。 读写操作使用传统的I/O程序读取文件内容, 并写入到另一个文件(或Socket)。性能开销比较大： 上下文切换(context switch), 此处有4次用户态和内核态的切换 Buffer内存开销, 一个是应用程序buffer, 另一个是系统读取buffer以及socket buffer。 需要进行四次拷贝，2次DMA copy和两次CPU copy。传统IO四次内容拷贝： 先将文件内容从磁盘中拷贝到操作系统buffer 再从操作系统buffer拷贝到程序应用buffer 从程序buffer拷贝到socket buffer 从socket buffer拷贝到协议引擎.零拷贝 MMap将物理内存映射到虚拟内存中。 在mmap之后，并没有在将文件内容加载到物理页上，只上在虚拟内存中分配了地址空间。当进程在访问这段地址时，若虚拟内存对应的page没有在物理内存中缓存，则产生”缺页”，将相应的页面载入物理内存。 mmap()会返回一个指针ptr，它指向进程逻辑地址空间中的一个地址，这样以后，进程无需再调用read或write对文件进行读写，而只需要通过ptr就能够操作文件。但是ptr所指向的是一个逻辑地址，要操作其中的数据，必须通过MMU将逻辑地址转换成物理地址，若MMU没有相应的映射，产生缺页中断，将页面重新置入内存。 省去了从内核缓冲区复制到用户空间的过程，只有从磁盘调入到物理内存的过程。它的最终目的是将磁盘中的文件映射到用户进程的虚拟地址空间，实现用户进程对文件的直接读写，减少了文件复制的开销，提高了用户的访问效率。 mmap+write如何映射，见更多细节。 sendFile拷贝过程： 首先通过DMA copy将数据从磁盘读取到kernel buffer中 然后通过CPU copy将数据从kernel buffer copy到sokcet buffer中 最终通过DMA copy将socket buffer中数据copy到网卡buffer中发送sendfile与read/write方式相比，少了一次复制，少了两次上下文切换。改进后的sendFilesendFile中间copy到socket buffer这一步仍是多余的。改进后的：拷贝过程： DMA copy将磁盘数据copy到kernel buffer中 向socket buffer中追加当前要发送的数据在kernel buffer中的位置和偏移量 DMA gather copy根据socket buffer中的位置和偏移量直接将kernel buffer中的数据copy到网卡上。 改进后的只有两次复制了。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>IO</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java nio操作实践]]></title>
    <url>%2F2019%2F07%2F26%2Fjava-nio%E6%93%8D%E4%BD%9C%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[java文件中文件IO主要包括普通IO，FileChannel以及MMap。本文主要介绍FileChannel以及MMap的一些原理以及使用，理解他们最好需要了解有关pageCache，内存零拷贝，堆外缓存的一些知识。 有关pageCache可见 PageCache和DirectIO ， 有关零拷贝可见 零拷贝问题 。 获取方式1234//获取FileChannelFileChannel fileChannel = new RandomAccessFile(new File("db.data"), "rw").getChannel();//获取MMapMappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0, filechannel.size()); FileChannel 写`` 123456789101112131415// 写byte[] data = new byte[4096];long position = 1024L;//指定 position 写入 data中 的数据fileChannel.write(ByteBuffer.wrap(data), position);//从当前文件指针的位置写入 4kb 的数据fileChannel.write(ByteBuffer.wrap(data));// 读ByteBuffer buffer = ByteBuffer.allocate(4096);long position = 1024L;//指定 position 读取 4kb 的数据到bufferfileChannel.read(buffer,position)；//从当前文件指针的位置读取 4kb 的数据fileChannel.read(buffer); FileChannel+ByteBuffer可以达到写入速度比较快，要是没有缓冲区的存在，FileChannel写入速度并不比普通IO，一般来说缓冲区的大小是由磁盘决定的。 那么，FileChannel是直接把ByteBuffer写到磁盘的吗？ 不是，中间还隔着一个PageCache。当ByteBUffer是堆内内存时，数据需要经历ByteBuffer-&gt;内核空间-&gt;PageCache。当ByteBufefr是直接内存，则省略到了从用户空间到内核空间的复制，直接ByteBuffer-&gt;PageCache，然后再从PageCache写回磁盘。 我们都知道磁盘 IO 和内存 IO 的速度可是相差了好几个数量级。我们可以认为 filechannel.write 写入 PageCache 便是完成了落盘操作，但实际上，操作系统最终帮我们完成了 PageCache 到磁盘的最终写入（这是异步的），理解了这个概念，你就应该能够理解 FileChannel 为什么提供了一个 force() 方法，用于通知操作系统进行及时的刷盘。 例如，RocketMQ刷盘方式： 异步刷盘方式：在返回写成功状态时，消息可能只是被写入了内存的PAGECACHE，写操作的返回快，吞吐量大；当内存里的消息量积累到一定程度时，统一触发写磁盘操作，快速写入 同步刷盘方式：在返回写成功状态时，消息已经被写入磁盘。具体流程是，消息写入内存的PAGECACHE后，立刻通知刷盘线程刷盘，然后等待刷盘完成，刷盘线程执行完成后唤醒等待的线程，返回消息写成功的状态。 MMap读写`` 12345678910111213141516171819// 写byte[] data = new byte[4];int position = 8;//从当前 mmap 指针的位置写入 4b 的数据mappedByteBuffer.put(data);//指定 position 写入 4b 的数据MappedByteBuffer subBuffer = mappedByteBuffer.slice();subBuffer.position(position);subBuffer.put(data);// 读byte[] data = new byte[4];int position = 8;//从当前 mmap 指针的位置读取 4b 的数据mappedByteBuffer.get(data)；//指定 position 读取 4b 的数据MappedByteBuffer subBuffer = mappedByteBuffer.slice();subBuffer.position(position);subBuffer.get(data); mmap是把文件映射到用户空间里的虚拟内存，这样就省去了从用户空间到内核空间的拷贝，这样，当我们需要向文件中写入数据时，先看虚拟内存中有没有对应的地址，即有没有将物理地址映射到虚拟内存，要是有的话，可以像操作内存一样操作这个文件，没有的话，产生缺页，加载相对应的页。 mmap 把文件映射到用户空间里的虚拟内存，省去了从内核缓冲区复制到用户空间的过程，文件中的位置在虚拟内存中有了对应的地址，可以像操作内存一样操作这个文件，相当于已经把整个文件放入内存，但在真正使用到这些数据前却不会消耗物理内存，也不会有读写磁盘的操作，只有真正使用这些数据时，也就是图像准备渲染在屏幕上时，虚拟内存管理系统 VMS 才根据缺页加载的机制从磁盘加载对应的数据块到物理内存进行渲染。这样的文件读写文件方式少了数据从内核缓存到用户空间的拷贝，效率很高。 但是，MMap是不适用于大量数据的。 因为一次map的大小在1.5G左右，要是大量数据的话必然要进行多次MMap，重复的map会带来虚拟内存回收，重新分配的问题。 MMAP 使用的是虚拟内存，和 PageCache 一样是由操作系统来控制刷盘的，虽然可以通过 force() 来手动控制，但这个时间把握不好，在小内存场景下会很令人头疼。 MMAP 的回收问题，当 MappedByteBuffer 不再需要时，可以手动释放占用的虚拟内存，但非常麻烦。 所以，对于小数据量刷盘的情况下，可以使用MMap，例如索引，但是其他场景，FileChannel+DirectByteBuffer完全可以替代，并且性能跟MMap差不多。 堆内内存与堆外内存 堆内内存 堆外内存 底层实现 数组，JVM 内存 unsafe.allocateMemory(size)返回直接内存 分配大小限制 -Xms-Xmx 配置的 JVM 内存相关，并且数组的大小有限制，在做测试时发现，当 JVM free memory 大于 1.5G 时，ByteBuffer.allocate(900M) 时会报错 可以通过 -XX:MaxDirectMemorySize 参数从 JVM 层面去限制，同时受到机器虚拟内存（说物理内存不太准确）的限制 垃圾回收 不必多说，gc自动回收 当 DirectByteBuffer 不再被使用时，会出发内部 cleaner 的钩子，保险起见，可以考虑手动回收：((DirectBuffer) buffer).cleaner().clean(); 内存复制 堆内内存 -&gt; 堆外内存 -&gt; pageCache 堆外内存 -&gt; pageCache 对于堆外内存，可使用池+堆外内存组合。例如：ThreadLocal&lt;ByteBuffer&gt; 和 ThreadLocal&lt;byte[]&gt;。 UnsafeReferrenceIO操作读写测试]]></content>
      <tags>
        <tag>java nio</tag>
      </tags>
  </entry>
</search>
